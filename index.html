<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="中文">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/rss2.xml" title="Light" type="application/atom+xml" />






<meta name="description" content="分享 交流">
<meta property="og:type" content="website">
<meta property="og:title" content="Light">
<meta property="og:url" content="http://wzlovegit.github.io/index.html">
<meta property="og:site_name" content="Light">
<meta property="og:description" content="分享 交流">
<meta property="og:locale" content="中文">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Light">
<meta name="twitter:description" content="分享 交流">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wzlovegit.github.io/"/>





  <title>Light</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="中文">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Light</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">王哲的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/11/18/acid base cap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/18/acid base cap/" itemprop="url">一气呵成了解分布式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-18T10:26:00+08:00">
                2018-11-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/base/" itemprop="url" rel="index">
                    <span itemprop="name">base</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>分布式的理念已经遍地开花，无论数据库存储、大规模计算、文件系统以及大多数商用软件的后台服务器都无法绕开分布式。相比于单机系统而言，分布式无论从理解上还是管理上复杂性都提高了不止一个量级，为什么大家还要选择用分布式？分布式在解决了某些问题的时候，又给我们带来了哪些新的问题？在设计分布式应用的时候，需要遵循哪些基本原则？日常我们又用过哪些分布式系统呢？本文将围绕上述的问题展开说明。</p>
<h1 id="分布式简介"><a href="#分布式简介" class="headerlink" title="分布式简介"></a>分布式简介</h1><h2 id="认识分布式系统"><a href="#认识分布式系统" class="headerlink" title="认识分布式系统"></a>认识分布式系统</h2><p>分布式系统将一组计算机组合起来，提供统一的服务。从使用者角度来看，分布式系统使用起来和单机系统是一样的。下面我们引用[1]中的例子进行说明。</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 1.36986301369863%;"><</div><div class="group-picture-column" style="width: 1.36986301369863%;">i</div><div class="group-picture-column" style="width: 1.36986301369863%;">m</div><div class="group-picture-column" style="width: 1.36986301369863%;">g</div><div class="group-picture-column" style="width: 1.36986301369863%;"> </div><div class="group-picture-column" style="width: 1.36986301369863%;">s</div><div class="group-picture-column" style="width: 1.36986301369863%;">r</div><div class="group-picture-column" style="width: 1.36986301369863%;">c</div><div class="group-picture-column" style="width: 1.36986301369863%;">=</div><div class="group-picture-column" style="width: 1.36986301369863%;">"</div><div class="group-picture-column" style="width: 1.36986301369863%;">/</div><div class="group-picture-column" style="width: 1.36986301369863%;">2</div><div class="group-picture-column" style="width: 1.36986301369863%;">0</div><div class="group-picture-column" style="width: 1.36986301369863%;">1</div><div class="group-picture-column" style="width: 1.36986301369863%;">8</div><div class="group-picture-column" style="width: 1.36986301369863%;">/</div><div class="group-picture-column" style="width: 1.36986301369863%;">1</div><div class="group-picture-column" style="width: 1.36986301369863%;">1</div><div class="group-picture-column" style="width: 1.36986301369863%;">/</div><div class="group-picture-column" style="width: 1.36986301369863%;">1</div><div class="group-picture-column" style="width: 1.36986301369863%;">8</div><div class="group-picture-column" style="width: 1.36986301369863%;">/</div><div class="group-picture-column" style="width: 1.36986301369863%;">a</div><div class="group-picture-column" style="width: 1.36986301369863%;">c</div><div class="group-picture-column" style="width: 1.36986301369863%;">i</div><div class="group-picture-column" style="width: 1.36986301369863%;">d</div><div class="group-picture-column" style="width: 1.36986301369863%;">%</div><div class="group-picture-column" style="width: 1.36986301369863%;">2</div><div class="group-picture-column" style="width: 1.36986301369863%;">0</div><div class="group-picture-column" style="width: 1.36986301369863%;">b</div><div class="group-picture-column" style="width: 1.36986301369863%;">a</div><div class="group-picture-column" style="width: 1.36986301369863%;">s</div><div class="group-picture-column" style="width: 1.36986301369863%;">e</div><div class="group-picture-column" style="width: 1.36986301369863%;">%</div><div class="group-picture-column" style="width: 1.36986301369863%;">2</div><div class="group-picture-column" style="width: 1.36986301369863%;">0</div><div class="group-picture-column" style="width: 1.36986301369863%;">c</div><div class="group-picture-column" style="width: 1.36986301369863%;">a</div><div class="group-picture-column" style="width: 1.36986301369863%;">p</div><div class="group-picture-column" style="width: 1.36986301369863%;">/</div><div class="group-picture-column" style="width: 1.36986301369863%;">t</div><div class="group-picture-column" style="width: 1.36986301369863%;">r</div><div class="group-picture-column" style="width: 1.36986301369863%;">a</div><div class="group-picture-column" style="width: 1.36986301369863%;">d</div><div class="group-picture-column" style="width: 1.36986301369863%;">i</div><div class="group-picture-column" style="width: 1.36986301369863%;">t</div><div class="group-picture-column" style="width: 1.36986301369863%;">i</div><div class="group-picture-column" style="width: 1.36986301369863%;">o</div><div class="group-picture-column" style="width: 1.36986301369863%;">n</div><div class="group-picture-column" style="width: 1.36986301369863%;">a</div><div class="group-picture-column" style="width: 1.36986301369863%;">l</div><div class="group-picture-column" style="width: 1.36986301369863%;">.</div><div class="group-picture-column" style="width: 1.36986301369863%;">p</div><div class="group-picture-column" style="width: 1.36986301369863%;">n</div><div class="group-picture-column" style="width: 1.36986301369863%;">g</div><div class="group-picture-column" style="width: 1.36986301369863%;">"</div><div class="group-picture-column" style="width: 1.36986301369863%;"> </div><div class="group-picture-column" style="width: 1.36986301369863%;">t</div><div class="group-picture-column" style="width: 1.36986301369863%;">i</div><div class="group-picture-column" style="width: 1.36986301369863%;">t</div><div class="group-picture-column" style="width: 1.36986301369863%;">l</div><div class="group-picture-column" style="width: 1.36986301369863%;">e</div><div class="group-picture-column" style="width: 1.36986301369863%;">=</div><div class="group-picture-column" style="width: 1.36986301369863%;">"</div><div class="group-picture-column" style="width: 1.36986301369863%;">一</div><div class="group-picture-column" style="width: 1.36986301369863%;">种</div><div class="group-picture-column" style="width: 1.36986301369863%;">传</div><div class="group-picture-column" style="width: 1.36986301369863%;">统</div><div class="group-picture-column" style="width: 1.36986301369863%;">技</div><div class="group-picture-column" style="width: 1.36986301369863%;">术</div><div class="group-picture-column" style="width: 1.36986301369863%;">栈</div><div class="group-picture-column" style="width: 1.36986301369863%;">"</div><div class="group-picture-column" style="width: 1.36986301369863%;">></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 1.36986301369863%;"><</div><div class="group-picture-column" style="width: 1.36986301369863%;">i</div><div class="group-picture-column" style="width: 1.36986301369863%;">m</div><div class="group-picture-column" style="width: 1.36986301369863%;">g</div><div class="group-picture-column" style="width: 1.36986301369863%;"> </div><div class="group-picture-column" style="width: 1.36986301369863%;">s</div><div class="group-picture-column" style="width: 1.36986301369863%;">r</div><div class="group-picture-column" style="width: 1.36986301369863%;">c</div><div class="group-picture-column" style="width: 1.36986301369863%;">=</div><div class="group-picture-column" style="width: 1.36986301369863%;">"</div><div class="group-picture-column" style="width: 1.36986301369863%;">/</div><div class="group-picture-column" style="width: 1.36986301369863%;">2</div><div class="group-picture-column" style="width: 1.36986301369863%;">0</div><div class="group-picture-column" style="width: 1.36986301369863%;">1</div><div class="group-picture-column" style="width: 1.36986301369863%;">8</div><div class="group-picture-column" style="width: 1.36986301369863%;">/</div><div class="group-picture-column" style="width: 1.36986301369863%;">1</div><div class="group-picture-column" style="width: 1.36986301369863%;">1</div><div class="group-picture-column" style="width: 1.36986301369863%;">/</div><div class="group-picture-column" style="width: 1.36986301369863%;">1</div><div class="group-picture-column" style="width: 1.36986301369863%;">8</div><div class="group-picture-column" style="width: 1.36986301369863%;">/</div><div class="group-picture-column" style="width: 1.36986301369863%;">a</div><div class="group-picture-column" style="width: 1.36986301369863%;">c</div><div class="group-picture-column" style="width: 1.36986301369863%;">i</div><div class="group-picture-column" style="width: 1.36986301369863%;">d</div><div class="group-picture-column" style="width: 1.36986301369863%;">%</div><div class="group-picture-column" style="width: 1.36986301369863%;">2</div><div class="group-picture-column" style="width: 1.36986301369863%;">0</div><div class="group-picture-column" style="width: 1.36986301369863%;">b</div><div class="group-picture-column" style="width: 1.36986301369863%;">a</div><div class="group-picture-column" style="width: 1.36986301369863%;">s</div><div class="group-picture-column" style="width: 1.36986301369863%;">e</div><div class="group-picture-column" style="width: 1.36986301369863%;">%</div><div class="group-picture-column" style="width: 1.36986301369863%;">2</div><div class="group-picture-column" style="width: 1.36986301369863%;">0</div><div class="group-picture-column" style="width: 1.36986301369863%;">c</div><div class="group-picture-column" style="width: 1.36986301369863%;">a</div><div class="group-picture-column" style="width: 1.36986301369863%;">p</div><div class="group-picture-column" style="width: 1.36986301369863%;">/</div><div class="group-picture-column" style="width: 1.36986301369863%;">d</div><div class="group-picture-column" style="width: 1.36986301369863%;">i</div><div class="group-picture-column" style="width: 1.36986301369863%;">s</div><div class="group-picture-column" style="width: 1.36986301369863%;">t</div><div class="group-picture-column" style="width: 1.36986301369863%;">r</div><div class="group-picture-column" style="width: 1.36986301369863%;">i</div><div class="group-picture-column" style="width: 1.36986301369863%;">b</div><div class="group-picture-column" style="width: 1.36986301369863%;">u</div><div class="group-picture-column" style="width: 1.36986301369863%;">t</div><div class="group-picture-column" style="width: 1.36986301369863%;">e</div><div class="group-picture-column" style="width: 1.36986301369863%;">.</div><div class="group-picture-column" style="width: 1.36986301369863%;">p</div><div class="group-picture-column" style="width: 1.36986301369863%;">n</div><div class="group-picture-column" style="width: 1.36986301369863%;">g</div><div class="group-picture-column" style="width: 1.36986301369863%;">"</div><div class="group-picture-column" style="width: 1.36986301369863%;"> </div><div class="group-picture-column" style="width: 1.36986301369863%;">t</div><div class="group-picture-column" style="width: 1.36986301369863%;">i</div><div class="group-picture-column" style="width: 1.36986301369863%;">t</div><div class="group-picture-column" style="width: 1.36986301369863%;">l</div><div class="group-picture-column" style="width: 1.36986301369863%;">e</div><div class="group-picture-column" style="width: 1.36986301369863%;">=</div><div class="group-picture-column" style="width: 1.36986301369863%;">"</div><div class="group-picture-column" style="width: 1.36986301369863%;">一</div><div class="group-picture-column" style="width: 1.36986301369863%;">种</div><div class="group-picture-column" style="width: 1.36986301369863%;">分</div><div class="group-picture-column" style="width: 1.36986301369863%;">布</div><div class="group-picture-column" style="width: 1.36986301369863%;">式</div><div class="group-picture-column" style="width: 1.36986301369863%;">技</div><div class="group-picture-column" style="width: 1.36986301369863%;">术</div><div class="group-picture-column" style="width: 1.36986301369863%;">栈</div><div class="group-picture-column" style="width: 1.36986301369863%;">"</div><div class="group-picture-column" style="width: 1.36986301369863%;">></div></div></div></div>
<p>我们重点关注左右两个图的数据库架构。传统数据库安装在一个单机 OS 的文件系统上，所有与该数据库的交互（CRUD）都需要该数据库完成。右图的分布式数据库中，用户可以和所有的数据库交互而不自知。比如，通常为了分担主库读写压力，MySQL 数据库会将读取请求分发到备库，如上图中，主库中插入了一条用户数据，在备库中查询这一条用户数据，然而这一切对用户都是透明的。</p>
<h2 id="分布式系统的成因"><a href="#分布式系统的成因" class="headerlink" title="分布式系统的成因"></a>分布式系统的成因</h2><p>相较于单机系统，开发、调试、部署、运维分布式系统的难度更大，甚至可以这样说，一个完整的运维监控平台是分布式系统商用必不可少的一部分：google 发表了 dapper 论文，facebook 开发了 zipkin 工具，spring cloud 也集成 sleuth 工具。几乎所有的商用分布式系统都有规模十分庞大的运维监控平台。那么问题来了，我们为什么要做分布式系统？</p>
<blockquote>
<p>此处声明一个观点：被逼的。分布式系统除了解决了单机系统面临的难题外，还引入了单机系统不存在的问题。有钱有势，我想没必要做分布式系统。想必大家在办事情的时候都遇到过“我们领导不在，你明天再来。”这种牛逼的回答。人家就是纯单机，领导不在直接不提供服务。</p>
</blockquote>
<p>言归正传，分布式系统解决了单机系统以下几个问题：</p>
<ol>
<li><p>水平扩展能力</p>
<p>想象一个情况，随着用户量变大，需求愈加复杂，有一天突然 CPU 90%，free -m 为10，投诉纷至沓来。正在老板焦头烂额之际，很多人提出了两个方案：1， 让码农加班优化；2，买主频更高的 CPU ，换更大的内存。第一种方案，等你优化完，项目组都解散了；第二种方案，多高算高，多大算大，臣妾做不到。这个时候大家就发现，单机系统有一个问题，用户量变大，会让系统瘫痪，而且是个绝症。然而我们做系统的目标就是让用户量变大，这违背了我们的初衷。<br>分布式很好地解决了上述问题。如右图所示，我们可以将数据库的读操作放到备库，在很多备库的情况下（即使这些备库只是普通计算机，而非超级计算机），查询的性能问题便能很好的解决。</p>
</li>
<li><p>更高的可用性</p>
<p>没有最坏，只有更坏。不幸的事情又发生了，数据库服务器的硬盘坏了，与某些情况下一样，不可恢复。灾难，用户数据一夜清零，从删库到跑路已经完成。这种涉及公司生死存亡的事故更是不允许的。<br>分布式也可以解决这种问题。如右图所示，主库不幸牺牲，备库中保存了全量的数据。这么多台主机，硬盘同时坏掉的可能性已经比全球断电、断网不高了。一台主机硬盘在某一时刻坏掉的可能性为 1/1000。根据概率论的知识可知 n 台主机在某一时刻同时坏掉的可能性为 (1/1000) ^ n。在 n &gt; 1 的情况下，分布式是可以保证比单机更高的可用性的。</p>
</li>
<li><p>更小的延迟</p>
<p>还是看右图，由于读取业务落到了多个备库，在大业务量处理时响应速度更快。由于备库部署到多个地域，用户访问的网络延时减少。所以利用分布式通常可以提供更小的延迟。</p>
</li>
</ol>
<h1 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h1><p>看完上面的介绍，是不是觉得分布式是完美的？然而事情总是具有两面性，分布式系统在解决单机系统出现的问题的同时，也引入了单机系统没有的问题。但分布式系统引入的问题比起拒绝服务来讲，对用户是比较友好的。</p>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>CAP (Conc)</p>
<h2 id="ACID-VS-BASE"><a href="#ACID-VS-BASE" class="headerlink" title="ACID VS BASE"></a>ACID VS BASE</h2><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote>
<p>[1] <a href="https://hackernoon.com/a-thorough-introduction-to-distributed-systems-3b91562c9b3c" target="_blank" rel="noopener">https://hackernoon.com/a-thorough-introduction-to-distributed-systems-3b91562c9b3c</a><br>[2] <a href="https://www.dummies.com/programming/big-data/hadoop/acid-versus-base-data-stores/" target="_blank" rel="noopener">https://www.dummies.com/programming/big-data/hadoop/acid-versus-base-data-stores/</a><br>[3] <a href="https://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="noopener">https://queue.acm.org/detail.cfm?id=1394128</a><br>[4] <a href="https://www.johndcook.com/blog/2009/07/06/brewer-cap-theorem-base/" target="_blank" rel="noopener">https://www.johndcook.com/blog/2009/07/06/brewer-cap-theorem-base/</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/10/21/rest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/21/rest/" itemprop="url">REST Introduction</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-21T17:26:00+08:00">
                2018-10-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/base/" itemprop="url" rel="index">
                    <span itemprop="name">base</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文翻译自 <a href="https://www.restapitutorial.com/" target="_blank" rel="noopener">https://www.restapitutorial.com/</a> ，继承协议 Creative Commons Attribution-ShareAlike 4.0 International License。转载请注明出处。</p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>与其他计算机技术一样，构建好一个 RESTful 服务也是科学与艺术的结合。互联网方兴未艾，如火如荼，采用业界最佳实践创建 REST API 变得越来越重要。由于 RESTful web 服务不遵循除 HTTP 以外的规定标准，因此根据行业最佳实践构建 RESTful API 以简化并提高客户端使用率变得非常重要。</p>
<p>目前没有很多可以帮助开发人员的 REST API 实践指南，RestApiTutorial.com 致力于专研 REST API 的最佳实践并且为开发人员提供资源，以便大家可以参考和自我学习。</p>
<h1 id="REST-简介"><a href="#REST-简介" class="headerlink" title="REST 简介"></a>REST 简介</h1><p>REST 架构包含 6 个约束，参见 <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="noopener">https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a> ：</p>
<ul>
<li><p>统一接口</p>
<p>统一接口用于简化和解耦客户端和服务端，以便于它们独立发展。统一接口设计的 4 个指导原则如下：</p>
<p><strong>基于资源</strong></p>
<p>请求中采用 URI 标识唯一资源。资源和返回给客户端的资源呈现是不同的，例如，服务器会将表示数据库记录的用UTF-8编码的 HTML，XML 或 JSON 数据发送给客户端，而不是将数据库返回给客户端。这里的 HTML，XML 或 JSON 等就是资源呈现，数据库真实的记录就是资源。</p>
<p><strong>通过资源呈现操作资源</strong></p>
<p>当客户端持有一个资源呈现及其附属的元数据时，它就应该具有足够多的信息在其权限允许的范围内增加、修改、删除服务器的资源。</p>
<p><strong>自描述消息</strong></p>
<p>每个消息需要包含如何处理它的足够信息，比如，采用 MIME 类型指定采用那个解析器处理消息，响应也需要明确指定它们的缓存能力。</p>
<p><strong>超媒体用作应用状态引擎（HATEOAS）</strong></p>
<p>客户端通过请求体、请求行、请求头传递状态到服务端，服务端通过响应体、响应码、响应头传递状态到客户端。这种方式称为超媒体。</p>
<p>除了上面的描述，HATEOAS 还意味着在必要的情况下，链接需要包含在返回的响应体重以便 URI 检索相关资源。</p>
<blockquote>
<p>统一接口是任何 REST 服务设计的基础</p>
</blockquote>
</li>
<li><p>无状态</p>
<p>REST 是 REpresentational <strong>State</strong> Transer （资源呈现状态迁移） 的简写，无状态是关键，也就是说处理当前请求所必需的状态就包含在该请求（无论是包含在 URI、查询参数、请求体、请求头）中，无需其它维系状态的手段。URI 唯一标识资源，请求体中包含资源的状态，服务器基于这两个信息处理完请求后通过响应头、响应体和状态码将结果状态返回给客户端。</p>
<p>有过工作经历的工程师都接触过 <strong>session</strong> 用于在服务器保存跨 HTTP 请求的业务状态，然而，在 REST 结构中，客户端需要维护所有的状态信息以便提供给服务器处理该请求，即便在该业务状态需要跨越多个 HTTP 请求的情况下，依旧需要客户端多次发送状态。无状态的条件下，服务器不用维系会话状态，使得服务器易于横向扩展。另外，无状态的使得服务器在设计负载均衡的时候无需考虑会话关系。</p>
<p>如何区分状态和资源？状态或应用状态是指服务器为了处理请求需要关注的信息，比如请求中携带的必要数据。资源或者资源状态是指资源呈现所指向的真正内容，比如数据库中的数据。每个客户端可以根据每次请求的需要更改应用状态，然而资源是在所有发起请求的客户端间是共享的常量。</p>
<p>是否遇到过由于 web 应用需要您按照既定顺序填写内容而您没有照做引起的服务失败？这正是因为它违背了无状态原则。然而某些场景确实无法做到无状态，比如 three-legged OAuth，API调用频率限制等，在这些场景下，您就需要尽可能保证服务一次性完成，避免服务跨越多个请求才能完成。</p>
</li>
</ul>
<ul>
<li><p>可缓存</p>
<p>和万维网一样，在 REST 架构中，客户端可以缓存响应，因此响应需要直接或间接的定义它们是否可以被缓存，以防止客户端在后续的请求中重用不恰当的数据。管理良好的缓存或多或少减少了客户端服务器的直接交互，更进一步提升了扩展性和性能。</p>
</li>
<li><p>C/S 模式</p>
<p>统一接口将客户端和服务器分开，这样的话，客户端无需考虑数据存储，交由服务器来完成，因此提升了客户端的可移植性；服务器不用考虑用户状态，因此提升了服务器的可扩展性和简单性。只要接口不发生变更，客户端和服务器可以独立开发和升级。</p>
</li>
<li><p>分层系统</p>
<p>客户端通常无法判断它是直连了终端服务器还是沿途的中间服务器，中间服务器可以通过启用负载均衡和共享缓存提供系统可伸缩性。分层机制也可以更加方面的实施安全保护措施。</p>
</li>
<li><p>Code on Demand(optional)</p>
<p>服务器可以通过传输客户端可以执行的逻辑扩展或定制客户端功能，比如包含客户端脚本（例如JS）和编译组件（例如 Java applets）。</p>
<p>符合 REST 风格，遵循上述约束可以带来诸如性能、可伸缩性、简单性、可修改性、可见性、可移植性和可靠性等诸多好处。</p>
<blockquote>
<p>注：Code on Demand 是唯一一个可选约束。如果违背了其他约束，那么该服务严格意义上并不是一个真正的 RESTful 服务。</p>
</blockquote>
</li>
</ul>
<h1 id="REST-API-小贴士"><a href="#REST-API-小贴士" class="headerlink" title="REST API 小贴士"></a>REST API 小贴士</h1><p>下面介绍 6 个 REST API 设计的小贴士，不管是不是严格的 RESTful 服务，这些小贴士都会帮助您设计出更好用的服务。</p>
<ul>
<li><p>合理运用 HTTP 中的动词<br>API 使用者可以发送 GET、POST、PUT 和 DELETE 这些动词给服务器，这极大地增强了请求的表达能力。主要的 HTTP 动词用法如下：</p>
<ul>
<li><strong>GET</strong><br><strong>查</strong>：读取（查询）某个指定资源或某个指定资源的集合。</li>
<li><strong>PUT</strong><br><strong>改</strong>：修改某个指定资源或某个自定资源的集合。如果预先知道资源标识符，PUT 也可以用于创建特定资源。</li>
<li><strong>DELETE</strong></li>
<li><strong>删</strong>：删除指定资源</li>
<li><strong>POST</strong><br><strong>增</strong>：创建一个新资源。对于不适合上述三类的操作，POST 是一个万金油动词。</li>
</ul>
</li>
<li><p>提供合理的资源名称<br>创建一个优秀的 API 来自于 80% 的艺术和 20% 的科学。采用层级性的 URL 用以合理表示资源是 API 设计的艺术部分。一个合理的资源名称（URL 路径，比如 /customers/12345/orders）有助于更加清晰的表达请求的内容。<br>合理的资源名称可以为服务请求提供上下文，使得 API 更易理解。URI 的层次性为 API 使用者提供友好的易于理解的资源层次结构，利于 API 在应用程序中使用。<br>下面是几个快速设计 URL （资源名称）的规则：</p>
<ul>
<li><strong>URL 中采用标识符代替查询字符串</strong>。查询字符串参数适合过滤但不适合用作资源名称。<br>好： /users/12345<br>差： /api?type=user&amp;id=23</li>
<li><strong>采用 URL 的分层特性来表示资源结构</strong>。</li>
<li><strong>面向用户设计资源名称，而非面向数据</strong>。</li>
<li><strong>资源名称采用名词命名，用 HTTP 方法指定动作</strong>。</li>
<li><strong>在 URL 的分层中，采用复数命名形式</strong>。使用复数可以使得 URL 在跨 HTTP 的方法保持一致。<br>好： /customers/33245/orders/8769/lineitems/1<br>坏： /customer/33245/order/8769/lineitem/1</li>
<li><strong>避免冗余的表示集合的命名方式</strong>。比如， customer_list 可以采用复数形式替换， customers。</li>
<li><strong>在 URL 分层中采用小写形式，使用下划线或连字符分隔单词</strong>。有些服务器大小写不敏感，因此最好保持一致性。</li>
<li><strong>在清楚表明语义的情况下，保持 URL 短小精悍</strong>。</li>
</ul>
</li>
</ul>
<ul>
<li><p>采用 HTTP 响应码表明处理状态</p>
<p>响应状态码是 HTTP 协议的一部分，它们涵盖了绝大部分常见的场景。由于 RESTful 也遵循 HTTP 规范，所以我们设计的 API 也应该返回相关的 HTTP 状态码。比如，在成功创建资源（比如来自 POST 请求）以后，API 应该返回 HTTP 状态码 201。下面是 TOP 10 常用的 HTTP 状态码列表:</p>
<p><strong>200 OK</strong><br>普通成功状态码，用于表示成功。<br><strong>201 CREATED</strong><br>资源创建成功（通过 POST 或 PUT）。将响应头中的 Location 字段设置为标识新资源的连接，响应体可有可无。<br><strong>204 NO CONTENT</strong><br>成功，但响应正文中没有任何内容，通常用于 DELETE 和 PUT 操作。<br><strong>400 BAD REQUEST</strong><br>处理请求时出现不合法的状态时的一般错误码。比如，数据格式错误、域名解析错误等。<br><strong>401 UNAUTHORIZED</strong><br>未携带或携带了错误的鉴权 token 时的错误码。<br><strong>403 FORBIDDEN</strong><br>用户没有认证权限执行该操作，或者资源不能被访问时的错误码。<br><strong>404 NOT FOUND</strong><br>找不到指定的资源时的错误码。不管是真的不存在或者存在 401 或 403，服务出于安全方面的考虑需要屏蔽。<br><strong>405 METHOD NOT ALLOWED</strong><br>请求的 URL 存在但不支持请求中的 HTTP 方法访问。比如 POST /users/12345，API 若不支持使用 POST 方法，返回 405 是必须设置 Allow 字段，诸如 GET, PUT, DELETE。<br><strong>409 CONFLICT</strong><br>执行请求时出现资源冲突。比如尝试创建相同信息的两个用户，或者不支持级联删除时删除根对象。<br><strong>500 INTERNAL SERVER ERROR</strong><br>不要故意返回 500 错误。服务端出现问题时会抛 500 错误，这种错误客户端无法解决。</p>
</li>
<li><p>同时支持 JSON 和 XML（JSON 大行其道，这个有待考量）</p>
<p>在不是很复杂的情况下，尽可能同时提供对 JSON 和 XML 的支持。理想情况下，让客户端采用 Accpet 字段指定格式，或者将 URL 上的 .xml 换成 .json 即可。<br>虽然我们建议支持 XML，但是除非必须，请尽量保持 XML 和 JSON 一样的简单实用。也就是说，XML 中也不支持架构和命名空间这些细节，只有数据和连接。如果完整支持 XML，其代价往往是高昂的。根据我们的实战经验，过去几年几乎没有使用过 XML 响应了，对于服务和客户端来讲都显得过于重了。<br>如果非要支持类似命名空间这些功能，JSON-Schema也是可以提供的。</p>
</li>
<li><p>创建细粒度资源<br>在最开始最好依托于底层应用程序和数据库的API来创建具有 CRUD 功能的资源，然后再利用小的资源构建更大的资源。</p>
</li>
<li>考虑连通性<br>通过超链接实现连通性是 REST 的一个重要原则。虽然不具备连通性的时候，服务依然是可用的，但是如果在响应中带有连接，那么 API 变得更具有自我描述性。至少我们可以通过链接通知客户端如何检索数据，还有，利用 HTTP Location 头域返回客户端通过 POST （或 PUT）创建的资源的连接。在支持分页响应时，”first”，”last”，”next”和”prev”非常有用。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/10/01/lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/01/lock/" itemprop="url">同步与互斥</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-01T09:15:00+08:00">
                2018-10-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/base/" itemprop="url" rel="index">
                    <span itemprop="name">base</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>随着计算机科学和实践的发展，多线程、多进程编程早已是后台工程师（无论框架还是服务器或是业务）需要熟知的重要基础知识之一。这个技术帮助工程师最大限度的利用冯诺依曼型计算机的资源，然而该技术在给资本家节约成本（当然也会提升人民生活的便利）的同时，提升了工程师编码的复杂度。</p>
</blockquote>
<p><strong>摘要</strong> 本文着重讨论多线程、多进程编程中的同步与互斥。<strong>名词解释</strong>部分对本文涉及到的重要名词进行说明，<strong>问题研讨</strong>部分对同步与互斥这一经典问题进行描述。</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><p><strong>定义</strong></p>
<p>计算机中的资源指的是操作系统管理的抽象资源。比如：内存、IO、CPU、锁等。</p>
</li>
</ul>
<h2 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h2><ul>
<li><p><strong>定义</strong></p>
<p>多道程序（多进程、多线程）系统中，一次只允许一道程序（一个线程、一个进程）使用的资源，称为<strong>临界资源</strong>。</p>
</li>
<li><p><strong>调皮一下</strong></p>
<p>现在假设厕所只有一个坑，小 A 占用的时候，小 B 只能等；小 B 占用的时候，小 A 只能等。厕所的坑是一个解决问题的重要资源，然而却不能被小 A 和小 B 同时使用，那么这个坑就是<strong>临界资源</strong>。</p>
<blockquote>
<p><strong>想法</strong>：计算机科学衍生自人类本身的经验科学和数学科学，因此有很多名词和编码理念取材于日常生活。而且计算机科学又非常高效地反馈了人类，取材于日常生活的理念，快速应用到解决日常问题。</p>
</blockquote>
</li>
</ul>
<h2 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h2><ul>
<li><strong>定义</strong><br>操作系统（Operation System）是计算机的管家，管理着这台计算机的全部资源。应用程序在运行过程中需要的资源均需向 OS 申请并且及时归还。多道程序申请一个临界资源的情况，称为<strong>竞争</strong>。</li>
</ul>
<h2 id="独立进程（或线程）"><a href="#独立进程（或线程）" class="headerlink" title="独立进程（或线程）"></a>独立进程（或线程）</h2><ul>
<li><strong>定义</strong><br>自身状态与其他进程（或线程）无关并且其他进程不会影响自身状态的进程（或线程），称为<strong>独立进程（或线程）</strong>。</li>
</ul>
<h2 id="合作进程（或线程）"><a href="#合作进程（或线程）" class="headerlink" title="合作进程（或线程）"></a>合作进程（或线程）</h2><ul>
<li><strong>定义</strong><br>进程执行过程中影响其他进程（或线程）状态或被其他进程（或线程）影响自身状态，称为<strong>合作进程（或线程）</strong>。</li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><ul>
<li><strong>定义</strong><br>在多道系统中，合作进程（或线程）按照某种事先规定的序列完成任务的过程称为<strong>同步</strong>。</li>
</ul>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><ul>
<li><p><strong>定义</strong><br>在多道系统中，合作进程（或线程）对临界资源的排他访问，称为<strong>互斥</strong>。</p>
</li>
<li><p><strong>调皮一下</strong><br>小 A 和小 B 属于合作进程。他们需要按照既定的顺序解决问题：小 A 先上或者小 B 先上。小 A 先上的话，小 B 只能等待小 A 出来，小 B 遵守了厕所坑互斥的约定，按照次序解决问题，这就是同步。</p>
</li>
</ul>
<blockquote>
<p><strong>想法</strong>，同步与互斥是两个非常独立的概念，然而却经常理解混乱。其一，多道程序为了完成同步需要一些互斥手段。其二，自然语言解释抽象概念本身就捉襟见肘。</p>
</blockquote>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul>
<li><strong>定义</strong><br>一种由资源管理者提供的资源，用于正确地访问临界资源。</li>
</ul>
<h1 id="问题研讨"><a href="#问题研讨" class="headerlink" title="问题研讨"></a>问题研讨</h1><p>由于互斥是同步的一个重要手段，我们从互斥入手去展开这一主题的介绍。锁在为多道程序正确地访问临界资源提供支持的同时，也加大了编写正确多道程序的难度。</p>
<h2 id="多道程序的活跃性问题"><a href="#多道程序的活跃性问题" class="headerlink" title="多道程序的活跃性问题"></a>多道程序的活跃性问题</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><p><strong>定义</strong><br>集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。死锁会进一步引起服务挂起，无法正常处理业务。</p>
</li>
<li><p><strong>调皮一下</strong><br>教科书爱用哲学家用餐问题引入介绍死锁，然而作为市井打工仔，我没见过科学家，因此这里换个日常生活中常见的死锁。一次下班回家，在一个交通转盘上就发生了严重的交通死锁，看到一辆救护车的悲鸣，心里很是触动。死锁如下：</p>
<img src="/2018/10/01/lock/Deadlock.jpg">
</li>
<li><p><strong>死锁产生</strong><br>从上面的例子我们可以看到死锁产生需要4个必要条件：</p>
<ol>
<li><strong>互斥</strong>：进程对临界资源排他性占用，若进程 P1 持有临界资源，则进程 P2 请求临界资源时需要等待，直到 P1 释放该资源，P2 才能获取。上图中，路口就是临界资源，同时只能由1辆车通过。</li>
<li><strong>请求和占有</strong>：进程 P1 在请求资源 R1 的同时还独占资源 R2，进程 P2 在请求资源 R2 的同时还独占资源 R1。上图中，每个方向的车队都是在请求自己的通行路口，同时还独占另外一个车队的通行路口。</li>
<li><strong>不可抢占</strong>：进程 P1 获得的资源 R1 在未自己释放之前不可由进程 P2 抢夺。每个车队都没有执法权可以让另一个车队让出一个路口。</li>
<li><strong>循环等待</strong>：进程资源环形链路。车队和路口出现了一个环形。</li>
</ol>
<p>上述四个条件为死锁产生的必要不充分条件：即死锁 -&gt; 互斥，死锁 -&gt; 请求和保持，死锁 -&gt; 请求和占有，死锁 -&gt; 循环等待，反过来则不成立。</p>
</li>
<li><p><strong>问题解决方案</strong></p>
<p>科学家给出了科学结论和理论上可行的方案：</p>
<ol>
<li><strong>死锁预防</strong><br>破坏死锁产生的4个必要条件之一，则就不会发生死锁。<strong>有序资源分配法</strong>是非常典型的一种死锁预防算法，它破坏了<strong>循环等待</strong>条件。<br><strong>有序资源分配算法</strong>即进程在获取多个资源的时候需要事先规定好的顺序获取，比如进程 P1 和 P2 需要资源 R1 R2 完成工作，如果 P1 占有 R1 申请 R2，P2 占有 R2 申请 R1 就会出现死锁。若我们事先规定进程获取资源的顺序为 R1 R2，那么进程 P2 在申请 R2 之前需先申请 R1，若 R1 申请不到则其无法持有 R2。因此不会产生死锁。</li>
<li><strong>死锁避免</strong><br>系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的<strong>动态策略</strong>。<strong>银行家算法</strong>是典型的死锁避免算法。<br><strong>银行家算法</strong>比较复杂，很难三言两语解释清楚，请见。由于申请资源者并非一次性将自己所需的最大资源数全部从银行家手里获取，因此会有虽然银行家手里有资源，但是并不能向外分配的情况。此时需要检测是否存在进程安全序列。</li>
<li><strong>死锁检测</strong><br>允许死锁发生，然后检测到进程发生死锁，再去干预。在交通图中，检测到死锁，右下角的警车到达，经过疏导完成了解锁。检测策略实现起来比较有难度。</li>
</ol>
<blockquote>
<p><strong>想法</strong>在日常业务开发中，通过业务拆分，通常多个进程竞争一个临界资源，不会出现多个临界资源，因此直接不满足死锁必要条件的<strong>请求和占有</strong>。如果真遇到多个临界资源的竞争，则需要引入<strong>有序资源分配法</strong>（由于资源有序，导致业务上的串行，影响性能），<strong>银行家算法</strong>（动态分配资源，实现略显复杂，提高并发性）。</p>
</blockquote>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3></li>
<li><p><strong>定义</strong></p>
<p>进程的等待时间给进程的响应时间带来明显影响，称为<strong>进程饥饿</strong>。若一直等待到即使完成该任务也毫无意义的时候，则称为<strong>饥饿死亡</strong>。</p>
</li>
<li><p><strong>调度算法</strong><br>进程和线程调度均由 OS 来完成，但业务相关任务调度则由工程师控制，因此调度算法也是工程师需要掌握的技术手段。下面介绍 6 种典型的进程调度算法（当然可以应用到任务调度当中），它们均是抢占式、非抢占式调度算法：</p>
<ol>
<li><strong>FCFS (First Come First Serve) 先来先服务</strong><ul>
<li>任务按照先来先服务原则执行（俗话所说的按照先来后到）</li>
<li>基于 FIFO 队列，实现简单</li>
<li>平均等待时长较长（老师常说的，你耽误课堂一分钟，整个教室 60 个人，你就耽误了 60 分钟）</li>
</ul>
</li>
<li><strong>SJN (Short Job Next) 短作业优先</strong><ul>
<li>任务按照短作业优先原则执行</li>
<li>平均等待时长最短（可以证明）</li>
<li>适合预先知道处理时长的批处理系统，不适合预先不知道处理时长的交互式系统</li>
<li>系统需要实现知道处理时长</li>
</ul>
</li>
<li><strong>Priority Scheduling 优先级调度</strong><ul>
<li>批处理系统中的常用调度算法</li>
<li>按照任务优先级处理，同一优先级按照 FCFS 处理</li>
</ul>
</li>
<li><strong>Shortest Remaining Time 最少剩余时间</strong></li>
<li><strong>Round Robin(RR) Scheduling 轮询调度</strong><ul>
<li>每个任务获取一个固定的执行时间，时间到则切换下一个任务</li>
</ul>
</li>
<li><strong>Multiple-Level Queue Scheduling 多级队列调度</strong></li>
</ol>
</li>
</ul>
<p>调度也是一个研究方向，值得庆幸的是科学家已经提供了很多行之有效的经典方案。Quartz 就是一个分布式调度框架，最近也用到了我们的项目中。</p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><ul>
<li><p><strong>定义</strong></p>
<p>活锁指的是任务或者执行者没有被阻塞，只是由于某种原因导致执行者一直重复尝试-失败，尝试-失败。</p>
</li>
<li><p><strong>实例</strong><br>活锁会导致虽然线程没有阻塞，但却什么都完成不了。比如执行任务的过程中，若遇到失败任务则重试，那么就有可能一直重试下去。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>锁是实现互斥的一种手段；互斥是程序执行过程中对临界资源访问的一种保证正确性的手段；同步需要 A 等待 B 完成才能继续执行，A 得知 B 已经完成的手段的一种方式就是访问一个临界资源。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/09/28/curator lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/28/curator lock/" itemprop="url">curator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-28T09:15:00+08:00">
                2018-09-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Zookeeper/" itemprop="url" rel="index">
                    <span itemprop="name">Zookeeper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Curator"><a href="#Curator" class="headerlink" title="Curator"></a>Curator</h1><p>Apache Curator 是 Apache Zookeeper 的一个客户端库。它封装了底层 Apache Zookeeper 客户端 API，为用户提供了更加简便可靠的高级 API 和一些常用工具。 除此之外，它还提供了常见场景的实现（比如选主、分布式锁等）以及一些扩展（比如服务发现）。</p>
<p>curator-recipes 为我们提供了几种常用场景的解决方案和实现，本文着重介绍这些工具的用法以及实现原理。</p>
<h1 id="Elections-选主"><a href="#Elections-选主" class="headerlink" title="Elections (选主)"></a>Elections (选主)</h1><p>日常生活中，一个稍微繁杂一些的工作，通常需要多人协作，多人协作时通常存在一个 leader 负责根据每个人的状况分发任务；那么就需要大家推举出一个让人信服的 leader，不能搞小团体，这样才能高效完成任务。在分布式系统中，通常也需要推举出一个 leader 完成整个系统的协同。</p>
<blockquote>
<p>选主（leader election）是指分布式系统中各个节点推举出一个节点作为整个系统的组织者，进而协同各个节点的状态，协调分布式任务。</p>
</blockquote>
<h2 id="应用场景举例"><a href="#应用场景举例" class="headerlink" title="应用场景举例"></a>应用场景举例</h2><ol>
<li>监控</li>
</ol>
<p>因为 leader 节点需要协同整个系统，所以及时获取系统中各个 non-leader 节点的状态是很重要的。因此 leader 节点会监控整个系统节点的状态。<br>比如在一个分布式计算系统中，调度模块将任务下发给 leader 节点，leader 节点在分发任务的时候，首先要确保 non-leader 计算节点的状态正常，才会下发计算任务；否则，就会引起数据丢失，计算失败。</p>
<ol>
<li>调度</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/08/05/question ananlysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/05/question ananlysis/" itemprop="url">记几次有意思的问题诊断</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-05T14:38:00+08:00">
                2018-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/诊断/" itemprop="url" rel="index">
                    <span itemprop="name">诊断</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h1><p>服务端出现 CLOSE_WAIT 状态，必然是某些原因导致服务端 socket 未关闭， FIN 包未发送到客户端，所以一直处于 CLOSE_WAIT 状态。打印 jstack 发现有大量的相同堆栈，均由同步 RPC 调用未能及时返回引起。</p>
<h1 id="Jedis连接到slave服务器"><a href="#Jedis连接到slave服务器" class="headerlink" title="Jedis连接到slave服务器"></a>Jedis连接到slave服务器</h1><p>服务端采用哨兵+主备方案部署，客户端采用 Jedis 连接。测试反应数据无法写入 redis，一直打印 READONLY异常。登录 redis，info 查看连接节点角色为 slave。因此怀疑主备切换之后 Jedis 客户端未能感知到。通过 Jedis 源代码得知 redis 主备切换后哨兵会将主备切换的信息 pub 到 +switch-master 这个主题， Jedis 客户端订阅该主题，在获取到主备切换信息之后关闭当前所有 Jedis 连接，跟新的主节点建立连接。由于测试服务端环境只有一个哨兵，并且 redis 的 pub/sub 模式是发布后需要直接消费，否则就会丢失，造就了 Jedis 客户端未能发现主备切换，引起客户端连接在了从节点。</p>
<h1 id="kafka无业务状态下流量和CPU较高"><a href="#kafka无业务状态下流量和CPU较高" class="headerlink" title="kafka无业务状态下流量和CPU较高"></a>kafka无业务状态下流量和CPU较高</h1><p>现网和测试反应 kafka 在基本没有业务的情况下，网络带宽竟然占用到了 5Mbits/s。问题反馈上来颇感棘手，原因是 kafka 采用 erlang 开发，而我只对 c/c++/Java 有所了解。既然无法直接阅读 kafka 代码，那就从外围分析。首先抓包，查看到的内容都是一些 topic 的名称，然而从我们的常识判断 kafka 这么成熟的商用消息队列不至于出现自身同步都引起巨大流量的问题。采用工具查看流量都从 kafka 不同节点同步消息互相流动。offset 的同步是采用的自动提交方式，每次提交都会触发 offset 同步。排查后发现 offset 的自动提交时间为 100ms，因此引起多个客户端每秒触发 10 次 offset 同步。将 offset 修改为 5000 ms 之后流量和 CPU 都降下来了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/07/25/Spring State Machine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/25/Spring State Machine/" itemprop="url">简单聊聊Spring State Machine</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-25T21:00:00+08:00">
                2018-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h1><p>FSM (Finite State Machine) 有限状态机。学术上 FSM 分为两种类型： Mealy 状态机和 Moore 状态机。</p>
<ul>
<li>Mealy 状态机</li>
</ul>
<p>output = f ( present_state, input )<br>next_state = f ( present_state, input)</p>
<ul>
<li>Moore 状态机</li>
</ul>
<p>output = f ( present_state )<br>next_state = f ( present_state, input )</p>
<p>参见：</p>
<p><a href="https://www.tutorialspoint.com/automata_theory/moore_and_mealy_machines.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/automata_theory/moore_and_mealy_machines.htm</a></p>
<h1 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h1>
<p>Spring State Machine 是事件驱动的，事件可以是定时器事件或者普通事件。上图中，比如状态机目前处于 S1 状态，收到 E1 事件后就切换到 S2 状态；状态机目前处于 S2 状态， 收到 E2 事件后切换到 S3 状态。那么 Spring 状态机是怎么使用计算资源的呢？</p>
<img src="/2018/07/25/Spring%20State%20Machine/springsm.jpg" title="This is an example image">
<p>每个状态机都有一个接收事件的事件队列，每次每个事件触发都会将 Runnable 任务提交到线程池的任务队列。线程从线程池中提取 Runnable 任务，然后执行事件队列中的全部事件。在任务执行的过程中，会首先加锁，不让多个线程同时处理一个事件队列以免引起线程安全问题。</p>
<h1 id="分布式协作状态机"><a href="#分布式协作状态机" class="headerlink" title="分布式协作状态机"></a>分布式协作状态机</h1><p>Distribute state machine 是借助 Zookeeper 实现的。每次状态发生变化，Spring State Machine 会将状态持久化到 Zookeeper 中，并以 log 的形式记录到 Zookeeper。 由于另一个 State Machine Watch 了 Zookeeper 上 log 的变化，因此它会在 log 发生变化的时候重放 log，以完成两个 State Machine 的同步。这里需要注意，如果状态机中定义的 Action 中存在变量自加的情况，那么重放 log 会导致 Action 中的操作执行多遍，因此我们在设计的时候通常不能在 Action 中执行操作。</p>
<h1 id="状态机实例化"><a href="#状态机实例化" class="headerlink" title="状态机实例化"></a>状态机实例化</h1><p>初次使用 Spring State Machine，从其 Demo 中只能看到每次启动 Spring 服务只能配置一个 Spring State Machine 实例。这种情况通常不符合我们的业务流程，因为我们会有多个相同的业务同时执行。当然，这不能困住我们啦，把 Spring State Machine 的源代码下下来，就能看到 Builder 模式的创建状态机的方法。</p>
<h1 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h1><p>经验教训是这将近一月的需求分析、概要设计、详细设计、代码开发到自测阶段不断思考的一些内容。由于并非理论知识，不具备普适性，不具备科学性，所以放在了行文的最后，不妨碍阅读 Spring State Machine 本身的内容。</p>
<h2 id="如何进行设计？"><a href="#如何进行设计？" class="headerlink" title="如何进行设计？"></a>如何进行设计？</h2><p>设计阶段我们分别进行了业务细节设计、研究 Spring State Machine 的设计、 定时器框架 Quarz 的设计。设计阶段没有达到预期的原因，我认为有以下几个点需要自己以后注意：</p>
<ol>
<li>设计仓促</li>
</ol>
<p>需求分析和可行性分析是最不能节省时间的。这里的仓促需要我花更多的时间和更多的精力买单。时间紧张是一个比较客观的原因。</p>
<ol>
<li>缺少沟通</li>
</ol>
<p>骨子里认为开会是个浪费时间的动作，但设计阶段的会议必不可少，一天一次或者一天两次都不为过。沟通的过程是需要和大家不断澄清方案合理性的过程，而且不间断的沟通可以激起负责人的主人翁精神，调动起大家的积极性是愉快工作必不可少的环节。</p>
<ol>
<li>缺少信任</li>
</ol>
<p>事必躬亲是非常错误的，是一种事倍功半的做法。首先一个人精力有限，其次一个人必有局限。充分信任同事，不断沟通结果才是提高生产力的法则。比如，如果不信任 Spring 的代码质量，那么项目从 0 开始，将是非常巨大的成本。信任同事，一起查看设计和开发结果，对不合理的地方不断完善，既可以减轻事必躬亲带来的压力和巨大工作量，又可以让大家都有主人翁精神。</p>
<h2 id="如何分工合作？"><a href="#如何分工合作？" class="headerlink" title="如何分工合作？"></a>如何分工合作？</h2><p>需求一下来，我立马拉上组内相关同事进行了一个针对性的拆解分工。因为每个人技术背景不同，所以起初我的想法是每两个同事关注一个重要的点，每个同事关注两个重要的点，即下图的形式：</p>
<img src="/2018/07/25/Spring%20State%20Machine/project_teamwork.jpg" title="This is an example image">
<p>此时大家可以分工调研各自重点关注和辅助关注的模块了。分工上基本是合理的。就是缺少了沟通。沟通是分工合作非常需要关注的一个点。下次牵头做设计，必然要每天沟通，记录进度和结果。</p>
<h2 id="如何保证质量？"><a href="#如何保证质量？" class="headerlink" title="如何保证质量？"></a>如何保证质量？</h2><p>把信任给了同事，那么质量如何保证。这就又体现了沟通的重要性。不是大家能力问题，而是不同技术背景，开发习惯等会引起一些低级问题。开会 review 是提升大家编码水平的一个重要渠道。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/06/23/JWT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/23/JWT/" itemprop="url">JWT简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-23T10:34:00+08:00">
                2018-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-JSON-Web-Tokens"><a href="#1-JSON-Web-Tokens" class="headerlink" title="1 JSON Web Tokens"></a>1 JSON Web Tokens</h1><p>JSON Web Tokens(JWT)是一个紧凑的自包含的用于多方安全传输信息的开放标准。由于JWT具有数字签名（可用对称密钥和非对称密钥进行签名），因此JWT传输的信息可以被认证和信任。</p>
<blockquote>
<p>数字签名： 用户Alice采用非对称密钥加密算法生成一对公钥和私钥；Alice将公钥公诸于世，私钥只有自己知道。此时Alice就可以采用自己的私钥将一段信息进行加密。其他人只有用Alice的公钥才能解密这一段信息。因此其他人就可以判定该信息由Alice发布，即具有Alice的数字签名。</p>
</blockquote>
<p>虽然JWT可以在加密信道传输，但是我们依然要关注JWT的签名。签名可以用于验证信息没有被篡改，并且可以判断发送者的身份。</p>
<h1 id="2-JWT应用场景"><a href="#2-JWT应用场景" class="headerlink" title="2 JWT应用场景"></a>2 JWT应用场景</h1><ul>
<li><p>认证</p>
<p>JWT最常用的场景就是认证。一旦用户正确登录，则其后续的请求都必须携带JWT。根据JWT判断是否允许用户访问受保护的路由、服务和资源。<br>由于JWT的轻量级和在不同领域的易传输性使其广泛应用于SSO（Signle Sign On）单点登录。</p>
</li>
</ul>
<blockquote>
<p>SSO：单点登录，用户完成认证后，在访问整个系统的其他服务时，只需携带令牌，无需重新登录。</p>
</blockquote>
<ul>
<li><p>信息交换</p>
<p>JWT可用于多方信息安全传输。因为JWT是被签名的，因此可以判断发送者身份，并且可判断消息是否被篡改。</p>
</li>
</ul>
<h1 id="3-JWT-结构"><a href="#3-JWT-结构" class="headerlink" title="3 JWT 结构"></a>3 JWT 结构</h1><p>紧凑型JWT包含三个部分，并且用点分隔，类似于xxx.yyy.zzz。</p>
<ul>
<li><p>Header</p>
<p>头部通常包括两部分：类型和哈希算法<br>{<br>  “alg” : “HS256”<br>  “typ” : “JWT”<br>}<br>将这个JSON经过Base64Url编码后生成JWT的header</p>
</li>
<li><p>Payload</p>
<p>负载包含三个部分：注册声明、公共声明和私有声明<br>注册声明包含一些推荐但不强制使用的预定义字段，提供注册该Token的相关信息。比如：iss（签发者），exp（过期时间），sub（使用者）等。<br>公共声明<br>私有声明是多方协商好携带信息的字段。<br>{<br>“sub” : “123”<br>“name” : “John”<br>“admin” : true<br>}</p>
<p>将这个JSON经过Base64Url编码后生成JWT的payload</p>
</li>
<li><p>Signature</p>
<p>签名是用加密算法生成编码后header和payload的摘要。比如：<br>HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)<br>签名用于鉴定信息是否被篡改，并且可以判断发送者身份。</p>
</li>
</ul>
<h1 id="4-JWT如何工作"><a href="#4-JWT如何工作" class="headerlink" title="4 JWT如何工作"></a>4 JWT如何工作</h1><p>认证时，当用户登录系统，会为其返回一个JWT。JWT也是证书，因此需要保护好它的安全性。通常在用完JWT后即释放。</p>
<p>当用户访问受保护的路由活资源时，用户代理同时需要将JWT发送过去。通常JWT令牌放在Authorization头的Bearer主题下。</p>
<blockquote>
<p>Authorization: Bearer \<token></token></p>
</blockquote>
<p>JWT在某些情况下是无状态认证机制。服务器认证JWT通过之后就会让其访问受保护的资源。如果JWT包含一些必要的数据，那么可以减少对数据库的查询操作。</p>
<p>如果token在Authorization头中发送，那么跨域资源共享（CORS）就不存在问题，因为他们不是cookie。</p>
<p>下图是JWT官网的图：<br><img src="/2018/06/23/JWT/client-credentials-grant.png" title="client-credentials-grant.png"></p>
<ol>
<li>应用或客户端发送认证请求到认证服务器。</li>
<li>认证通过，认证服务器给应用返回一个访问令牌</li>
<li>应用程序使用访问令牌访问服务端受保护的资源</li>
</ol>
<p>注意：JWT中的所有信息都可以被所有人获取，因此JWT不应该存储密钥信息。</p>
<h1 id="5-为什么选择JWT"><a href="#5-为什么选择JWT" class="headerlink" title="5 为什么选择JWT"></a>5 为什么选择JWT</h1><ul>
<li>JSON比XML冗余小，更紧凑，适合在HTML和HTTP环境</li>
<li>JWT相比于SWT，可以使用非对称加密算法。相比于SAML更加简单清晰</li>
<li>JSON格式平台兼容性更好</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/05/21/mosquittio source code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/21/mosquittio source code/" itemprop="url">Mosquitto源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-21T16:30:00+08:00">
                2018-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/协议/" itemprop="url" rel="index">
                    <span itemprop="name">协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>[Mosquitto简介]这篇文章介绍了Mosquitto的基本功能。本文在此基础上，对Mosquitto的内核实现进行简单总结。文章只对Mosquitto概要设计进行分析，不深入代码细节。</p>
<h1 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h1><p>Mosquitto对socket连接的管理和redis等其他开源c软件大同小异，均采用反应堆模式（可参考<a href="http://www.cnblogs.com/xujian2014/p/5711828.html）。事件驱动是反应堆的核心。" target="_blank" rel="noopener">http://www.cnblogs.com/xujian2014/p/5711828.html）。事件驱动是反应堆的核心。</a></p>
<h2 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h2><p>事件指I/O、定时器等事件。一个新的客户端连接服务器，就会触发监听socket的可读事件；客户端向服务器发送消息，就会触发客户端与服务器之间这个socket的可读事件；服务器想向客户端发送消息，那么服务器会去触发客户端与服务器之间这个socket的可写事件。</p>

<p>由上图，事件驱动模型有3大部件：1，事件收集器；2，事件发送器；3，事件处理器。在C语言编写的服务器里面，事件收集器的工作通常由select、poll或epoll这类多路复用IO承担。事件发送器通常在与多路复用IO同一个应用线程当中实现，即将收集的事件分发到不同的事件队列。事件处理器通常是与多路复用IO不同的一些线程，这些线程从事件队列中获取事件，并根据事件类型执行响应的事件处理函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mosquitto_main_loop</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	while (run)</span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">		fdcount = epoll_wait(db-&gt;epollfd, events, MAX_EVENTS, 100);</span><br><span class="line">		...</span><br><span class="line">			ev.data.fd = net__socket_accept(db, listensock[j])</span><br><span class="line">		...</span><br><span class="line">		loop_handle_reads_writes(db, events[i].data.fd, events[i].events);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码片为简化版的1.5.0的Mosquitto的主循环实现。代码中清晰的分辨出事件收集器epoll，事件发送器loop_handle_reads_writes。事件处理器则在其他线程执行不同事件的处理函数。</p>
<p>为什么称为事件驱动呢？驱动是指事物本身是静止状态，在驱动的驱使下发生变动。由上述代码片，若没有事件发生，那么只有while循环这一个线程在空转，事件处理器处于全体静止状态。事件发生，则会处罚事件处理器执行事件的处理函数。因此说，整个的server是事件驱动的。</p>
<h2 id="客户端对象"><a href="#客户端对象" class="headerlink" title="客户端对象"></a>客户端对象</h2><p>c 语言虽然不是面向对象的语言，但开源项目中通常看到对象的影子。面向对象思想包含 3 个重要特性：封装、继承、多态。<br>封装性在 c 语言中采用 struct 结构体模拟。之所以叫模拟是因为 c 语言中 struct 不具备成员变量可见性控制；私有成员函数采用在 .c 文件中的 static 方法实现，对外接口则声明到头文件中。继承和多态在 c 语言中需要采用 void * 指针、回调函数、自定义虚函数表来模拟。虽然是模拟，但是 c 语言并不是面向对象语言。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">struct mosquitto &#123;</span><br><span class="line">	mosq_sock_t sock;</span><br><span class="line">#ifndef WITH_BROKER</span><br><span class="line">	mosq_sock_t sockpairR, sockpairW;</span><br><span class="line">#endif</span><br><span class="line">#if defined(__GLIBC__) &amp;&amp; defined(WITH_ADNS)</span><br><span class="line">	struct gaicb *adns; /* For getaddrinfo_a */</span><br><span class="line">#endif</span><br><span class="line">	... 客户端接收包所需的数据结构</span><br><span class="line">#ifdef WITH_TLS</span><br><span class="line">	...</span><br><span class="line">#endif</span><br><span class="line">	bool want_write;</span><br><span class="line">	bool want_connect;</span><br><span class="line">#if defined(WITH_THREADING) &amp;&amp; !defined(WITH_BROKER)</span><br><span class="line">	...</span><br><span class="line">#endif</span><br><span class="line">	bool clean_session;</span><br><span class="line">#ifdef WITH_BROKER</span><br><span class="line">	... 服务端端用于存储 msg 的结构</span><br><span class="line">#  ifdef WITH_WEBSOCKETS</span><br><span class="line">	...</span><br><span class="line">#  endif</span><br><span class="line">	bool ws_want_write;</span><br><span class="line">#else</span><br><span class="line">#  ifdef WITH_SOCKS</span><br><span class="line">	... SOCKS协议控制</span><br><span class="line">#  endif</span><br><span class="line">	... 登录登出、收发包等的回调</span><br><span class="line">#  ifdef WITH_SRV</span><br><span class="line">	ares_channel achan;</span><br><span class="line">#  endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef WITH_BROKER</span><br><span class="line">	... handle</span><br><span class="line">#endif</span><br><span class="line">#ifdef WITH_EPOLL</span><br><span class="line">	uint32_t events;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct mosquitto 结构中包含了 #ifdef WITH_BROKER，因为在 Mosquitto 的设计中，在实现 server 的同时也实现了 client 的 lib 库。<br>包括 redis 在内，开源软件中很多 server 中都会对客户端进行抽象。这些客户端对象很方便管理各个客户端的状态、数据等。</p>
<h1 id="服务器数据结构"><a href="#服务器数据结构" class="headerlink" title="服务器数据结构"></a>服务器数据结构</h1><p>Mosquitto 的实现，AWS IoT 对 MQTT 的支持，阿里 IoT 对 MQTT 的支持，均关注一个非常重要的指标：消息转发。与消息中间件（比如 Kafka ）不同，Mosquitto 更加关注消息转发效率而非消息吞吐量。</p>
<h2 id="订阅树"><a href="#订阅树" class="headerlink" title="订阅树"></a>订阅树</h2><p>Mosquitto 的订阅树采用的是孩子兄弟表示法。与平时见到的实现不同，为了快速找到某个 topic 上的订阅者，它采用了 hash 表来加速查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">struct mosquitto__subleaf &#123;</span><br><span class="line">	struct mosquitto__subleaf *prev;</span><br><span class="line">	struct mosquitto__subleaf *next;</span><br><span class="line">	struct mosquitto *context;</span><br><span class="line">	int qos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct mosquitto__subhier &#123;</span><br><span class="line">	UT_hash_handle hh;</span><br><span class="line">	struct mosquitto__subhier *parent;</span><br><span class="line">	struct mosquitto__subhier *children;</span><br><span class="line">	struct mosquitto__subleaf *subs;</span><br><span class="line">	struct mosquitto_msg_store *retained;</span><br><span class="line">	mosquitto__topic_element_uhpa topic;</span><br><span class="line">	uint16_t topic_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct UT_hash_bucket &#123;</span><br><span class="line">   struct UT_hash_handle *hh_head;</span><br><span class="line">   unsigned count;</span><br><span class="line">   unsigned expand_mult;</span><br><span class="line"></span><br><span class="line">&#125; UT_hash_bucket;</span><br><span class="line"></span><br><span class="line">typedef struct UT_hash_table &#123;</span><br><span class="line">   UT_hash_bucket *buckets;</span><br><span class="line">   unsigned num_buckets, log2_num_buckets;</span><br><span class="line">   unsigned num_items;</span><br><span class="line">   struct UT_hash_handle *tail; /* tail hh in app order, for fast append    */</span><br><span class="line">   ptrdiff_t hho; /* hash handle offset (byte pos of hash handle in element */</span><br><span class="line">   unsigned ideal_chain_maxlen;</span><br><span class="line">   unsigned nonideal_items;</span><br><span class="line">   unsigned ineff_expands, noexpand;</span><br><span class="line"></span><br><span class="line">   uint32_t signature; /* used only to find hash tables in external analysis */</span><br><span class="line">#ifdef HASH_BLOOM</span><br><span class="line">   uint32_t bloom_sig; /* used only to test bloom exists in external analysis */</span><br><span class="line">   uint8_t *bloom_bv;</span><br><span class="line">   char bloom_nbits;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; UT_hash_table;</span><br><span class="line"></span><br><span class="line">typedef struct UT_hash_handle &#123;</span><br><span class="line">   struct UT_hash_table *tbl;</span><br><span class="line">   void *prev;                       /* prev element in app order      */</span><br><span class="line">   void *next;                       /* next element in app order      */</span><br><span class="line">   struct UT_hash_handle *hh_prev;   /* previous hh in bucket order    */</span><br><span class="line">   struct UT_hash_handle *hh_next;   /* next hh in bucket order        */</span><br><span class="line">   void *key;                        /* ptr to enclosing struct&apos;s key  */</span><br><span class="line">   unsigned keylen;                  /* enclosing struct&apos;s key len     */</span><br><span class="line">   unsigned hashv;                   /* result of hash-fcn(key)        */</span><br><span class="line">&#125; UT_hash_handle;</span><br></pre></td></tr></table></figure>
<p>订阅树中订阅节点采用双向链表实现。孩子兄弟表示法隐藏在handle数据结构中。从下图可以清晰得看出订阅树的数据结构。MQTT 主题采用目录结构形式，天然是树形结构，因此订阅主题采用订阅树的结构非常合适。Hash 表可以提升树形结构的查询效率。目前用不上，不做详细分析。</p>
<img src="/2018/05/21/mosquittio%20source%20code/mosquitto_subhier.jpg">
<img src="/2018/05/21/mosquittio%20source%20code/UT_hash_handle.jpg">
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文描述了 C 语言开发的事件驱动模型以及 mosquitto 的订阅树结构。若需要更加深入的使用 mosquitto 则可以沿此思路继续深入。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/05/15/mosquttio cook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/15/mosquttio cook/" itemprop="url">Mosquitto简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-15T09:15:00+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/协议/" itemprop="url" rel="index">
                    <span itemprop="name">协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>Mosquitto是实现了MQTT协议3.1和3.1.1版本的一个消息服务器的开源实现。Mosquitto是轻量级的，它的应用平台囊括从低电量的单片机到所有服务器。</p>
<p>MQTT协议基于<strong>publish/subscribe(发布/订阅)</strong>模型提供了轻量级的携带消息的方法。这就为传感器、移动设备（比如手机）、嵌入式设备接入互联网提供了可能。</p>
<p>Mosquitto提供了实现MQTT客户端的C库，并且提供了<strong>mosquitto_pub</strong> 和 <strong>mosquitto_sub</strong>的命令行实现。</p>
<h1 id="2-MQTT"><a href="#2-MQTT" class="headerlink" title="2 MQTT"></a>2 MQTT</h1><h2 id="2-1-描述"><a href="#2-1-描述" class="headerlink" title="2.1 描述"></a>2.1 描述</h2><p>MQTT是一个轻量级的发布/订阅协议。在低电量传感器中非常有用，但它也可以用于很多其他场景。</p>
<h2 id="2-2-发布-订阅"><a href="#2-2-发布-订阅" class="headerlink" title="2.2 发布/订阅"></a>2.2 发布/订阅</h2><p>MQTT协议基于”pub/sub”即发布/订阅模型。客户端连接到服务器（broker）并且订阅它们感兴趣的主题（topics），除此之外，客户端也会连接到服务器并且发布消息到主题。不同的客户端可以订阅相同的主题。MQTT服务器就像一个接口一样供大量不同设备接入。</p>
<h2 id="2-3-主题-订阅"><a href="#2-3-主题-订阅" class="headerlink" title="2.3 主题/订阅"></a>2.3 主题/订阅</h2><p>MQTT的主题结构是一种类似于文件系统的层级格式，每一层采用”/“分隔。与此同时，MQTT提供了”+”和”#”通配符，这就为客户端订阅相似的主题提供了便利。</p>
<ul>
<li>： 单一层级的通配符<br># ： 多层级通配符  </li>
</ul>
<p>比如：设备将温度发送到主题<strong>sensors/COMPUTER_NAME/temperature/HARDDRIVE_NAME</strong>中,如果我们想要订阅所有设备的温度变化，则可以订阅<strong>sensors/+/temperature/+</strong>这个主题。</p>
<p>又比如订阅<strong>a/b/c/d</strong>这个主题，那么以下几种方式都可以订阅到：</p>
<p>a/b/c/d<br>+/b/c/d<br>a/+/c/d<br>a/+/+/d<br>+/+/+/+</p>
<p>a/b/c/d<br>#<br>a/#<br>a/b/#<br>a/b/c/#<br>+/b/c/#</p>
<p>不要提供长度为0的层级主题。</p>
<h2 id="2-4-服务质量QoS"><a href="#2-4-服务质量QoS" class="headerlink" title="2.4 服务质量QoS"></a>2.4 服务质量QoS</h2><p>MQTT提供了3个等级的QoS，每个等级对于可达性的要求不同。消息可以采用任意QoS等级发布，也可以采用任意QoS等级订阅，但最终发布端到订阅端的QoS的值为min(QoSSend，QoSReceive)。</p>
<p>QoS0：只发一次，不发确认。<br>QoS1：最少一次，需要确认。<br>QoS2：精确一次，四次握手。</p>
<h1 id="3-保持消息"><a href="#3-保持消息" class="headerlink" title="3 保持消息"></a>3 保持消息</h1><p>消息可以配置为保持消息，这意味着服务器在将消息发送到所有订阅的客户端之后，仍然会保存该消息。如果新的订阅到来，服务端会将保持消息发送到该客户端。在某些场景下，消息的更新频率很低，这个时候，如果新的客户端订阅消息时如果未保持消息，则新的客户端会等待比较长的时间；而如果进行了消息保持，则会立即获取到消息。</p>
<h1 id="4-清除会话-持久连接"><a href="#4-清除会话-持久连接" class="headerlink" title="4 清除会话/持久连接"></a>4 清除会话/持久连接</h1><p>客户端的clean session字段若为false，则认为是持久连接。在持久连接中，当客户端断链，那么它将要订阅的所有主题以及所有它订阅的QoS1和QoS2级别的消息将会存储到服务端，直到它重连。如果clean session字段为false，则在客户端断链之后，会清除所有会话相关内容。</p>
<h1 id="5-遗嘱"><a href="#5-遗嘱" class="headerlink" title="5 遗嘱"></a>5 遗嘱</h1><p>客户单连接到服务端后，可以给向服务端提供自己的遗嘱。这个遗嘱是在客户端意外断链的时候，服务端需要发布的消息。这个消息的主题，QoS和保持状态跟之前介绍的是一致的。</p>
<h1 id="6-桥接"><a href="#6-桥接" class="headerlink" title="6 桥接"></a>6 桥接</h1><p>关于Mosquitto桥接的配置在配置文档里面已经描述清楚，这里对其原理进行介绍：</p>
<img src="/2018/05/15/mosquttio%20cook/mosquitto桥接.jpg">
<p>桥接在一台Mosquitto服务器配置。桥接服务器与其他服务器建立连接，并各自为该连接命名。</p>
<p>在某个客户端向任何一台Mosquitto服务器publish消息的时候，由于客户端连接订阅了该主题，那么服务器就会往该连接publish 消息。当其他broker收到publish消息，会将消息发布到对应的topic当中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/05/11/Jedis design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/11/Jedis design/" itemprop="url">Jedis简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-11T18:34:00+08:00">
                2018-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>Jedis是redis的Java客户端。它基于BIO实现。Jedis包含以下几个核心类与服务端交互：Jedis，JedisCluster，ShardedJedis，JedisPool，JedisSentinelPool，ShardedJedisPool。通过本文加深对对象池化和连接管理的理解。</p>
<h1 id="2-Jedis简介"><a href="#2-Jedis简介" class="headerlink" title="2 Jedis简介"></a>2 Jedis简介</h1><img src="/2018/05/11/Jedis%20design/jedis.jpg" title="jedis">
<h2 id="2-1-Jedis介绍"><a href="#2-1-Jedis介绍" class="headerlink" title="2.1 Jedis介绍"></a>2.1 Jedis介绍</h2><p>Jedis是对redis命令的封装，包括数据操作命令，哨兵相关命令，集群相关命令。Jedis对象封装了与redis服务器的Connection，因此它只能执行与redis服务器相关的命令；对于需要在redis-sentinel执行的命令需要采用JedisSentinel对象，JedisSentinel对象封装了客户端与redis-sentinel之间的连接；需要执行redis-cluster相关的命令则只能采用JedisCluster对象。</p>
<h2 id="2-2-Client介绍"><a href="#2-2-Client介绍" class="headerlink" title="2.2 Client介绍"></a>2.2 Client介绍</h2><p>Client用于封装与redis服务器的Connection。Client利用Connection执行sendCommand命令给服务端发送命令以外，还会进行鉴权，连接指定数据库等操作。</p>
<h2 id="2-3-Connection介绍"><a href="#2-3-Connection介绍" class="headerlink" title="2.3 Connection介绍"></a>2.3 Connection介绍</h2><p>Jedis的方法在有返回值的情况下大致分两步执行：1，将redis命令通过按照redis协议发往redis服务器；2，接收来自服务器的返回值并解析。第一步是写的过程，即将redis命令按照redis协议写入与redis服务器连接的Socket当中；第二步是读的过程，即将redis命令的执行结果从刚刚的Socket中读出来解析。</p>
<p>Socket的建立通过Connection封装管理。Socket为TCP的BIO实现，采用NODELAY，KEEPALIVE，超时时间默认2min的形式配置。情况下，2min足够redis将结果返回，但也不排除会抛出I/O异常。I/O异常会封装为JedisConnectionException向外抛。</p>
<h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h2><p>Jedis用于给使用者提供跟服务器基本一样的命令接口。Client用于鉴权、连接数据库，并且执行Jedis调用自己的指令。Connection用于管理与服务器之间的连接。Protocol用于完成命令的封装。分工非常清晰。</p>
<h1 id="3-JedisSentinel"><a href="#3-JedisSentinel" class="headerlink" title="3 JedisSentinel"></a>3 JedisSentinel</h1><img src="/2018/05/11/Jedis%20design/JedisSentinel.PNG" title="JedisSentinel">
<p>并不存在JedisSentinel类。在执行redis-sentinel的命令时，其实也是采用的Jedis对象，不过Jedis对象中使用的连接是连接到redis-sentinel的。Jedis jedisSentinel = new Jedis(sentinel)；sentinel为redis-sentinel的ip和port。</p>
<h1 id="4-JedisCluster"><a href="#4-JedisCluster" class="headerlink" title="4 JedisCluster"></a>4 JedisCluster</h1><p>JedisCluster和Jedis不同，JedisCluster对象用于执行一些集群相关的命令。</p>
<h1 id="5-ShardedJedis"><a href="#5-ShardedJedis" class="headerlink" title="5 ShardedJedis"></a>5 ShardedJedis</h1><img src="/2018/05/11/Jedis%20design/ShardJedis.jpg" title="ShardJedis">
<h2 id="5-1-ShardedJedis"><a href="#5-1-ShardedJedis" class="headerlink" title="5.1 ShardedJedis"></a>5.1 ShardedJedis</h2><p>ShardedJedis是基于客户端分片的redis客户端实现。ShardedJedis在执行命令的时候，首先获取key对应的分片使用的Jedis对象，然后通过该Jedis对象执行相应的命令。使用者不感知Jedis和分片的存在。如上图的get流程所示：ShardedJedis调用get方法，get方法里面会先获取key对应的Jedis，然后采用Jedis执行命令，然后将结果返回；整个过程使用者不感知分片和Jedis的存在。</p>
<img src="/2018/05/11/Jedis%20design/ShardedJedis1.jpg" title="ShardJedis">
<h2 id="5-2-Sharded"><a href="#5-2-Sharded" class="headerlink" title="5.2 Sharded"></a>5.2 Sharded</h2><p>Sharded用于管理key与Jedis之间的关系。</p>
<ol>
<li>Sharded缓存key的hash值区间和ShardInfo的映射关系</li>
<li>Sharded缓存ShardInfo与Jedis的映射关系</li>
</ol>
<p>所以Sharded执行命令的过程如下：</p>
<ol>
<li>计算key的hash值应该落到那个区间</li>
<li>查看该区间对应的ShardInfo</li>
<li>查找ShardInfo对应的Jedis</li>
<li>利用Jedis对象发送命令给对应的redis服务器并获取结果</li>
<li>返回结果。</li>
</ol>
<h2 id="5-3-ShardedInfo"><a href="#5-3-ShardedInfo" class="headerlink" title="5.3 ShardedInfo"></a>5.3 ShardedInfo</h2><p>ShardedInfo有两个作用：</p>
<ol>
<li>存储多个redis服务器的信息</li>
<li>提供createResource方法创建对象</li>
</ol>
<h1 id="6-JedisPool"><a href="#6-JedisPool" class="headerlink" title="6 JedisPool"></a>6 JedisPool</h1><img src="/2018/05/11/Jedis%20design/JedisPool.jpg" title="JedisPool">
<h2 id="6-1-JedisPool介绍"><a href="#6-1-JedisPool介绍" class="headerlink" title="6.1 JedisPool介绍"></a>6.1 JedisPool介绍</h2><p>JedisPool是Jedis对象池。Jedis对象中的连接为TCP长连接，TCP连接的创建需要三次握手，销毁需要四次挥手。如果每次执行一个redis命令都进行连接的创建和销毁，对于客户端和服务端来讲均有不小的毫无意义的开销。因而引入了Pool。</p>
<p>JedisPool提供getResource()方法，返回一个Jedis对象，用于执行redis命令。提供returnResource(returnBrokenResource)方法，将Jedis对象归回到Pool。</p>
<h2 id="6-2-GenericObjectPool"><a href="#6-2-GenericObjectPool" class="headerlink" title="6.2 GenericObjectPool"></a>6.2 GenericObjectPool</h2><p>GenericObjectPool是Pool的一种。它提供Pool中对象的借用（borrowObject）和归还（returnObject）的方法，管理Pool中对象的生命周期。它提供了一些配置参数用于管理对象池中对象的个数，对象的生命周期。</p>
<ul>
<li>maxIdle：Pool中最大空闲对象数</li>
<li>minIdle：Pool中最小空闲对象数</li>
<li>maxTotal：Pool中对象个数最大值</li>
<li>testOnBorrow：对象借出前合法性检查，不合法则销毁</li>
<li>testOnReturn：对象归还pool之前合法性检查，不合法则销毁</li>
</ul>
<h2 id="6-3-JedisFactory"><a href="#6-3-JedisFactory" class="headerlink" title="6.3 JedisFactory"></a>6.3 JedisFactory</h2><p>JedisFactory继承自PooledObjectFactory，用于提供对象生命周期管理的方法，供pool使用。PooledObjectFactory提供了对象的创建（makeObject）、激活（activateObject)、去激活（passivateObject)、销毁（destoryObject)、合法性检查（validateObject)方法。JedisFactory这些方法，makeObject创建Jedis对象；activateObject选择指定的数据库；destoryObject销毁Jedis对象；validateObject给服务器发送PING消息探测连接是否可用。</p>
<h1 id="7-JedisSentinelPool"><a href="#7-JedisSentinelPool" class="headerlink" title="7 JedisSentinelPool"></a>7 JedisSentinelPool</h1><p>JedisSentinelPool并不是客户端与哨兵之间的连接池，而是客户端通过redis-sentinel获取到redis-master的ip和port，然后建立与master之间的Jedis池。</p>
<p>JedisSentinelPool主要负责两个事情：1，监听redis-sentinel发布的切主事件，销毁与旧master之间的连接，建立与新master之间的连接；2，维护池中Jedis对象。</p>
<img src="/2018/05/11/Jedis%20design/JedisSentinelPool1.jpg" title="JedisSentinel">
<h2 id="7-1-MasterListener"><a href="#7-1-MasterListener" class="headerlink" title="7.1 MasterListener"></a>7.1 MasterListener</h2><p>MasterListener是在JedisSentinelPool初始化的时候创建的，它订阅redis-sentinel的+switch-master主题，在发生主从切换的时候，哨兵将事件发布到该topic，然后MasterListener订阅到该信息，根据该信息，关闭与旧的主redis的连接，创建与新redis的连接。</p>
<h2 id="7-2-PooledObjectFactory"><a href="#7-2-PooledObjectFactory" class="headerlink" title="7.2 PooledObjectFactory"></a>7.2 PooledObjectFactory</h2><p>JedisSentinelPool默认的PooledObjectFactory是JedisFactory。该JedisFactory是管理与master连接的Jedis的对象生命周期的，因此JedisSentinelPool并没有创建大量的与redis-sentinel的连接，而是创建与master的连接。</p>
<h2 id="7-3-小结"><a href="#7-3-小结" class="headerlink" title="7.3 小结"></a>7.3 小结</h2><p>为什么JedisSentinelPool不直接依赖JedisPool实现呢？如果实现默认功能的话，确实可以直接饮用JedisPool的实现方法。但是有时候我们需要扩充JedisSentinelPool，比如扩充为ShardJedisSentinelPool，那么就可以考虑重新设计PooledObjectFactory并传递给JedisSentinelPool。</p>
<h1 id="8-ShardedJedisPool"><a href="#8-ShardedJedisPool" class="headerlink" title="8 ShardedJedisPool"></a>8 ShardedJedisPool</h1><p>ShardedJedisPool是ShardedJedis的对象池。它需要提供自己的PooledObjectFactory即ShardedJedisFactory。这里不再赘述。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王哲</p>
              <p class="site-description motion-element" itemprop="description">分享 交流</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">Kategorien</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/rss2.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王哲</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>




  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
