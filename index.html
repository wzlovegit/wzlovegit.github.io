<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="中文">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/rss2.xml" title="Light" type="application/atom+xml" />






<meta name="description" content="分享 交流">
<meta property="og:type" content="website">
<meta property="og:title" content="Light">
<meta property="og:url" content="http://wzlovegit.github.io/index.html">
<meta property="og:site_name" content="Light">
<meta property="og:description" content="分享 交流">
<meta property="og:locale" content="中文">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Light">
<meta name="twitter:description" content="分享 交流">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wzlovegit.github.io/"/>





  <title>Light</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="中文">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Light</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">王哲的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2019/01/27/2018/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/2018/" itemprop="url">小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-27T13:17:00+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/life/" itemprop="url" rel="index">
                    <span itemprop="name">life</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>入职公司已经 1 年有余，收入不高，待遇一般，产品前景也让人有些担忧，但总体来讲自己还是得到很多锻炼，现在从多个角度小结一下今年的工作状态。</p>
<h1 id="工作任务和挑战"><a href="#工作任务和挑战" class="headerlink" title="工作任务和挑战"></a>工作任务和挑战</h1><p>7 月份离开华为，究其原因是我没有感觉到技术上哪怕一丝的提升，而且工作过程中极端的压迫和疲惫。这一段时间自己在读研期间的好习惯几乎全部打破，随之而来的是远离已久的坏习惯，整个人被紧张和欲望控制的死死的。</p>
<p>11 月份入职优克云联，得益于项目起步、同事交流和个人时间的允许，才体会到自身技术能力在不断进步，并且不断扩张。由于入职较早，所以比后进来的同事更加熟悉产品和业务流，因此在今年的后半年开始发力做一些难度较大的工作。</p>
<p>第一份具有挑战性的工作是跟踪系统。前期设计没有考虑此功能，没有预先埋点，没有统一规范，团队对运维性质的工作内容积极性不高，加上自己第一次去推动涉及几乎全部模块的业务，没有经验，跟踪系统在预研一段时间后，被紧急需求挂起。后期虽然启动了一个版本，但远没有 ELK 平台方便，因此此次探索算是失败的。</p>
<p>失败中了解到：1. 全链路追踪关注调用链，并非关注业务本身，比如 sleuth + zipkin，可以清晰地看出 A 服务调用 B 服务，执行了多长时间等。对于异步的场景，由于 Runnable 和 Callable 均为 JDK 原生的，因此无法提供传递 SPAN 的埋点，全链路中无法体现。 2. ELK 平台在业务日志分析上很强大，几乎不需要新建跟踪系统，因为 ELK 可以更加全面的给开发人员提供定位问题所需要的信息，而且还可以做一些简单的可视化统计类指标，添加告警，所以起初我们做跟踪系统的路有些走偏了。3. 跟踪系统交给 ELK 以后，指标类的数据应由流式数据计算完成统计上报，并一定程度上反馈业务本身，减少运营人员的人工分析成本。</p>
<p>第二份是开发呼叫控制服务。有了前面失败的教训，自己认真去调研了 Spring State Machine 的用法，但此次对系统的改造历经 2 个月才发布。原因有二：1， 对系统的改造动作过大，几乎重写了全部的呼叫接续逻辑，但从工作量来看就难以快速迭代交付；2， 改造的系统还在持续不断地融入新功能，新系统必须包含全量的新功能。本次服务的选型、原型验证、工作拆分、开发、测试、性能调优，本人都身先士卒，最终在没有出现大问题的情况下交付完成。除了时间上延时较大，整体结果来看，还是不错的。</p>
<p>第三份是目前正在做的灰度。灰度升级又是一个设计全量服务的系统。第一版本分析出来各服务的入口为， HTTP 和 KAFKA，为了减轻业务侵入，自己给 RIBBON 做了插件，给 KAFKA 客户端做了切面，并以注解和 starter jar 包的形式提供给了各服务。由于侵入性低，各服务拉通比较顺利。后期有发现，服务的任务启动入口还有1， TCP 长连接；2，定时任务。由于这两个启动入口在个别服务中有，再加上赶进度，就先交由业务模块处理了。</p>
<p>每一个方案的概要设计、详细设计和原型验证均通过自己一板一眼的去研习成熟的开源项目，去和同事交流，去写代码验证。这个过程才是我想要的，虽然很头大，但收获也很大。</p>
<h1 id="平时总结积累"><a href="#平时总结积累" class="headerlink" title="平时总结积累"></a>平时总结积累</h1><p>从去年 5 月份启动博客开始，坚持了一月一篇的频率更新了下来了。这件事情让我很开心。博客没有单纯介绍某某东西怎么用，而是切切实实的记录了自己的一些思考。比如线程池、Jedis，都是自己读完源码以后的总结和感悟。比如 Mosquitto 也是自己研读了一部分代码的整理和思考，虽然后面此项目自己没有参与，但是还是感谢自己去年的坚持。REST 用法的翻译、CAP 理论的整理记录、PAXOS 算法的整理记录，都是比较消耗时间的。</p>
<p>工作过程中，解决过 REDIS 哨兵网络原因引起的客户端连接到从库上出现 READ ONLY 的难题，解决过 kafka 空转情况下，流量出现 5 MB 的问题，解决过服务 CLOSE_WAIT 问题，解决过公司自研一致性 hash Jedis 客户端归还异常连接错误问题，解决过莫名其妙不知道消息去哪里的问题。这些问题在解决之前都显得悬而未决，异常难缠，最终都解决了。得益于公司比较轻松的氛围，给时间，给精力去了解这些中间件，了解了自然就更容易知道问题出现在什么地方。</p>
<h1 id="下一步工作学习规划"><a href="#下一步工作学习规划" class="headerlink" title="下一步工作学习规划"></a>下一步工作学习规划</h1><p>学习一直围绕工作，这是目前自身能力所限定的，还不具备一边工作，一边搞其他技术的眼界和水平。下一步向上需要更加清晰一个商业系统的整体结构，在整体结构的基础上，探索各个组件的优缺点和边界，在各个组件上研习核心技术。</p>
<p>之前的学习习惯都倒过来了，导致难以学以致用，而且出现学习和实践断节的现象。</p>
<h1 id="聊聊公司产品形态"><a href="#聊聊公司产品形态" class="headerlink" title="聊聊公司产品形态"></a>聊聊公司产品形态</h1><p>从我自身一个屌丝程序员来看，产品形态不应该只局限于终端，而是提供一个稳定的平台，对接更多形态的终端，现在 docker k8s 这些均为云化服务提供了可能，没必要还局限在我就是要卖个终端这条路，但是卖终端这条路不能丢，因为只有有钱了才能做事情，否则理想只可能是幻想。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2019/01/12/consensus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/12/consensus/" itemprop="url">consensus 共识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-12T13:17:00+08:00">
                2019-01-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/base/" itemprop="url" rel="index">
                    <span itemprop="name">base</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://imengdong.cn/2018/11/18/acid%20base%20cap/" target="_blank" rel="noopener">一气呵成了解分布式</a>介绍了入门分布式系统的一点基本理论。在现有的网络基础设施条件下，<strong>CAP</strong> 理论中的 P 是不可避免的，因此我们需要在 C 和 A 中做选择。<strong>Base</strong> 理论选择了 AP，强调基本可用、最终一致性，后面我们讨论工业界常见的达成最终一致性的方案。在有些常见的系统中，选择 CP，如果获取不到一致性的值，则会直接导致不可用，zookeeper 就是其中之一。本文从 paxos 入手介绍分布式共识算法。</p>
<h1 id="分布式共识模型"><a href="#分布式共识模型" class="headerlink" title="分布式共识模型"></a>分布式共识模型</h1><p>在具备容错能力的分布式系统中，分布式共识问题是需要解决的一个基本问题，<strong>它指的是多个分布式节点就某变量的值达成一致，而且一旦达成一致，则该值就是最终确认的值，不会由于某个节点的异常导致该值变化</strong>。<br>分布式共识模型是对工业界需要解决的常见问题的抽象，比如：选主、加锁等。想必大家见识过不止一种选主手段，比如采用 zookeeper 进行选主、在 redis 中通过 redis-sentinel 进行选主等。</p>
<h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><blockquote>
<p>如果我们不做数据内核相关的工作，目前对该类算法不感兴趣并不影响我们日常的工作，毕竟这是科学家搞出来的算法，有难度。然而简单了解一下却可以帮助我们了解到类似 zookeeper 这些分布式协调服务的能力边界，不至于认为它可以顺利解决所有分布式问题。</p>
</blockquote>
<h2 id="形象化描述"><a href="#形象化描述" class="headerlink" title="形象化描述"></a>形象化描述</h2><p>受论文的影响，paxos 算法介绍的时候总是采用议会选举来描述。这里我们采用小伙伴们常见的约球选球场的方式说明如何就选择哪个球场达成共识。共识问题描述如下：你和其余4个朋友共 5 人，相约每周日要去球馆打篮球。市区内有 30 个球馆在周日提供服务。现在你们周日要去打球了，你们几个只能通过手机（不能建立群组）相互联系，并且由于西安联通的信号很差，所以小伙伴之间经常无法正常取得联系，那么大家怎么最终就选择某个球馆达成一致呢？</p>
<h2 id="PAXOS-算法"><a href="#PAXOS-算法" class="headerlink" title="PAXOS 算法"></a>PAXOS 算法</h2><img src="/2019/01/12/consensus/paxos1.jpg">
<p>上图是对球场共识场景的一个简化，5 人可以同时承担提议者和接受者的角色。为了便于理解，我们让这些人只担当一种角色，从 2 个提议者，3 个接受者的角度入手描述。</p>
<p>上图描述了 paxos 最简单的场景。小 A 分别对 3 个接受者说，我来给大家选球场（prepare[N]）吧。3 个接受者说好（promise[N]）。小 A 收到这 3 个接受者的授权后，分别对 3 个接受者说，我们去 V 球场（Accept[N，V]）吧。三个接受者因为没有收到其他人的建议就回复小 A 说好（Accepted[N,V]）。此时就去 V 球场就达成了一致。小 B 这时和三个接受者说，我来给大家选球场（prepare[M])吧。若M &lt; N，则接受者会忽略；若M &gt; N，则接受者会告诉小 B，我们已经决定了去 V 球场。此时小 B 接收到了 3 个接受者的拒绝信息，就确定大家都去 V 球场了。</p>
<p>比如三个接受者中有一个联系不上了，即分布式系统中出现了分区问题，那么怎么办？ </p>
<img src="/2019/01/12/consensus/paxos2.jpg">
<p>上图中虽然有一个接受者联通信号不行，联系不上了，但是由于小 A 获得了超过一半的接受者的支持（达到了quorum）,小 A 依旧会提供自己的建议给这些接受者，直到最终就 V 球场达成一致。等到信号差的接受者电话好了，其他接受者会将选择了 V 球场作为共识的信息通知到该接受者。因此我们可以看到 paxos 算法就最终去 V 球场达成了一致。也就是说<strong>只要接受者有一半可以正常联系到，那么就可以达成共识，容错能力超强</strong>。</p>
<h2 id="PAXOS-算法问题"><a href="#PAXOS-算法问题" class="headerlink" title="PAXOS 算法问题"></a>PAXOS 算法问题</h2><p>也许你已经发现上述算法一个很大的漏洞，即如果小 A 说完我给大家选球场（prepare[N]），三个接受者同意后（promise[N]）,小 B 也说我给大家选球场(prepare[M])，三个接受者由于还未达成任何共识，因为 N &lt; M，他们必须同意小 B 选球场（promise[M]）。此时如果小 A 提出了去球场 V (accept[N,V])打球，三个接受者会因为小 B 的 M 更大而忽略小 A 的提议。此时小 A 会重新提出我来给大家选球场（prepare[P])，M &lt; P。如此循环下去，那么这个将无休无止了，最终无法选出一个球场。如下图所示：<br><img src="/2019/01/12/consensus/paxos-problem.jpg"><br>令大家意想不到的是，工业界解决这类问题的方法简单到爆：随机时间。即如果提案被忽略，则需要等待一个随机时间才可以再次提出 prepare，该随机时间通常会超过上一个提案达成共识的时间。</p>
<h2 id="MULTI-PAXOS-算法"><a href="#MULTI-PAXOS-算法" class="headerlink" title="MULTI-PAXOS 算法"></a>MULTI-PAXOS 算法</h2><p>通过对 PAXOS 介绍，我们可发现，每个共识的生成，都至少需要 4 个步骤，两次 RPC，对一个高性能的共识服务器是一个不小的冲击，那么是否可以简化呢？答案是肯定的。我们平时选择球场的时候，通常会由固定的某一个人发起，multi-paxos 选用类似的方式。</p>
<img src="/2019/01/12/consensus/multi-paxos.jpg">
<p>上图是 multi-paxos 算法的描述，与 paxos 不同的是， multi-paxos 会首先通过 paxos 的方式选主。上图中选定小 A 为第 I 年度的队长，那么以后每周去哪个球馆都由小 A 直接向接受者提出（accept[N, I, V]），而不需要先向接受者提出让自己来选择球馆(prepare[N])。这样除了第一次是 4 个步骤，后续只需要两个步骤，少了一半。</p>
<p>假如小 A 也换成了联通手机，大家都无法联系到小 A 了（即分布式系统中主异常），此时剩下的几人就需要重新选出一个主，即选取第 J 年度队长。等小 A 联系上了之后，接受者会通知小 A，由于你的信号太差，我们选了小 B 作为第 J 年度队长，以后我们让小 B 通知大家吧，小 A 也就欣然接受小 B 作为队长，以后不再提出异议。</p>
<h2 id="raft、zab"><a href="#raft、zab" class="headerlink" title="raft、zab"></a>raft、zab</h2><p>raft 和 zab 是 multi-paxos 的变种，它们将共识过程分为 3 步：1. 选主；2，备份；3.安全性。raft 在选主完成之后，主会周期性的通过心跳通知从，大哥还好好的，你们听话，直到主异常后，才会进入下一轮的选主。 zab 则在选主完成之后，从周期性的通过心跳看大哥是不是好好的，如果不好就篡位了。想更形象了解 raft，可以通过<a href="https://raft.github.io/了解。" target="_blank" rel="noopener">https://raft.github.io/了解。</a></p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>通过上述的介绍，我们对分布式共识算法有了初步了解。我们知道 zookeeper 实现了 zab 协议，那么它可以做到什么，做不到什么呢，又是如何工作的呢？</p>
<img src="/2019/01/12/consensus/masterandlock.jpg">
<p>因为 zookeeper 可以就某一值达成共识，所以我们可以通过 zookeeper 对我们的服务进行选主。由于算法的安全性保障只要达到 quorum 的 zookeeper 正常工作，我们最终可以确认唯一的节点为主节点。分布式锁也可以由 zookeeper 实现，一旦某个客户端加锁成功，则 zookeeper 会就这一情况达成共识，即使主 zookeeper 后来挂掉，也会延续这一共识。但我们要认识到，在 curator-recipes 的实现中采用的临时 node，那么一旦具有锁的客户端连接丢失，超过 session 时间后，锁就会被释放。</p>
<p>zookeeper 不能完成所有情况下客户端强一致性的保证。比如我们用 zookeeper 做个简单的配置中心，配置下发过程中，一旦客户端连接丢失，则配置信息不会及时通知到客户端。也就是说，我们不能就此保证各个客户端目前肯定就某一种配置达成一致。<br><img src="/2019/01/12/consensus/client.jpg"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/12/23/springcloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/springcloud/" itemprop="url">springcloud</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-23T20:30:00+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文讲述如何使用 spring cloud 中的部分基础设施构建一套微服务脚手架，基于该脚手架工程丰富自己的业务，而无需关注过多基础设施的开发。</p>
</blockquote>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>开源社区有很多能量很大的工程师，优秀地抽象了基础设施具备的能力。Spring 提供了 IoC 、 AOP 基础能力，基于此基础能力，很多基础设施又都方便得集成到了 Spring 上面，从而构成了大而全的 Spring Cloud 项目，而且还在不断地发展。Spring Cloud 是一套完整的微服务基础设施方案，我们通常采用如下方式构建项目：</p>
<img src="/2018/12/23/springcloud/springcloud.png">
<p>Zuul 被用作 API 网关，同时借助 Ribbon 和 Hystrix 提供可监控的服务器负载均衡能力。Zuul 服务通常采用 Eureka-Client 注册到 Eureka-Server，用于获取内部服务的状态，并将请求转发给对应的服务。内部服务通过 Ribbon、Hystrix、Feign 完成微服务间调用。通过 Sleuth 监控微服务调用的依赖关系和性能，将监控到的元数据 SPAN 发布到离线消息队列 KAFKA，用 Zipkin 展示微服务调用的依赖关系和性能。Actuator 用于检查服务本身的运行状态：CPU状况、内存状况等。</p>
<h1 id="微服务和SOA"><a href="#微服务和SOA" class="headerlink" title="微服务和SOA"></a>微服务和SOA</h1><p>上图中提供了一套微服务的基础设施，然而，在历史包袱的情况下，我们是不能一步到位将所有服务都转型为微服务的架构。那么整个的微服务模块可以作为一个整体对外提供服务，也就是 SOA 结构。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/12/18/ribbon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/ribbon/" itemprop="url">ribbon</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-18T19:31:00+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/base/" itemprop="url" rel="index">
                    <span itemprop="name">base</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文只对 Ribbon 的概要设计进行描述，从客户端负载均衡器的角度认识 Ribbon，便于自己设计和实现客户端负载均衡器，或者为 Ribbon 做插件满足自身业务需求（最近项目中我们给 Ribbon 做了个小插件完成 A/B 测试能力）。源代码分析可以自行深入或者配合博客书籍自己阅读。</p>
</blockquote>
<p>Ribbon 是一款非常优秀的客户端负载均衡工具，在 Spring Cloud 的微服务架构中起了至关重要的作用。近来由于项目的需要，对 Ribbon 的原理进行了深入学习，同时在 Ribbon 的基础上扩展了几个点，所以对 Ribbon 有了更新的认识。</p>
<h1 id="客户端负载均衡和服务端负载均衡"><a href="#客户端负载均衡和服务端负载均衡" class="headerlink" title="客户端负载均衡和服务端负载均衡"></a>客户端负载均衡和服务端负载均衡</h1><p>之前介绍 REST 的时候介绍过为了降低服务器开发的复杂性，REST 的设计理念当中，HTTP 请求需要客户端负载均衡，Ribbon 就是 HTTP 客户端负载均衡工具；不过想必大家也听说过诸如 Nginx 、 Zuul 这些具有服务器负载均衡能力的网关。那么问题来了：为什么既有客户端负载又要有服务端负载均衡呢？</p>
<img src="/2018/12/18/ribbon/loadbalancer.png">
<p>从功能上来讲，服务端负载均衡通常出现在服务网关中，网关隔离外部客户端和内部服务，这个外部客户端如同用户和服务的中介。比如：小明在 APP 点击下单，此时 APP 会将下单的请求发送到淘宝的网关，再由网关转到对应的服务。网关在隔离 APP 和服务的同时，为服务提供负载均衡的能力。客户端负载均衡通常出现在内部服务的交互中，在微服务架构中尤为常见。比如服务 A 查询服务 B 中某用户是否在黑名单，从而进一步决定自己的业务流向。上图中红色部分为服务端负载均衡，绿色部分为客户端负载均衡。</p>
<h1 id="Ribbon-的工作方式"><a href="#Ribbon-的工作方式" class="headerlink" title="Ribbon 的工作方式"></a>Ribbon 的工作方式</h1><p>Ribbon 通过在 RestTemplate 上面添加 @LoadBalancer 实现。RestTemplate 是 Spring 为我们封装的 HTTP 请求工具，借助 @LoadBalancer 可以为 RestTemplate 设置请求前拦截器，用以拦截请求，根据策略为该请求选择合适的实例，并将请求转发出去。<br>我们不妨从一个设计者的角度出发去思考如何设计一个客户端负载均衡器。第一步，需要我们获取服务实例状态；第二步需要根据服务实例状态按照某种策略选择一个实例；第三部需要将请求发送到该实例。其实这也是 Ribbon 的总体设计。</p>
<img src="/2018/12/18/ribbon/ribbonmodule.png">
<p>如上图所示，Ribbon 通过 ServerList 提供的方法获取实例状态。 ServerListUpdater 采用周期性拉取服务器实例或者经由注册中心发布服务器实例状态变更信息。ServerListFilter 按照规则过滤出符合规则的服务器实例，提供了更多的个性化能力。IPing 用于测试服务器实例是否正常。这些信息足够我们获取全部实例的状态。在全部实例状态的基础上，IRule 提供了众多的实例选取策略，比如轮询、随机、权重等。在我们选择了一个实例以后，就可以将请求发送到服务实例。</p>
<h2 id="获取服务实例状态"><a href="#获取服务实例状态" class="headerlink" title="获取服务实例状态"></a>获取服务实例状态</h2><p>Ribbon 可以通过配置读取服务器实例状态，也可以通过 Eureka-Client 等服务发现客户端从服务注册中心获取全量服务器实例状态。通常情况下，Ribbon 提供的这两种方式足以满足我们的业务需求。但是有些情况下我们想让 Ribbon 按照我们指定的策略获取服务器实例信息，怎么处理呢？</p>
<p>从上面的介绍可知， ServerListFilter 可以从全部实例中按照规则过滤服务器实例，所以此处我们是可以自定义 ServerListFilter 规则，并在配置文件中指定我们的 ServerListFilter 为 Ribbon 过滤服务器的策略，这样在每次 ServerListUpdater 触发执行的时候，都会按照我们指定的 ServerListFilter 选择服务器实例。</p>
<p>Ribbon 在 ServerListFilter 也提供了众多的方案，比如 Zone亲和、动态获取等。</p>
<h2 id="选择指定类型的服务实例"><a href="#选择指定类型的服务实例" class="headerlink" title="选择指定类型的服务实例"></a>选择指定类型的服务实例</h2><p>Zuul 网关在实现的时候直接集成了 Ribbon 和 Hystrix（模块化做的太好了），直接在网关上面集成了负载均衡的能力。假设我们需要为每个请求选择指定类型的服务器实例，请求 reqA 选择 A 类型的服务实例，请求 reqB 选择 B 类型的服务实例，怎么处理呢？</p>
<p>乍一看我们可以通过 ServerListFilter 来完成，但是其实是做不到的。因为 ServerListFilter 的执行时机是 ServerListUpdater 触发的时候，与 HTTP 请求的生命周期是没有任何关系的。即使没有请求 ServerListFilter 依旧会被 ServerListUpdater 触发；请求到来也不会触发 ServerListFilter。因此我们无法通过 ServerListFilter 为每个请求选择服务实例。我们可以通过扩展 ILoadBalancer 来根据请求内容变换 ILoadBalancer 的服务器实例信息。因为请求到来后，必然会执行 IRule 的 chooseServer 方法， chooseServer 方法会从负载均衡状态对象中获取服务器实例状态，在返回这些状态的时候，我们可以通过 req 携带的 A 或者 B 信息筛选服务器实例，并传递给 IRule。 IRule 只会从这些返回实例中根据路由规则获取一个实例。可以看一下 Ribbon 的 chooseServer 实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 可以看到我们把 ILoadBalancer 传递进去了，他会提供 getReachableServers getAllServers 等信息给 IRule 让其选择一个实例</span><br><span class="line"> */</span><br><span class="line">public Server choose(ILoadBalancer lb, Object key) &#123;</span><br><span class="line">    if (lb == null) &#123;</span><br><span class="line">        log.warn(&quot;no load balancer&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Server server = null;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (server == null &amp;&amp; count++ &lt; 10) &#123;</span><br><span class="line">        List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">        List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">        int upCount = reachableServers.size();</span><br><span class="line">        int serverCount = allServers.size();</span><br><span class="line"></span><br><span class="line">        if ((upCount == 0) || (serverCount == 0)) &#123;</span><br><span class="line">            log.warn(&quot;No up servers available from load balancer: &quot; + lb);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int nextServerIndex = incrementAndGetModulo(serverCount);</span><br><span class="line">        server = allServers.get(nextServerIndex);</span><br><span class="line"></span><br><span class="line">        if (server == null) &#123;</span><br><span class="line">            /* Transient. */</span><br><span class="line">            Thread.yield();</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">            return (server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Next.</span><br><span class="line">        server = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (count &gt;= 10) &#123;</span><br><span class="line">        log.warn(&quot;No available alive servers after 10 tries from load balancer: &quot;</span><br><span class="line">                + lb);</span><br><span class="line">    &#125;</span><br><span class="line">    return server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h2><p>或许有些朋友好奇为什么指定了我们自己提供扩展，Ribbon 就会使用我们提供的扩展而不是使用期默认的实现。Springboot 的约定大于配置并非废弃配置，只是提供了一种便捷的配置方案。下面举例说明 Ribbon 是如何实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">	@ConditionalOnMissingBean</span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	public ServerListFilter ribbonServerListFilter(IClientConfig config) &#123;</span><br><span class="line">		if (this.propertiesFactory.isSet(ServerListFilter.class, name)) &#123;</span><br><span class="line">			return this.propertiesFactory.get(ServerListFilter.class, config, name);</span><br><span class="line">		&#125;</span><br><span class="line">		ZonePreferenceServerListFilter filter = new ZonePreferenceServerListFilter();</span><br><span class="line">		filter.initWithNiwsConfig(config);</span><br><span class="line">		return filter;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>从 RibbonClientConfiguration.java 的ServerListFilter 这段代码中可知， Spring 在装配 Ribbon 的 ServerListFilter 的时候，会先从 propertiesFactory 查询是否已经配置，如果是，则返回配置的 filter，否则创建 ZonePreferenceServerListFilter， 初始化之后返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 读取配置文件获取类</span><br><span class="line"> */</span><br><span class="line">public String getClassName(Class clazz, String name) &#123;</span><br><span class="line">	if (this.classToProperty.containsKey(clazz)) &#123;</span><br><span class="line">		String classNameProperty = this.classToProperty.get(clazz);</span><br><span class="line">		String className = environment.getProperty(name + &quot;.&quot; + NAMESPACE + &quot;.&quot; + classNameProperty);</span><br><span class="line">		return className;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果类存在则实例化该类，并返回</span><br><span class="line"> * 否则返回 null</span><br><span class="line"> */</span><br><span class="line">public  C get(Class clazz, IClientConfig config, String name) &#123;</span><br><span class="line">	String className = getClassName(clazz, name);</span><br><span class="line">	if (StringUtils.hasText(className)) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Class toInstantiate = Class.forName(className);</span><br><span class="line">			return (C) instantiateWithConfig(toInstantiate, config);</span><br><span class="line">		&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">			throw new IllegalArgumentException(&quot;Unknown class to load &quot;+className+&quot; for class &quot; + clazz + &quot; named &quot; + name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 getClassName 从配置文件中读到了配置的类，则通过 Class.forName 和 instantiateWithConfig 初始化一个 ServerListFilter 实例，并返回给 Spring 容器，后续状态整个负载均衡器的时候，采用 ServerListFilter 装配。</p>
<p>所以我们在提供 starter 的时候，也可以采用这种方式实现，提供更加灵活的配置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/11/18/acid base cap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/18/acid base cap/" itemprop="url">一气呵成了解分布式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-18T10:26:00+08:00">
                2018-11-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/base/" itemprop="url" rel="index">
                    <span itemprop="name">base</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>分布式的理念已经遍地开花，无论数据库存储、大规模计算、文件系统以及大多数商用软件的后台服务器都无法绕开分布式。相比于单机系统而言，分布式无论从理解上还是管理上复杂性都提高了不止一个量级，为什么大家还要选择用分布式？分布式在解决了某些问题的时候，又给我们带来了哪些新的问题？在设计分布式应用的时候，需要遵循哪些基本原则？日常我们又用过哪些分布式系统呢？本文将围绕上述的问题展开说明。</p>
<h1 id="分布式简介"><a href="#分布式简介" class="headerlink" title="分布式简介"></a>分布式简介</h1><h2 id="认识分布式系统"><a href="#认识分布式系统" class="headerlink" title="认识分布式系统"></a>认识分布式系统</h2><p>分布式系统将一组计算机组合起来，提供统一的服务。从使用者角度来看，分布式系统使用起来和单机系统是一样的。下面我们引用[1]中的例子进行说明。</p>
<img src="/2018/11/18/acid%20base%20cap/traditional&distribute.png">
<p>传统的数据库安装在一个单机 OS 的文件系统上，所有与该数据库的交互（CRUD）都在该数据库完成。而在分布式数据库部署中，用户通常会和多个数据库服务器交互。从上图可以看出，采用分布式数据库部署之后，第一可以将读写数据库操作分离；第二可以进行数据备份；第三可以进行主从切换。</p>
<h2 id="分布式系统的成因"><a href="#分布式系统的成因" class="headerlink" title="分布式系统的成因"></a>分布式系统的成因</h2><p>相较于单机系统，开发、调试、部署、运维分布式系统的难度更大。甚至可以这样说，一个完整的运维监控平台是分布式系统进入商用阶段必不可少的一部分（ google 发表了 dapper 论文，facebook 开发了 zipkin 工具，spring cloud 也集成 sleuth ）。商用分布式系统意味着规模庞大的运维监控管理平台。既然如此，我们为什么还要做分布式系统？</p>
<blockquote>
<p>此处声明一个观点：被逼的。分布式系统除了解决了单机系统面临的难题外，还引入了单机系统不存在的问题。有钱有势，我想没必要做分布式系统。想必大家在办事情的时候都遇到过“我们领导不在，你明天再来。”这种牛逼的回答。人家就是纯单机，领导不在直接不提供服务。</p>
</blockquote>
<p>显然分布式系统并非智力游戏，它提供了单机系统所不具备的几个重要的影响用户体验的能力：</p>
<ol>
<li><p><strong>水平扩展能力</strong><br>水平扩展指若一个服务节点可以为 m 个用户提供正常服务，那么 n 个服务节点可以为 n * m 个用户提供正常服务。也就是说系统可服务的用户数可随着服务节点个数线性增长。<br>通常我们达不到如此理想的水平扩展能力，因为随着节点个数增多，节点间信息同步、路由用户到某节点等开销都会增大。所以只要在 n = max_user_num / m 的范围内（其中 max_usr_num 为预估用户最大值）满足水平扩展，我们就可以认为该系统具有水平扩展能力。<br>与水平扩展相呼应的的扩展方式叫做垂直扩展，垂直扩展通常指提高单机硬件设备处理能力。垂直扩展对于大业务量的服务器来讲通常是杯水车薪。</p>
<blockquote>
<p>想象一个场景，随着用户量的变大和需求的愈加复杂，有一天突然节点 CPU 80%，free -m 为100，投诉纷至沓来。正在老板焦头烂额之际，很多人提出了两个方案：1， 让码农加班优化；2，买主频更高的 CPU ，换更大的内存。第一种方案，等你优化完，项目组都解散了；第二种方案，即使是目前最好的 CPU，它的处理能力也是有限的；可扩展内存的数量也是非常有限的。此时若只需要在云端扩充几个一模一样的节点就可以迅速恢复服务将会是最快速稳妥的方案。</p>
</blockquote>
</li>
<li><p><strong>更高的可用性</strong></p>
<p>假设一台主机在某一时刻发生不可恢复的故障的可能性为 1/1000。根据概率论的知识可知 n 台主机在某一时刻同时故障的概率为 (1/1000) ^ n。在 n &gt; 1 的情况下，分布式比单机系统提供了更高的可用性的。</p>
</li>
<li><p><strong>更小的延迟</strong></p>
<p>第一由于分散了服务节点压力，服务节点可以更快的响应用户；第二若多地域部署分布式系统，用户可以选择就近接入，提高响应速度。</p>
</li>
</ol>
<h1 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h1><p>事物总是具有两面性，分布式系统在解决单机系统出现的问题的同时也引入了单机系统没有的多节点数据一致性问题。下面我们首先介绍产生该问题的原因（CAP），然后介绍两种解决数据一致性问题的实践。</p>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>CAP （Consistency、Availability、Partition Tolerance)是指在现在基础设施条件下，一个分布式系统无法同时满足一致性、可用性和分区容忍性。</p>
<img src="/2018/11/18/acid%20base%20cap/cap.png">
<ul>
<li><p><strong>一致性（Consistency）</strong> ： 所有节点访问同一份最新的数据副本</p>
</li>
<li><p><strong>可用性（Availability）</strong> ：每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据</p>
</li>
<li><p><strong>分区容忍性(Partition Tolerance)</strong> ： 以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</p>
</li>
</ul>
<p>就现在基础设施而言，网络是不可靠的，分区是必然的。如果我们保证了一致性，那么在分布式系统数据未达成一致的时间内，是不能提供访问的，即不具备可用性。如果我们保证了可用性，那么在分布式系统数据未达成一致的时间内，我们提供的数据不是最新数据，即不保证一致性。</p>
<blockquote>
<p>AP 和 CP 均有商用分布式系统采用，就数据库而言，Cassandra 是 AP，MySQL 事务则是 CP。</p>
</blockquote>
<h2 id="ACID-VS-BASE"><a href="#ACID-VS-BASE" class="headerlink" title="ACID VS BASE"></a>ACID VS BASE</h2><h3 id="事务-ACID"><a href="#事务-ACID" class="headerlink" title="事务 ACID"></a>事务 ACID</h3><ul>
<li><strong>原子性（Atomicity）</strong> : 数据库事务要么完整的执行完毕，要么就恢复执行之前的状态。不允许出现执行一部分的状态。</li>
<li><strong>一致性（Consistency)</strong> : 事务将数据库从一个合法状态转移到另一个合法状态。比如银行转账，A转给B 500，那么事务执行成功后必须是 A 减少 500，B增加 500 ，不能出现 A 减少 500 ，B 没变的情况。</li>
<li><p><strong>隔离性（Isolation）</strong> : 多个客户端生成的多个事务是互相隔离执行。隔离级别分为 4 类：脏读、不可重复读、幻读、串行。</p>
<blockquote>
<ol>
<li>脏读： A B 事务并行执行，A 事务写入的未提交的数据被 B 事务读取到</li>
<li>不可重复读： A B 事务并行执行，A 事务写入的已提交的数据被 B 事务读取到</li>
<li>幻读： A B 事务并行执行，A 向表中添加了一条数据，B 通过查询全部记录条数统计到该数据，但却无法检索出来。</li>
<li>串行： A B 事务并行执行， B 事务必须等 A 事务执行完毕才能执行。</li>
</ol>
</blockquote>
</li>
<li><strong>持久性（Durability）</strong> : 事务的数据操作必须反映在非易失性存储中（比如硬盘）并在事务成功完成后保持不变。事务失败则不能使数据处于部分提交状态。</li>
</ul>
<p>由此可见事务为了保证一致性，但牺牲了可用性。即若不能达成一致性，则拒绝提供服务，直到全部成功或全部失败。</p>
<h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><ul>
<li><strong>基本可用（BasicallyAvailable）</strong> ：系统总是可以给用户一个响应</li>
<li><strong>可变状态（Soft State）</strong> : 系统中存储的值可能在返回给用户之后又发生了变化</li>
<li><strong>最终一致性（Eventually Consistent）</strong> : 当数据添加到系统后，系统会将数据逐渐复制到其他节点。也正是由于最终一致性要求，会产生可变状态。</li>
</ul>
<p>由此可见 BASE 理论采用可变状态 + 最终一致性减弱了一致性约束。它倾向于 AP。</p>
<p>我们知道，为了保证事务的 ACID 特性，关系型数据库通过 MVCC 做了大量的工作。然而在很多应用场景中，强一致性并没有可用性那么重要。比如，线上抢购系统，在10000个人同时抢购的时候，显示还有 1000 台， 最终可定有 9000 个用户没抢上，再下单时台数已经为 0。然而用户是可以接受这种现象的。但是如果为了强一致性要求，而使得网站拒绝服务，则会让用户反感。</p>
<h1 id="分布式模型"><a href="#分布式模型" class="headerlink" title="分布式模型"></a>分布式模型</h1><p>虽然都是分布式服务，但是提供服务的方式不尽相同，下面介绍两种常见的分布式模型。</p>
<h2 id="主备模型"><a href="#主备模型" class="headerlink" title="主备模型"></a>主备模型</h2><p>主备模型多见于持有状态的服务，比如数据库、消息队列、任务调度等。比如在写入比例远小于查询比例的场景中，MySQL 部署方式采用的是一主多备，主库写入，备库读取；Kafka 的 partition 在各 Kafka 的物理机上分布的时候也是一主多备，在主 partition 故障之后，备 partiton 继续提供数据；分布式调度框架通常也采用一主多备的形式，主调度负责下发任务，在主调度故障之后，由备调度继续下发任务。</p>
<p>对于 Kafka 来讲只是数据上的主备，处理上采用的是多活模型，因此支持水平扩展。对于 MySQL 来讲，处理上就采用的主从模型，即只有主库具有写入权限，备库只支持查询。这个时候的水平扩展给我们带来另外一个话题：客户端协作。</p>
<h3 id="客户端协作"><a href="#客户端协作" class="headerlink" title="客户端协作"></a>客户端协作</h3><p><strong>服务器分片</strong>，比如 redis-cluster 系统，在客户端向 cluster 中的节点 A 发起请求的时候，若请求的结果在节点 A 上，那么 redis-cluster 会将结果直接返回，如果在 B 节点， redis-cluster 会给客户端回复一个重定向命令，客户端会将请求发往 B 节点，从而完成分布式操作。这是 redis-cluster 是可以支持水平扩展的。<br><strong>客户端分片</strong>，比如 mycat 服务用来支持 MySQL 的水平扩展。在客户端发起请求的时候，由客户端对请求进行路由，分发到不同的 MySQL 服务器。</p>
<h2 id="多活模型"><a href="#多活模型" class="headerlink" title="多活模型"></a>多活模型</h2><p>多活模型通常用于业务应用开发，业务应用的状态全部存储在缓存、消息队列、数据库等服务中，业务应用本身无状态。业务应用提供无差别服务。<br>我们知道，多活模型通常有两种方法来导流客户端请求：<strong>服务器路由</strong> VS <strong>客户端路由</strong>。<br>在 Spring Cloud 的微服务架构中采用<strong>客户端路由</strong>。服务端注册到 Eureka-Server 并提供 RESTful 接口（无状态接口），客户端（Ribbon 、 Hystrix 、 Feign）通过 Eureka-Server 提供的接口发现服务，并采用既定的路由规则进行路由。Ribbon 提供了多种路由，IRule 接口提供了服务发现的规则（包括轮询、加权、区域亲和等），chooseServer 接口提供了选择服务的规则，在这两种策略的配合下，为客户端选择出指定的服务器。</p>
<p>对于对外提供的接口（整个系统之外），则需要用到<strong>服务器路由</strong>，通常采用 Zuul、Nginx 等负载均衡工具，针对服务器的使用情况进行负载均衡。</p>
<h1 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h1><h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>思考中，未消化。<br><a href="https://zhuanlan.zhihu.com/p/25933039" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25933039</a><br><a href="https://zhuanlan.zhihu.com/p/36153160" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36153160</a></p>
<h2 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h2><p>分区容忍性（CAP 中的 P）是不可避免的，在网络环境下，节点无法全部互联，从而出现各自为政的局面，如下图所示，我们称之为脑裂现象。</p>
<img src="/2018/11/18/acid%20base%20cap/splitbrain.png">
<p>如上例，我们假定上述5个节点为 redis-sentinel 节点，左边三个互联，右边两个互联，左边和右边网络断开连接，此时需要哨兵投票哪个 redis 服务器作为主服务器。左边三个认为 A 是或者的，选择了 A 节点，右边两个认为 B 是存活的，选择 B 节点，那么就会存在数据不一致的严重问题。如何保证一致性或最终一致性呢？</p>
<h3 id="Quorum-（维基百科）"><a href="#Quorum-（维基百科）" class="headerlink" title="Quorum （维基百科）"></a>Quorum （维基百科）</h3><p>Quorom 机制，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鸽巢原理。</p>
<p>在有冗余数据的分布式存储系统当中，冗余数据对象会在不同的机器之间存放多份拷贝。但是同一时刻一个数据对象的多份拷贝只能用于读或者用于写。该算法可以保证同一份数据对象的多份拷贝不会被超过两个访问对象读写。</p>
<p>分布式系统中的每一份数据拷贝对象都被赋予一票。每一个读操作获得的票数必须大于最小读票数（read quorum）（Vr），每个写操作必须获得获得的票数必须大于最小写票数（write quorum）(Vw）才能读或者写。如果系统有V票（意味着一个数据对象有V份冗余拷贝），那么最小读写票数(quorum)应满足如下限制：</p>
<ol>
<li>Vr + Vw &gt; V</li>
<li>Vw &gt; V/2</li>
</ol>
<p>第一条规则保证了一个数据不会被同时读写。当一个写操作请求过来的时候，它必须要获得Vw个冗余拷贝的许可。而剩下的数量是V-Vw 不够Vr，因此不能再有读请求过来了。同理，当读请求已经获得了Vr个冗余拷贝的许可时，写请求就无法获得许可了。第二条规则保证了数据的串行化修改。一份数据的冗余拷贝不可能同时被两个写请求修改。</p>
<p>在区间 (V/2, V] 调整 Vw 的值可以改变写入操作的开销。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote>
<p>[1] <a href="https://hackernoon.com/a-thorough-introduction-to-distributed-systems-3b91562c9b3c" target="_blank" rel="noopener">https://hackernoon.com/a-thorough-introduction-to-distributed-systems-3b91562c9b3c</a><br>[2] <a href="https://www.dummies.com/programming/big-data/hadoop/acid-versus-base-data-stores/" target="_blank" rel="noopener">https://www.dummies.com/programming/big-data/hadoop/acid-versus-base-data-stores/</a><br>[3] <a href="https://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="noopener">https://queue.acm.org/detail.cfm?id=1394128</a><br>[4] <a href="https://www.johndcook.com/blog/2009/07/06/brewer-cap-theorem-base/" target="_blank" rel="noopener">https://www.johndcook.com/blog/2009/07/06/brewer-cap-theorem-base/</a><br>[5] <a href="https://zh.wikipedia.org/wiki/Quorum_(%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Quorum_(%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/10/21/rest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/21/rest/" itemprop="url">REST Introduction</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-21T17:26:00+08:00">
                2018-10-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/base/" itemprop="url" rel="index">
                    <span itemprop="name">base</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文翻译自 <a href="https://www.restapitutorial.com/" target="_blank" rel="noopener">https://www.restapitutorial.com/</a> ，继承协议 Creative Commons Attribution-ShareAlike 4.0 International License。转载请注明出处。</p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>与其他计算机技术一样，构建好一个 RESTful 服务也是科学与艺术的结合。互联网方兴未艾，如火如荼，采用业界最佳实践创建 REST API 变得越来越重要。由于 RESTful web 服务不遵循除 HTTP 以外的规定标准，因此根据行业最佳实践构建 RESTful API 以简化并提高客户端使用率变得非常重要。</p>
<p>目前没有很多可以帮助开发人员的 REST API 实践指南，RestApiTutorial.com 致力于专研 REST API 的最佳实践并且为开发人员提供资源，以便大家可以参考和自我学习。</p>
<h1 id="REST-简介"><a href="#REST-简介" class="headerlink" title="REST 简介"></a>REST 简介</h1><p>REST 架构包含 6 个约束，参见 <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="noopener">https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a> ：</p>
<ul>
<li><p>统一接口</p>
<p>统一接口用于简化和解耦客户端和服务端，以便于它们独立发展。统一接口设计的 4 个指导原则如下：</p>
<p><strong>基于资源</strong></p>
<p>请求中采用 URI 标识唯一资源。资源和返回给客户端的资源呈现是不同的，例如，服务器会将表示数据库记录的用UTF-8编码的 HTML，XML 或 JSON 数据发送给客户端，而不是将数据库返回给客户端。这里的 HTML，XML 或 JSON 等就是资源呈现，数据库真实的记录就是资源。</p>
<p><strong>通过资源呈现操作资源</strong></p>
<p>当客户端持有一个资源呈现及其附属的元数据时，它就应该具有足够多的信息在其权限允许的范围内增加、修改、删除服务器的资源。</p>
<p><strong>自描述消息</strong></p>
<p>每个消息需要包含如何处理它的足够信息，比如，采用 MIME 类型指定采用那个解析器处理消息，响应也需要明确指定它们的缓存能力。</p>
<p><strong>超媒体用作应用状态引擎（HATEOAS）</strong></p>
<p>客户端通过请求体、请求行、请求头传递状态到服务端，服务端通过响应体、响应码、响应头传递状态到客户端。这种方式称为超媒体。</p>
<p>除了上面的描述，HATEOAS 还意味着在必要的情况下，链接需要包含在返回的响应体重以便 URI 检索相关资源。</p>
<blockquote>
<p>统一接口是任何 REST 服务设计的基础</p>
</blockquote>
</li>
<li><p>无状态</p>
<p>REST 是 REpresentational <strong>State</strong> Transer （资源呈现状态迁移） 的简写，无状态是关键，也就是说处理当前请求所必需的状态就包含在该请求（无论是包含在 URI、查询参数、请求体、请求头）中，无需其它维系状态的手段。URI 唯一标识资源，请求体中包含资源的状态，服务器基于这两个信息处理完请求后通过响应头、响应体和状态码将结果状态返回给客户端。</p>
<p>有过工作经历的工程师都接触过 <strong>session</strong> 用于在服务器保存跨 HTTP 请求的业务状态，然而，在 REST 结构中，客户端需要维护所有的状态信息以便提供给服务器处理该请求，即便在该业务状态需要跨越多个 HTTP 请求的情况下，依旧需要客户端多次发送状态。无状态的条件下，服务器不用维系会话状态，使得服务器易于横向扩展。另外，无状态的使得服务器在设计负载均衡的时候无需考虑会话关系。</p>
<p>如何区分状态和资源？状态或应用状态是指服务器为了处理请求需要关注的信息，比如请求中携带的必要数据。资源或者资源状态是指资源呈现所指向的真正内容，比如数据库中的数据。每个客户端可以根据每次请求的需要更改应用状态，然而资源是在所有发起请求的客户端间是共享的常量。</p>
<p>是否遇到过由于 web 应用需要您按照既定顺序填写内容而您没有照做引起的服务失败？这正是因为它违背了无状态原则。然而某些场景确实无法做到无状态，比如 three-legged OAuth，API调用频率限制等，在这些场景下，您就需要尽可能保证服务一次性完成，避免服务跨越多个请求才能完成。</p>
</li>
</ul>
<ul>
<li><p>可缓存</p>
<p>和万维网一样，在 REST 架构中，客户端可以缓存响应，因此响应需要直接或间接的定义它们是否可以被缓存，以防止客户端在后续的请求中重用不恰当的数据。管理良好的缓存或多或少减少了客户端服务器的直接交互，更进一步提升了扩展性和性能。</p>
</li>
<li><p>C/S 模式</p>
<p>统一接口将客户端和服务器分开，这样的话，客户端无需考虑数据存储，交由服务器来完成，因此提升了客户端的可移植性；服务器不用考虑用户状态，因此提升了服务器的可扩展性和简单性。只要接口不发生变更，客户端和服务器可以独立开发和升级。</p>
</li>
<li><p>分层系统</p>
<p>客户端通常无法判断它是直连了终端服务器还是沿途的中间服务器，中间服务器可以通过启用负载均衡和共享缓存提供系统可伸缩性。分层机制也可以更加方面的实施安全保护措施。</p>
</li>
<li><p>Code on Demand(optional)</p>
<p>服务器可以通过传输客户端可以执行的逻辑扩展或定制客户端功能，比如包含客户端脚本（例如JS）和编译组件（例如 Java applets）。</p>
<p>符合 REST 风格，遵循上述约束可以带来诸如性能、可伸缩性、简单性、可修改性、可见性、可移植性和可靠性等诸多好处。</p>
<blockquote>
<p>注：Code on Demand 是唯一一个可选约束。如果违背了其他约束，那么该服务严格意义上并不是一个真正的 RESTful 服务。</p>
</blockquote>
</li>
</ul>
<h1 id="REST-API-小贴士"><a href="#REST-API-小贴士" class="headerlink" title="REST API 小贴士"></a>REST API 小贴士</h1><p>下面介绍 6 个 REST API 设计的小贴士，不管是不是严格的 RESTful 服务，这些小贴士都会帮助您设计出更好用的服务。</p>
<ul>
<li><p>合理运用 HTTP 中的动词<br>API 使用者可以发送 GET、POST、PUT 和 DELETE 这些动词给服务器，这极大地增强了请求的表达能力。主要的 HTTP 动词用法如下：</p>
<ul>
<li><strong>GET</strong><br><strong>查</strong>：读取（查询）某个指定资源或某个指定资源的集合。</li>
<li><strong>PUT</strong><br><strong>改</strong>：修改某个指定资源或某个自定资源的集合。如果预先知道资源标识符，PUT 也可以用于创建特定资源。</li>
<li><strong>DELETE</strong></li>
<li><strong>删</strong>：删除指定资源</li>
<li><strong>POST</strong><br><strong>增</strong>：创建一个新资源。对于不适合上述三类的操作，POST 是一个万金油动词。</li>
</ul>
</li>
<li><p>提供合理的资源名称<br>创建一个优秀的 API 来自于 80% 的艺术和 20% 的科学。采用层级性的 URL 用以合理表示资源是 API 设计的艺术部分。一个合理的资源名称（URL 路径，比如 /customers/12345/orders）有助于更加清晰的表达请求的内容。<br>合理的资源名称可以为服务请求提供上下文，使得 API 更易理解。URI 的层次性为 API 使用者提供友好的易于理解的资源层次结构，利于 API 在应用程序中使用。<br>下面是几个快速设计 URL （资源名称）的规则：</p>
<ul>
<li><strong>URL 中采用标识符代替查询字符串</strong>。查询字符串参数适合过滤但不适合用作资源名称。<br>好： /users/12345<br>差： /api?type=user&amp;id=23</li>
<li><strong>采用 URL 的分层特性来表示资源结构</strong>。</li>
<li><strong>面向用户设计资源名称，而非面向数据</strong>。</li>
<li><strong>资源名称采用名词命名，用 HTTP 方法指定动作</strong>。</li>
<li><strong>在 URL 的分层中，采用复数命名形式</strong>。使用复数可以使得 URL 在跨 HTTP 的方法保持一致。<br>好： /customers/33245/orders/8769/lineitems/1<br>坏： /customer/33245/order/8769/lineitem/1</li>
<li><strong>避免冗余的表示集合的命名方式</strong>。比如， customer_list 可以采用复数形式替换， customers。</li>
<li><strong>在 URL 分层中采用小写形式，使用下划线或连字符分隔单词</strong>。有些服务器大小写不敏感，因此最好保持一致性。</li>
<li><strong>在清楚表明语义的情况下，保持 URL 短小精悍</strong>。</li>
</ul>
</li>
</ul>
<ul>
<li><p>采用 HTTP 响应码表明处理状态</p>
<p>响应状态码是 HTTP 协议的一部分，它们涵盖了绝大部分常见的场景。由于 RESTful 也遵循 HTTP 规范，所以我们设计的 API 也应该返回相关的 HTTP 状态码。比如，在成功创建资源（比如来自 POST 请求）以后，API 应该返回 HTTP 状态码 201。下面是 TOP 10 常用的 HTTP 状态码列表:</p>
<p><strong>200 OK</strong><br>普通成功状态码，用于表示成功。<br><strong>201 CREATED</strong><br>资源创建成功（通过 POST 或 PUT）。将响应头中的 Location 字段设置为标识新资源的连接，响应体可有可无。<br><strong>204 NO CONTENT</strong><br>成功，但响应正文中没有任何内容，通常用于 DELETE 和 PUT 操作。<br><strong>400 BAD REQUEST</strong><br>处理请求时出现不合法的状态时的一般错误码。比如，数据格式错误、域名解析错误等。<br><strong>401 UNAUTHORIZED</strong><br>未携带或携带了错误的鉴权 token 时的错误码。<br><strong>403 FORBIDDEN</strong><br>用户没有认证权限执行该操作，或者资源不能被访问时的错误码。<br><strong>404 NOT FOUND</strong><br>找不到指定的资源时的错误码。不管是真的不存在或者存在 401 或 403，服务出于安全方面的考虑需要屏蔽。<br><strong>405 METHOD NOT ALLOWED</strong><br>请求的 URL 存在但不支持请求中的 HTTP 方法访问。比如 POST /users/12345，API 若不支持使用 POST 方法，返回 405 是必须设置 Allow 字段，诸如 GET, PUT, DELETE。<br><strong>409 CONFLICT</strong><br>执行请求时出现资源冲突。比如尝试创建相同信息的两个用户，或者不支持级联删除时删除根对象。<br><strong>500 INTERNAL SERVER ERROR</strong><br>不要故意返回 500 错误。服务端出现问题时会抛 500 错误，这种错误客户端无法解决。</p>
</li>
<li><p>同时支持 JSON 和 XML（JSON 大行其道，这个有待考量）</p>
<p>在不是很复杂的情况下，尽可能同时提供对 JSON 和 XML 的支持。理想情况下，让客户端采用 Accpet 字段指定格式，或者将 URL 上的 .xml 换成 .json 即可。<br>虽然我们建议支持 XML，但是除非必须，请尽量保持 XML 和 JSON 一样的简单实用。也就是说，XML 中也不支持架构和命名空间这些细节，只有数据和连接。如果完整支持 XML，其代价往往是高昂的。根据我们的实战经验，过去几年几乎没有使用过 XML 响应了，对于服务和客户端来讲都显得过于重了。<br>如果非要支持类似命名空间这些功能，JSON-Schema也是可以提供的。</p>
</li>
<li><p>创建细粒度资源<br>在最开始最好依托于底层应用程序和数据库的API来创建具有 CRUD 功能的资源，然后再利用小的资源构建更大的资源。</p>
</li>
<li>考虑连通性<br>通过超链接实现连通性是 REST 的一个重要原则。虽然不具备连通性的时候，服务依然是可用的，但是如果在响应中带有连接，那么 API 变得更具有自我描述性。至少我们可以通过链接通知客户端如何检索数据，还有，利用 HTTP Location 头域返回客户端通过 POST （或 PUT）创建的资源的连接。在支持分页响应时，”first”，”last”，”next”和”prev”非常有用。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/10/01/lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/01/lock/" itemprop="url">同步与互斥</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-01T09:15:00+08:00">
                2018-10-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/base/" itemprop="url" rel="index">
                    <span itemprop="name">base</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>随着计算机科学和实践的发展，多线程、多进程编程早已是后台工程师（无论框架还是服务器或是业务）需要熟知的重要基础知识之一。这个技术帮助工程师最大限度的利用冯诺依曼型计算机的资源，然而该技术在给资本家节约成本（当然也会提升人民生活的便利）的同时，提升了工程师编码的复杂度。</p>
</blockquote>
<p><strong>摘要</strong> 本文着重讨论多线程、多进程编程中的同步与互斥。<strong>名词解释</strong>部分对本文涉及到的重要名词进行说明，<strong>问题研讨</strong>部分对同步与互斥这一经典问题进行描述。</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><p><strong>定义</strong></p>
<p>计算机中的资源指的是操作系统管理的抽象资源。比如：内存、IO、CPU、锁等。</p>
</li>
</ul>
<h2 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h2><ul>
<li><p><strong>定义</strong></p>
<p>多道程序（多进程、多线程）系统中，一次只允许一道程序（一个线程、一个进程）使用的资源，称为<strong>临界资源</strong>。</p>
</li>
<li><p><strong>调皮一下</strong></p>
<p>现在假设厕所只有一个坑，小 A 占用的时候，小 B 只能等；小 B 占用的时候，小 A 只能等。厕所的坑是一个解决问题的重要资源，然而却不能被小 A 和小 B 同时使用，那么这个坑就是<strong>临界资源</strong>。</p>
<blockquote>
<p><strong>想法</strong>：计算机科学衍生自人类本身的经验科学和数学科学，因此有很多名词和编码理念取材于日常生活。而且计算机科学又非常高效地反馈了人类，取材于日常生活的理念，快速应用到解决日常问题。</p>
</blockquote>
</li>
</ul>
<h2 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h2><ul>
<li><strong>定义</strong><br>操作系统（Operation System）是计算机的管家，管理着这台计算机的全部资源。应用程序在运行过程中需要的资源均需向 OS 申请并且及时归还。多道程序申请一个临界资源的情况，称为<strong>竞争</strong>。</li>
</ul>
<h2 id="独立进程（或线程）"><a href="#独立进程（或线程）" class="headerlink" title="独立进程（或线程）"></a>独立进程（或线程）</h2><ul>
<li><strong>定义</strong><br>自身状态与其他进程（或线程）无关并且其他进程不会影响自身状态的进程（或线程），称为<strong>独立进程（或线程）</strong>。</li>
</ul>
<h2 id="合作进程（或线程）"><a href="#合作进程（或线程）" class="headerlink" title="合作进程（或线程）"></a>合作进程（或线程）</h2><ul>
<li><strong>定义</strong><br>进程执行过程中影响其他进程（或线程）状态或被其他进程（或线程）影响自身状态，称为<strong>合作进程（或线程）</strong>。</li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><ul>
<li><strong>定义</strong><br>在多道系统中，合作进程（或线程）按照某种事先规定的序列完成任务的过程称为<strong>同步</strong>。</li>
</ul>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><ul>
<li><p><strong>定义</strong><br>在多道系统中，合作进程（或线程）对临界资源的排他访问，称为<strong>互斥</strong>。</p>
</li>
<li><p><strong>调皮一下</strong><br>小 A 和小 B 属于合作进程。他们需要按照既定的顺序解决问题：小 A 先上或者小 B 先上。小 A 先上的话，小 B 只能等待小 A 出来，小 B 遵守了厕所坑互斥的约定，按照次序解决问题，这就是同步。</p>
</li>
</ul>
<blockquote>
<p><strong>想法</strong>，同步与互斥是两个非常独立的概念，然而却经常理解混乱。其一，多道程序为了完成同步需要一些互斥手段。其二，自然语言解释抽象概念本身就捉襟见肘。</p>
</blockquote>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul>
<li><strong>定义</strong><br>一种由资源管理者提供的资源，用于正确地访问临界资源。</li>
</ul>
<h1 id="问题研讨"><a href="#问题研讨" class="headerlink" title="问题研讨"></a>问题研讨</h1><p>由于互斥是同步的一个重要手段，我们从互斥入手去展开这一主题的介绍。锁在为多道程序正确地访问临界资源提供支持的同时，也加大了编写正确多道程序的难度。</p>
<h2 id="多道程序的活跃性问题"><a href="#多道程序的活跃性问题" class="headerlink" title="多道程序的活跃性问题"></a>多道程序的活跃性问题</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><p><strong>定义</strong><br>集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。死锁会进一步引起服务挂起，无法正常处理业务。</p>
</li>
<li><p><strong>调皮一下</strong><br>教科书爱用哲学家用餐问题引入介绍死锁，然而作为市井打工仔，我没见过科学家，因此这里换个日常生活中常见的死锁。一次下班回家，在一个交通转盘上就发生了严重的交通死锁，看到一辆救护车的悲鸣，心里很是触动。死锁如下：</p>
<img src="/2018/10/01/lock/Deadlock.jpg">
</li>
<li><p><strong>死锁产生</strong><br>从上面的例子我们可以看到死锁产生需要4个必要条件：</p>
<ol>
<li><strong>互斥</strong>：进程对临界资源排他性占用，若进程 P1 持有临界资源，则进程 P2 请求临界资源时需要等待，直到 P1 释放该资源，P2 才能获取。上图中，路口就是临界资源，同时只能由1辆车通过。</li>
<li><strong>请求和占有</strong>：进程 P1 在请求资源 R1 的同时还独占资源 R2，进程 P2 在请求资源 R2 的同时还独占资源 R1。上图中，每个方向的车队都是在请求自己的通行路口，同时还独占另外一个车队的通行路口。</li>
<li><strong>不可抢占</strong>：进程 P1 获得的资源 R1 在未自己释放之前不可由进程 P2 抢夺。每个车队都没有执法权可以让另一个车队让出一个路口。</li>
<li><strong>循环等待</strong>：进程资源环形链路。车队和路口出现了一个环形。</li>
</ol>
<p>上述四个条件为死锁产生的必要不充分条件：即死锁 -&gt; 互斥，死锁 -&gt; 请求和保持，死锁 -&gt; 请求和占有，死锁 -&gt; 循环等待，反过来则不成立。</p>
</li>
<li><p><strong>问题解决方案</strong></p>
<p>科学家给出了科学结论和理论上可行的方案：</p>
<ol>
<li><strong>死锁预防</strong><br>破坏死锁产生的4个必要条件之一，则就不会发生死锁。<strong>有序资源分配法</strong>是非常典型的一种死锁预防算法，它破坏了<strong>循环等待</strong>条件。<br><strong>有序资源分配算法</strong>即进程在获取多个资源的时候需要事先规定好的顺序获取，比如进程 P1 和 P2 需要资源 R1 R2 完成工作，如果 P1 占有 R1 申请 R2，P2 占有 R2 申请 R1 就会出现死锁。若我们事先规定进程获取资源的顺序为 R1 R2，那么进程 P2 在申请 R2 之前需先申请 R1，若 R1 申请不到则其无法持有 R2。因此不会产生死锁。</li>
<li><strong>死锁避免</strong><br>系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的<strong>动态策略</strong>。<strong>银行家算法</strong>是典型的死锁避免算法。<br><strong>银行家算法</strong>比较复杂，很难三言两语解释清楚，请见。由于申请资源者并非一次性将自己所需的最大资源数全部从银行家手里获取，因此会有虽然银行家手里有资源，但是并不能向外分配的情况。此时需要检测是否存在进程安全序列。</li>
<li><strong>死锁检测</strong><br>允许死锁发生，然后检测到进程发生死锁，再去干预。在交通图中，检测到死锁，右下角的警车到达，经过疏导完成了解锁。检测策略实现起来比较有难度。</li>
</ol>
<blockquote>
<p><strong>想法</strong>在日常业务开发中，通过业务拆分，通常多个进程竞争一个临界资源，不会出现多个临界资源，因此直接不满足死锁必要条件的<strong>请求和占有</strong>。如果真遇到多个临界资源的竞争，则需要引入<strong>有序资源分配法</strong>（由于资源有序，导致业务上的串行，影响性能），<strong>银行家算法</strong>（动态分配资源，实现略显复杂，提高并发性）。</p>
</blockquote>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3></li>
<li><p><strong>定义</strong></p>
<p>进程的等待时间给进程的响应时间带来明显影响，称为<strong>进程饥饿</strong>。若一直等待到即使完成该任务也毫无意义的时候，则称为<strong>饥饿死亡</strong>。</p>
</li>
<li><p><strong>调度算法</strong><br>进程和线程调度均由 OS 来完成，但业务相关任务调度则由工程师控制，因此调度算法也是工程师需要掌握的技术手段。下面介绍 6 种典型的进程调度算法（当然可以应用到任务调度当中），它们均是抢占式、非抢占式调度算法：</p>
<ol>
<li><strong>FCFS (First Come First Serve) 先来先服务</strong><ul>
<li>任务按照先来先服务原则执行（俗话所说的按照先来后到）</li>
<li>基于 FIFO 队列，实现简单</li>
<li>平均等待时长较长（老师常说的，你耽误课堂一分钟，整个教室 60 个人，你就耽误了 60 分钟）</li>
</ul>
</li>
<li><strong>SJN (Short Job Next) 短作业优先</strong><ul>
<li>任务按照短作业优先原则执行</li>
<li>平均等待时长最短（可以证明）</li>
<li>适合预先知道处理时长的批处理系统，不适合预先不知道处理时长的交互式系统</li>
<li>系统需要实现知道处理时长</li>
</ul>
</li>
<li><strong>Priority Scheduling 优先级调度</strong><ul>
<li>批处理系统中的常用调度算法</li>
<li>按照任务优先级处理，同一优先级按照 FCFS 处理</li>
</ul>
</li>
<li><strong>Shortest Remaining Time 最少剩余时间</strong></li>
<li><strong>Round Robin(RR) Scheduling 轮询调度</strong><ul>
<li>每个任务获取一个固定的执行时间，时间到则切换下一个任务</li>
</ul>
</li>
<li><strong>Multiple-Level Queue Scheduling 多级队列调度</strong></li>
</ol>
</li>
</ul>
<p>调度也是一个研究方向，值得庆幸的是科学家已经提供了很多行之有效的经典方案。Quartz 就是一个分布式调度框架，最近也用到了我们的项目中。</p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><ul>
<li><p><strong>定义</strong></p>
<p>活锁指的是任务或者执行者没有被阻塞，只是由于某种原因导致执行者一直重复尝试-失败，尝试-失败。</p>
</li>
<li><p><strong>实例</strong><br>活锁会导致虽然线程没有阻塞，但却什么都完成不了。比如执行任务的过程中，若遇到失败任务则重试，那么就有可能一直重试下去。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>锁是实现互斥的一种手段；互斥是程序执行过程中对临界资源访问的一种保证正确性的手段；同步需要 A 等待 B 完成才能继续执行，A 得知 B 已经完成的手段的一种方式就是访问一个临界资源。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/09/28/curator lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/28/curator lock/" itemprop="url">curator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-28T09:15:00+08:00">
                2018-09-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Zookeeper/" itemprop="url" rel="index">
                    <span itemprop="name">Zookeeper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Curator"><a href="#Curator" class="headerlink" title="Curator"></a>Curator</h1><p>Apache Curator 是 Apache Zookeeper 的一个客户端库。它封装了底层 Apache Zookeeper 客户端 API，为用户提供了更加简便可靠的高级 API 和一些常用工具。 除此之外，它还提供了常见场景的实现（比如选主、分布式锁等）以及一些扩展（比如服务发现）。</p>
<p>curator-recipes 为我们提供了几种常用场景的解决方案和实现，本文着重介绍这些工具的用法以及实现原理。</p>
<h1 id="Elections-选主"><a href="#Elections-选主" class="headerlink" title="Elections (选主)"></a>Elections (选主)</h1><p>日常生活中，一个稍微繁杂一些的工作，通常需要多人协作，多人协作时通常存在一个 leader 负责根据每个人的状况分发任务；那么就需要大家推举出一个让人信服的 leader，不能搞小团体，这样才能高效完成任务。在分布式系统中，通常也需要推举出一个 leader 完成整个系统的协同。</p>
<blockquote>
<p>选主（leader election）是指分布式系统中各个节点推举出一个节点作为整个系统的组织者，进而协同各个节点的状态，协调分布式任务。</p>
</blockquote>
<h2 id="应用场景举例"><a href="#应用场景举例" class="headerlink" title="应用场景举例"></a>应用场景举例</h2><ol>
<li>监控</li>
</ol>
<p>因为 leader 节点需要协同整个系统，所以及时获取系统中各个 non-leader 节点的状态是很重要的。因此 leader 节点会监控整个系统节点的状态。<br>比如在一个分布式计算系统中，调度模块将任务下发给 leader 节点，leader 节点在分发任务的时候，首先要确保 non-leader 计算节点的状态正常，才会下发计算任务；否则，就会引起数据丢失，计算失败。</p>
<ol>
<li>调度</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/08/05/question ananlysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/05/question ananlysis/" itemprop="url">记几次有意思的问题诊断</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-05T14:38:00+08:00">
                2018-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/诊断/" itemprop="url" rel="index">
                    <span itemprop="name">诊断</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h1><p>服务端出现 CLOSE_WAIT 状态，必然是某些原因导致服务端 socket 未关闭， FIN 包未发送到客户端，所以一直处于 CLOSE_WAIT 状态。打印 jstack 发现有大量的相同堆栈，均由同步 RPC 调用未能及时返回引起。</p>
<h1 id="Jedis连接到slave服务器"><a href="#Jedis连接到slave服务器" class="headerlink" title="Jedis连接到slave服务器"></a>Jedis连接到slave服务器</h1><p>服务端采用哨兵+主备方案部署，客户端采用 Jedis 连接。测试反应数据无法写入 redis，一直打印 READONLY异常。登录 redis，info 查看连接节点角色为 slave。因此怀疑主备切换之后 Jedis 客户端未能感知到。通过 Jedis 源代码得知 redis 主备切换后哨兵会将主备切换的信息 pub 到 +switch-master 这个主题， Jedis 客户端订阅该主题，在获取到主备切换信息之后关闭当前所有 Jedis 连接，跟新的主节点建立连接。由于测试服务端环境只有一个哨兵，并且 redis 的 pub/sub 模式是发布后需要直接消费，否则就会丢失，造就了 Jedis 客户端未能发现主备切换，引起客户端连接在了从节点。</p>
<h1 id="kafka无业务状态下流量和CPU较高"><a href="#kafka无业务状态下流量和CPU较高" class="headerlink" title="kafka无业务状态下流量和CPU较高"></a>kafka无业务状态下流量和CPU较高</h1><p>现网和测试反应 kafka 在基本没有业务的情况下，网络带宽竟然占用到了 5Mbits/s。问题反馈上来颇感棘手，原因是 kafka 采用 erlang 开发，而我只对 c/c++/Java 有所了解。既然无法直接阅读 kafka 代码，那就从外围分析。首先抓包，查看到的内容都是一些 topic 的名称，然而从我们的常识判断 kafka 这么成熟的商用消息队列不至于出现自身同步都引起巨大流量的问题。采用工具查看流量都从 kafka 不同节点同步消息互相流动。offset 的同步是采用的自动提交方式，每次提交都会触发 offset 同步。排查后发现 offset 的自动提交时间为 100ms，因此引起多个客户端每秒触发 10 次 offset 同步。将 offset 修改为 5000 ms 之后流量和 CPU 都降下来了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wzlovegit.github.io/2018/07/25/Spring State Machine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王哲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/25/Spring State Machine/" itemprop="url">简单聊聊Spring State Machine</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-25T21:00:00+08:00">
                2018-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h1><p>FSM (Finite State Machine) 有限状态机。学术上 FSM 分为两种类型： Mealy 状态机和 Moore 状态机。</p>
<ul>
<li>Mealy 状态机</li>
</ul>
<p>output = f ( present_state, input )<br>next_state = f ( present_state, input)</p>
<ul>
<li>Moore 状态机</li>
</ul>
<p>output = f ( present_state )<br>next_state = f ( present_state, input )</p>
<p>参见：</p>
<p><a href="https://www.tutorialspoint.com/automata_theory/moore_and_mealy_machines.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/automata_theory/moore_and_mealy_machines.htm</a></p>
<h1 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h1>
<p>Spring State Machine 是事件驱动的，事件可以是定时器事件或者普通事件。上图中，比如状态机目前处于 S1 状态，收到 E1 事件后就切换到 S2 状态；状态机目前处于 S2 状态， 收到 E2 事件后切换到 S3 状态。那么 Spring 状态机是怎么使用计算资源的呢？</p>
<img src="/2018/07/25/Spring%20State%20Machine/springsm.jpg" title="This is an example image">
<p>每个状态机都有一个接收事件的事件队列，每次每个事件触发都会将 Runnable 任务提交到线程池的任务队列。线程从线程池中提取 Runnable 任务，然后执行事件队列中的全部事件。在任务执行的过程中，会首先加锁，不让多个线程同时处理一个事件队列以免引起线程安全问题。</p>
<h1 id="分布式协作状态机"><a href="#分布式协作状态机" class="headerlink" title="分布式协作状态机"></a>分布式协作状态机</h1><p>Distribute state machine 是借助 Zookeeper 实现的。每次状态发生变化，Spring State Machine 会将状态持久化到 Zookeeper 中，并以 log 的形式记录到 Zookeeper。 由于另一个 State Machine Watch 了 Zookeeper 上 log 的变化，因此它会在 log 发生变化的时候重放 log，以完成两个 State Machine 的同步。这里需要注意，如果状态机中定义的 Action 中存在变量自加的情况，那么重放 log 会导致 Action 中的操作执行多遍，因此我们在设计的时候通常不能在 Action 中执行操作。</p>
<h1 id="状态机实例化"><a href="#状态机实例化" class="headerlink" title="状态机实例化"></a>状态机实例化</h1><p>初次使用 Spring State Machine，从其 Demo 中只能看到每次启动 Spring 服务只能配置一个 Spring State Machine 实例。这种情况通常不符合我们的业务流程，因为我们会有多个相同的业务同时执行。当然，这不能困住我们啦，把 Spring State Machine 的源代码下下来，就能看到 Builder 模式的创建状态机的方法。</p>
<h1 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h1><p>经验教训是这将近一月的需求分析、概要设计、详细设计、代码开发到自测阶段不断思考的一些内容。由于并非理论知识，不具备普适性，不具备科学性，所以放在了行文的最后，不妨碍阅读 Spring State Machine 本身的内容。</p>
<h2 id="如何进行设计？"><a href="#如何进行设计？" class="headerlink" title="如何进行设计？"></a>如何进行设计？</h2><p>设计阶段我们分别进行了业务细节设计、研究 Spring State Machine 的设计、 定时器框架 Quarz 的设计。设计阶段没有达到预期的原因，我认为有以下几个点需要自己以后注意：</p>
<ol>
<li>设计仓促</li>
</ol>
<p>需求分析和可行性分析是最不能节省时间的。这里的仓促需要我花更多的时间和更多的精力买单。时间紧张是一个比较客观的原因。</p>
<ol>
<li>缺少沟通</li>
</ol>
<p>骨子里认为开会是个浪费时间的动作，但设计阶段的会议必不可少，一天一次或者一天两次都不为过。沟通的过程是需要和大家不断澄清方案合理性的过程，而且不间断的沟通可以激起负责人的主人翁精神，调动起大家的积极性是愉快工作必不可少的环节。</p>
<ol>
<li>缺少信任</li>
</ol>
<p>事必躬亲是非常错误的，是一种事倍功半的做法。首先一个人精力有限，其次一个人必有局限。充分信任同事，不断沟通结果才是提高生产力的法则。比如，如果不信任 Spring 的代码质量，那么项目从 0 开始，将是非常巨大的成本。信任同事，一起查看设计和开发结果，对不合理的地方不断完善，既可以减轻事必躬亲带来的压力和巨大工作量，又可以让大家都有主人翁精神。</p>
<h2 id="如何分工合作？"><a href="#如何分工合作？" class="headerlink" title="如何分工合作？"></a>如何分工合作？</h2><p>需求一下来，我立马拉上组内相关同事进行了一个针对性的拆解分工。因为每个人技术背景不同，所以起初我的想法是每两个同事关注一个重要的点，每个同事关注两个重要的点，即下图的形式：</p>
<img src="/2018/07/25/Spring%20State%20Machine/project_teamwork.jpg" title="This is an example image">
<p>此时大家可以分工调研各自重点关注和辅助关注的模块了。分工上基本是合理的。就是缺少了沟通。沟通是分工合作非常需要关注的一个点。下次牵头做设计，必然要每天沟通，记录进度和结果。</p>
<h2 id="如何保证质量？"><a href="#如何保证质量？" class="headerlink" title="如何保证质量？"></a>如何保证质量？</h2><p>把信任给了同事，那么质量如何保证。这就又体现了沟通的重要性。不是大家能力问题，而是不同技术背景，开发习惯等会引起一些低级问题。开会 review 是提升大家编码水平的一个重要渠道。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王哲</p>
              <p class="site-description motion-element" itemprop="description">分享 交流</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">Kategorien</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/rss2.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王哲</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
