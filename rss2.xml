<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Light</title>
    <link>http://wzlovegit.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>分享 交流</description>
    <pubDate>Mon, 18 Feb 2019 11:19:01 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>服务保活</title>
      <link>http://wzlovegit.github.io/2019/02/18/server%20keepalive/</link>
      <guid>http://wzlovegit.github.io/2019/02/18/server%20keepalive/</guid>
      <pubDate>Mon, 18 Feb 2019 10:43:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;服务保活是微服务治理的基本要求，服务注册、服务摘除的自动化都离不开服务保活。那么如何去保活服务呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大部分软件工程师是做业务的，但是业务是繁荣的，Not only web！我们通常会依赖相关领域中重要的三方服务，比如通信领域的 Fre
        
      
      </description>
      
      <content:encoded><![CDATA[<p>服务保活是微服务治理的基本要求，服务注册、服务摘除的自动化都离不开服务保活。那么如何去保活服务呢？</p><blockquote><p>大部分软件工程师是做业务的，但是业务是繁荣的，Not only web！我们通常会依赖相关领域中重要的三方服务，比如通信领域的 FreeSwitch。FreeSwitch 并没有原生的集群能力，比如选主、failover等。针对这一类服务，我们需要了解如何保活服务。</p></blockquote><h1 id="续约-VS-探测"><a href="#续约-VS-探测" class="headerlink" title="续约 VS 探测"></a>续约 VS 探测</h1><p>续约是将注册中心作为服务，三方服务作为客户端，周期性向注册中心上报自身状态，一旦注册中心连续多次无法获取三方服务的续约请求，则认为三方服务出现故障。如下图所示：</p><img src="/2019/02/18/server%20keepalive/renew.png"><p>探测是将注册中心作为客户端，三方服务作为服务，注册中心周期性发送 PING 等待三方服务返回 PONG，一旦注册中心连续多次无法获取三方服务的 PONG 回应，则认为三方服务出现故障。如下图所示：</p><img src="/2019/02/18/server%20keepalive/probe.png"><p>这两种方式选择任意一种均可以满足要求。</p><h1 id="连接-VS-服务"><a href="#连接-VS-服务" class="headerlink" title="连接 VS 服务"></a>连接 VS 服务</h1><p>接触过连接池的工程师都知道连接池中的连接通常也需要保活，也会采用 PING / PONG 方式，比如 Jedis。但本人认为连接的保活和服务的保活是两个不同层次的内容，一个连接的丢失并不能象征服务故障。</p><p>连接的保活，是确保在连接上可以传递信息。服务的保活，是确保服务可用。服务的保活 PING/PONG 可以通过任一连接发送，只要成功即可认为服务可用。</p><img src="/2019/02/18/server%20keepalive/server.png"><p>结论：连接的保活放到底层连接实现。服务的保活放到服务定时任务中采用 PING/PONG 实现。</p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2019/02/18/server%20keepalive/#disqus_thread</comments>
    </item>
    
    <item>
      <title>pool 池化技术</title>
      <link>http://wzlovegit.github.io/2019/02/15/pool/</link>
      <guid>http://wzlovegit.github.io/2019/02/15/pool/</guid>
      <pubDate>Fri, 15 Feb 2019 14:43:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;近期在优化 FreeSwitch ESL 客户端相关的业务实现的过程中，对 ESL 提供的 Client 进行了封装，设计并开发了 FreeSwitch 连接池，命名为 JreeSwitch（学习 Jedis 命名方式）。本文围绕如何设计池和如何使用池展开讨论，对池化技术的
        
      
      </description>
      
      <content:encoded><![CDATA[<p>近期在优化 FreeSwitch ESL 客户端相关的业务实现的过程中，对 ESL 提供的 Client 进行了封装，设计并开发了 FreeSwitch 连接池，命名为 JreeSwitch（学习 Jedis 命名方式）。本文围绕如何设计池和如何使用池展开讨论，对池化技术的精髓进行介绍。</p><h1 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h1><p>对象池是统一管理多个对象生命周期的一种技术。对象池最大的优点是<strong>省去频繁创建和销毁对象的性能损耗</strong>，其次可以<strong>将对象生命周期的管理复杂度集中管理，减少开发和运维难度</strong>。</p><blockquote><p>小贴士： 池化技术在现实生活当中随处可见，即共享技术。例如共享单车属于单车资源池化，高铁属于交通资源池化，我们不创建共享单车和高铁，但是我们可以方便得使用它们。</p></blockquote><h1 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h1><p>正是由于对象池的这些优点，使得我们经常见到线程池、连接池等名词。既然对象池如此优秀，为什么不讲所有的对象都放到对象池呢？我总结出如下用法：</p><ul><li>对象一次创建和销毁的开销相对业务本身较大，通常涉及内核资源的调度（系统 API 调用），比如连接、线程、内存等</li><li>对象可以复用，并非临时性对象，比如连接创建之后，在连接上发送命令即可，无需频繁建链。</li></ul><h1 id="对象池设计"><a href="#对象池设计" class="headerlink" title="对象池设计"></a>对象池设计</h1><blockquote><p>参照 GenericObjectPool 进行讲解</p></blockquote><p>我们在使用对象池时是不关注对象何时创建的，用完对象之后，同样也不关注对象何时被销毁，那么对于一个用于租赁对象的对象池来讲，它需要具备以下几个核心能力。</p><ul><li>borrowObject : 对象池出租对象给用户</li><li>returnObject : 用户归还对象给对象池</li><li>检查对象状态 : 出租前、归还后检查</li><li>对象池检查 : 定时检查，根据对象状态和对象池状态决定是否回收或创建连接</li><li>动态扩容缩容 : 根据对象池状态，动态扩充新对象或销毁对象</li></ul><h2 id="GenericObject"><a href="#GenericObject" class="headerlink" title="GenericObject"></a>GenericObject</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenericObjectPool(PooledObjectFactory&lt;T&gt; factory, GenericObjectPoolConfig&lt;T&gt; config)</span><br></pre></td></tr></table></figure><p>入参为 PooledObjectFactory 和 GenericObjectPoolConfig。其中 PooledObjectFactory 用于提供对象的创建、激活、去激活、销毁等方法给 GenericObjectPool 管理对象生命周期时使用。GenericObjectPoolConfig 用于完成对象池的配置，比如最小空闲对象数等。</p><h2 id="PooledObjectFactory"><a href="#PooledObjectFactory" class="headerlink" title="PooledObjectFactory"></a>PooledObjectFactory</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface PooledObjectFactory&lt;T&gt;</span><br></pre></td></tr></table></figure><ul><li><p>makeObject()<br>创建对象实例。 当我们调用对象池的 borrowObject 方法获取对象时，在规则满足的情况下（比如池中无空闲对象并且没有到达最大对象数），那么对象池会调用该方法生成一个新的对象放入对象池。</p></li><li><p>activateObject(org.apache.commons.pool2.PooledObject) 激活对象实例。当我们从对象池中 borrowObject 的时，会执行该方法先激活对象再返回给用户使用。</p></li><li><p>validateObject(org.apache.commons.pool2.PooledObject) 判断对象合法性。在对象池返回某个对象或者将对象归还到对象池中的时，若满足配置规则，则会调用该方法判断对象是否可用。</p></li><li><p>passivateObject(org.apache.commons.pool2.PooledObject) 去激活对象实例。当我们 returnObject 给对象池时，会调用该方法去激活对象。</p></li><li>destroyObject(org.apache.commons.pool2.PooledObject) 销毁对象。当定时检查对象状态和对象池状态时，若满足规则，则销毁一部分对象。</li></ul><h2 id="GenericObjectPoolConfig"><a href="#GenericObjectPoolConfig" class="headerlink" title="GenericObjectPoolConfig"></a>GenericObjectPoolConfig</h2><p>管理对象池的最大个数，最大空闲对象个数和最少空闲个数。</p><h1 id="快速实现"><a href="#快速实现" class="headerlink" title="快速实现"></a>快速实现</h1><p>在 GenericObjectPool 的基础上，我们可以快速完成对象池化。</p><ul><li>实现 PooledObjectFactory ：提供对象的创建、激活、去激活、销毁等方法。</li><li>创建 GenericObjectPool ： 完成对象池生命周期管理（当然可以通过 GenericObjectPoolConfig 设置对象池的大小）。</li></ul><p>使用者在使用时无需关注何时创建、何时销毁等操作就可以复用以前的对象，非常方便。</p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2019/02/15/pool/#disqus_thread</comments>
    </item>
    
    <item>
      <title>小结</title>
      <link>http://wzlovegit.github.io/2019/01/27/2018/</link>
      <guid>http://wzlovegit.github.io/2019/01/27/2018/</guid>
      <pubDate>Sun, 27 Jan 2019 05:17:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;入职公司已经 1 年有余，收入不高，待遇一般，产品前景也让人有些担忧，但总体来讲自己还是得到很多锻炼，现在从多个角度小结一下今年的工作状态。&lt;/p&gt;
&lt;h1 id=&quot;工作任务和挑战&quot;&gt;&lt;a href=&quot;#工作任务和挑战&quot; class=&quot;headerlink&quot; title=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>入职公司已经 1 年有余，收入不高，待遇一般，产品前景也让人有些担忧，但总体来讲自己还是得到很多锻炼，现在从多个角度小结一下今年的工作状态。</p><h1 id="工作任务和挑战"><a href="#工作任务和挑战" class="headerlink" title="工作任务和挑战"></a>工作任务和挑战</h1><p>7 月份离开华为，究其原因是我没有感觉到技术上哪怕一丝的提升，而且工作过程中极端的压迫和疲惫。这一段时间自己在读研期间的好习惯几乎全部打破，随之而来的是远离已久的坏习惯，整个人被紧张和欲望控制的死死的。</p><p>11 月份入职优克云联，得益于项目起步、同事交流和个人时间的允许，才体会到自身技术能力在不断进步，并且不断扩张。由于入职较早，所以比后进来的同事更加熟悉产品和业务流，因此在今年的后半年开始发力做一些难度较大的工作。</p><p>第一份具有挑战性的工作是跟踪系统。前期设计没有考虑此功能，没有预先埋点，没有统一规范，团队对运维性质的工作内容积极性不高，加上自己第一次去推动涉及几乎全部模块的业务，没有经验，跟踪系统在预研一段时间后，被紧急需求挂起。后期虽然启动了一个版本，但远没有 ELK 平台方便，因此此次探索算是失败的。</p><p>失败中了解到：1. 全链路追踪关注调用链，并非关注业务本身，比如 sleuth + zipkin，可以清晰地看出 A 服务调用 B 服务，执行了多长时间等。对于异步的场景，由于 Runnable 和 Callable 均为 JDK 原生的，因此无法提供传递 SPAN 的埋点，全链路中无法体现。 2. ELK 平台在业务日志分析上很强大，几乎不需要新建跟踪系统，因为 ELK 可以更加全面的给开发人员提供定位问题所需要的信息，而且还可以做一些简单的可视化统计类指标，添加告警，所以起初我们做跟踪系统的路有些走偏了。3. 跟踪系统交给 ELK 以后，指标类的数据应由流式数据计算完成统计上报，并一定程度上反馈业务本身，减少运营人员的人工分析成本。</p><p>第二份是开发呼叫控制服务。有了前面失败的教训，自己认真去调研了 Spring State Machine 的用法，但此次对系统的改造历经 2 个月才发布。原因有二：1， 对系统的改造动作过大，几乎重写了全部的呼叫接续逻辑，但从工作量来看就难以快速迭代交付；2， 改造的系统还在持续不断地融入新功能，新系统必须包含全量的新功能。本次服务的选型、原型验证、工作拆分、开发、测试、性能调优，本人都身先士卒，最终在没有出现大问题的情况下交付完成。除了时间上延时较大，整体结果来看，还是不错的。</p><p>第三份是目前正在做的灰度。灰度升级又是一个设计全量服务的系统。第一版本分析出来各服务的入口为， HTTP 和 KAFKA，为了减轻业务侵入，自己给 RIBBON 做了插件，给 KAFKA 客户端做了切面，并以注解和 starter jar 包的形式提供给了各服务。由于侵入性低，各服务拉通比较顺利。后期有发现，服务的任务启动入口还有1， TCP 长连接；2，定时任务。由于这两个启动入口在个别服务中有，再加上赶进度，就先交由业务模块处理了。</p><p>每一个方案的概要设计、详细设计和原型验证均通过自己一板一眼的去研习成熟的开源项目，去和同事交流，去写代码验证。这个过程才是我想要的，虽然很头大，但收获也很大。</p><h1 id="平时总结积累"><a href="#平时总结积累" class="headerlink" title="平时总结积累"></a>平时总结积累</h1><p>从去年 5 月份启动博客开始，坚持了一月一篇的频率更新了下来了。这件事情让我很开心。博客没有单纯介绍某某东西怎么用，而是切切实实的记录了自己的一些思考。比如线程池、Jedis，都是自己读完源码以后的总结和感悟。比如 Mosquitto 也是自己研读了一部分代码的整理和思考，虽然后面此项目自己没有参与，但是还是感谢自己去年的坚持。REST 用法的翻译、CAP 理论的整理记录、PAXOS 算法的整理记录，都是比较消耗时间的。</p><p>工作过程中，解决过 REDIS 哨兵网络原因引起的客户端连接到从库上出现 READ ONLY 的难题，解决过 kafka 空转情况下，流量出现 5 MB 的问题，解决过服务 CLOSE_WAIT 问题，解决过公司自研一致性 hash Jedis 客户端归还异常连接错误问题，解决过莫名其妙不知道消息去哪里的问题。这些问题在解决之前都显得悬而未决，异常难缠，最终都解决了。得益于公司比较轻松的氛围，给时间，给精力去了解这些中间件，了解了自然就更容易知道问题出现在什么地方。</p><h1 id="下一步工作学习规划"><a href="#下一步工作学习规划" class="headerlink" title="下一步工作学习规划"></a>下一步工作学习规划</h1><p>学习一直围绕工作，这是目前自身能力所限定的，还不具备一边工作，一边搞其他技术的眼界和水平。下一步向上需要更加清晰一个商业系统的整体结构，在整体结构的基础上，探索各个组件的优缺点和边界，在各个组件上研习核心技术。</p><p>之前的学习习惯都倒过来了，导致难以学以致用，而且出现学习和实践断节的现象。</p><h1 id="聊聊公司产品形态"><a href="#聊聊公司产品形态" class="headerlink" title="聊聊公司产品形态"></a>聊聊公司产品形态</h1><p>从我自身一个屌丝程序员来看，产品形态不应该只局限于终端，而是提供一个稳定的平台，对接更多形态的终端，现在 docker k8s 这些均为云化服务提供了可能，没必要还局限在我就是要卖个终端这条路，但是卖终端这条路不能丢，因为只有有钱了才能做事情，否则理想只可能是幻想。</p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2019/01/27/2018/#disqus_thread</comments>
    </item>
    
    <item>
      <title>consensus 共识</title>
      <link>http://wzlovegit.github.io/2019/01/12/consensus/</link>
      <guid>http://wzlovegit.github.io/2019/01/12/consensus/</guid>
      <pubDate>Sat, 12 Jan 2019 05:17:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;http://imengdong.cn/2018/11/18/acid%20base%20cap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一气呵成了解分布式&lt;/a&gt;介绍了入门分布式系统的一点基本理论。在现有的网络基础设施条件下，&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="http://imengdong.cn/2018/11/18/acid%20base%20cap/" target="_blank" rel="noopener">一气呵成了解分布式</a>介绍了入门分布式系统的一点基本理论。在现有的网络基础设施条件下，<strong>CAP</strong> 理论中的 P 是不可避免的，因此我们需要在 C 和 A 中做选择。<strong>Base</strong> 理论选择了 AP，强调基本可用、最终一致性，后面我们讨论工业界常见的达成最终一致性的方案。在有些常见的系统中，选择 CP，如果获取不到一致性的值，则会直接导致不可用，zookeeper 就是其中之一。本文从 paxos 入手介绍分布式共识算法。</p><h1 id="分布式共识模型"><a href="#分布式共识模型" class="headerlink" title="分布式共识模型"></a>分布式共识模型</h1><p>在具备容错能力的分布式系统中，分布式共识问题是需要解决的一个基本问题，<strong>它指的是多个分布式节点就某变量的值达成一致，而且一旦达成一致，则该值就是最终确认的值，不会由于某个节点的异常导致该值变化</strong>。<br>分布式共识模型是对工业界需要解决的常见问题的抽象，比如：选主、加锁等。想必大家见识过不止一种选主手段，比如采用 zookeeper 进行选主、在 redis 中通过 redis-sentinel 进行选主等。</p><h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><blockquote><p>如果我们不做数据内核相关的工作，目前对该类算法不感兴趣并不影响我们日常的工作，毕竟这是科学家搞出来的算法，有难度。然而简单了解一下却可以帮助我们了解到类似 zookeeper 这些分布式协调服务的能力边界，不至于认为它可以顺利解决所有分布式问题。</p></blockquote><h2 id="形象化描述"><a href="#形象化描述" class="headerlink" title="形象化描述"></a>形象化描述</h2><p>受论文的影响，paxos 算法介绍的时候总是采用议会选举来描述。这里我们采用小伙伴们常见的约球选球场的方式说明如何就选择哪个球场达成共识。共识问题描述如下：你和其余4个朋友共 5 人，相约每周日要去球馆打篮球。市区内有 30 个球馆在周日提供服务。现在你们周日要去打球了，你们几个只能通过手机（不能建立群组）相互联系，并且由于西安联通的信号很差，所以小伙伴之间经常无法正常取得联系，那么大家怎么最终就选择某个球馆达成一致呢？</p><h2 id="PAXOS-算法"><a href="#PAXOS-算法" class="headerlink" title="PAXOS 算法"></a>PAXOS 算法</h2><img src="/2019/01/12/consensus/paxos1.jpg"><p>上图是对球场共识场景的一个简化，5 人可以同时承担提议者和接受者的角色。为了便于理解，我们让这些人只担当一种角色，从 2 个提议者，3 个接受者的角度入手描述。</p><p>上图描述了 paxos 最简单的场景。小 A 分别对 3 个接受者说，我来给大家选球场（prepare[N]）吧。3 个接受者说好（promise[N]）。小 A 收到这 3 个接受者的授权后，分别对 3 个接受者说，我们去 V 球场（Accept[N，V]）吧。三个接受者因为没有收到其他人的建议就回复小 A 说好（Accepted[N,V]）。此时就去 V 球场就达成了一致。小 B 这时和三个接受者说，我来给大家选球场（prepare[M])吧。若M &lt; N，则接受者会忽略；若M &gt; N，则接受者会告诉小 B，我们已经决定了去 V 球场。此时小 B 接收到了 3 个接受者的拒绝信息，就确定大家都去 V 球场了。</p><p>比如三个接受者中有一个联系不上了，即分布式系统中出现了分区问题，那么怎么办？ </p><img src="/2019/01/12/consensus/paxos2.jpg"><p>上图中虽然有一个接受者联通信号不行，联系不上了，但是由于小 A 获得了超过一半的接受者的支持（达到了quorum）,小 A 依旧会提供自己的建议给这些接受者，直到最终就 V 球场达成一致。等到信号差的接受者电话好了，其他接受者会将选择了 V 球场作为共识的信息通知到该接受者。因此我们可以看到 paxos 算法就最终去 V 球场达成了一致。也就是说<strong>只要接受者有一半可以正常联系到，那么就可以达成共识，容错能力超强</strong>。</p><h2 id="PAXOS-算法问题"><a href="#PAXOS-算法问题" class="headerlink" title="PAXOS 算法问题"></a>PAXOS 算法问题</h2><p>也许你已经发现上述算法一个很大的漏洞，即如果小 A 说完我给大家选球场（prepare[N]），三个接受者同意后（promise[N]）,小 B 也说我给大家选球场(prepare[M])，三个接受者由于还未达成任何共识，因为 N &lt; M，他们必须同意小 B 选球场（promise[M]）。此时如果小 A 提出了去球场 V (accept[N,V])打球，三个接受者会因为小 B 的 M 更大而忽略小 A 的提议。此时小 A 会重新提出我来给大家选球场（prepare[P])，M &lt; P。如此循环下去，那么这个将无休无止了，最终无法选出一个球场。如下图所示：<br><img src="/2019/01/12/consensus/paxos-problem.jpg"><br>令大家意想不到的是，工业界解决这类问题的方法简单到爆：随机时间。即如果提案被忽略，则需要等待一个随机时间才可以再次提出 prepare，该随机时间通常会超过上一个提案达成共识的时间。</p><h2 id="MULTI-PAXOS-算法"><a href="#MULTI-PAXOS-算法" class="headerlink" title="MULTI-PAXOS 算法"></a>MULTI-PAXOS 算法</h2><p>通过对 PAXOS 介绍，我们可发现，每个共识的生成，都至少需要 4 个步骤，两次 RPC，对一个高性能的共识服务器是一个不小的冲击，那么是否可以简化呢？答案是肯定的。我们平时选择球场的时候，通常会由固定的某一个人发起，multi-paxos 选用类似的方式。</p><img src="/2019/01/12/consensus/multi-paxos.jpg"><p>上图是 multi-paxos 算法的描述，与 paxos 不同的是， multi-paxos 会首先通过 paxos 的方式选主。上图中选定小 A 为第 I 年度的队长，那么以后每周去哪个球馆都由小 A 直接向接受者提出（accept[N, I, V]），而不需要先向接受者提出让自己来选择球馆(prepare[N])。这样除了第一次是 4 个步骤，后续只需要两个步骤，少了一半。</p><p>假如小 A 也换成了联通手机，大家都无法联系到小 A 了（即分布式系统中主异常），此时剩下的几人就需要重新选出一个主，即选取第 J 年度队长。等小 A 联系上了之后，接受者会通知小 A，由于你的信号太差，我们选了小 B 作为第 J 年度队长，以后我们让小 B 通知大家吧，小 A 也就欣然接受小 B 作为队长，以后不再提出异议。</p><h2 id="raft、zab"><a href="#raft、zab" class="headerlink" title="raft、zab"></a>raft、zab</h2><p>raft 和 zab 是 multi-paxos 的变种，它们将共识过程分为 3 步：1. 选主；2，备份；3.安全性。raft 在选主完成之后，主会周期性的通过心跳通知从，大哥还好好的，你们听话，直到主异常后，才会进入下一轮的选主。 zab 则在选主完成之后，从周期性的通过心跳看大哥是不是好好的，如果不好就篡位了。想更形象了解 raft，可以通过<a href="https://raft.github.io/了解。" target="_blank" rel="noopener">https://raft.github.io/了解。</a></p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>通过上述的介绍，我们对分布式共识算法有了初步了解。我们知道 zookeeper 实现了 zab 协议，那么它可以做到什么，做不到什么呢，又是如何工作的呢？</p><img src="/2019/01/12/consensus/masterandlock.jpg"><p>因为 zookeeper 可以就某一值达成共识，所以我们可以通过 zookeeper 对我们的服务进行选主。由于算法的安全性保障只要达到 quorum 的 zookeeper 正常工作，我们最终可以确认唯一的节点为主节点。分布式锁也可以由 zookeeper 实现，一旦某个客户端加锁成功，则 zookeeper 会就这一情况达成共识，即使主 zookeeper 后来挂掉，也会延续这一共识。但我们要认识到，在 curator-recipes 的实现中采用的临时 node，那么一旦具有锁的客户端连接丢失，超过 session 时间后，锁就会被释放。</p><p>zookeeper 不能完成所有情况下客户端强一致性的保证。比如我们用 zookeeper 做个简单的配置中心，配置下发过程中，一旦客户端连接丢失，则配置信息不会及时通知到客户端。也就是说，我们不能就此保证各个客户端目前肯定就某一种配置达成一致。<br><img src="/2019/01/12/consensus/client.jpg"></p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2019/01/12/consensus/#disqus_thread</comments>
    </item>
    
    <item>
      <title>springcloud</title>
      <link>http://wzlovegit.github.io/2018/12/23/springcloud/</link>
      <guid>http://wzlovegit.github.io/2018/12/23/springcloud/</guid>
      <pubDate>Sun, 23 Dec 2018 12:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文讲述如何使用 spring cloud 中的部分基础设施构建一套微服务脚手架，基于该脚手架工程丰富自己的业务，而无需关注过多基础设施的开发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文讲述如何使用 spring cloud 中的部分基础设施构建一套微服务脚手架，基于该脚手架工程丰富自己的业务，而无需关注过多基础设施的开发。</p></blockquote><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>开源社区有很多能量很大的工程师，优秀地抽象了基础设施具备的能力。Spring 提供了 IoC 、 AOP 基础能力，基于此基础能力，很多基础设施又都方便得集成到了 Spring 上面，从而构成了大而全的 Spring Cloud 项目，而且还在不断地发展。Spring Cloud 是一套完整的微服务基础设施方案，我们通常采用如下方式构建项目：</p><img src="/2018/12/23/springcloud/springcloud.png"><p>Zuul 被用作 API 网关，同时借助 Ribbon 和 Hystrix 提供可监控的服务器负载均衡能力。Zuul 服务通常采用 Eureka-Client 注册到 Eureka-Server，用于获取内部服务的状态，并将请求转发给对应的服务。内部服务通过 Ribbon、Hystrix、Feign 完成微服务间调用。通过 Sleuth 监控微服务调用的依赖关系和性能，将监控到的元数据 SPAN 发布到离线消息队列 KAFKA，用 Zipkin 展示微服务调用的依赖关系和性能。Actuator 用于检查服务本身的运行状态：CPU状况、内存状况等。</p><h1 id="微服务和SOA"><a href="#微服务和SOA" class="headerlink" title="微服务和SOA"></a>微服务和SOA</h1><p>上图中提供了一套微服务的基础设施，然而，在历史包袱的情况下，我们是不能一步到位将所有服务都转型为微服务的架构。那么整个的微服务模块可以作为一个整体对外提供服务，也就是 SOA 结构。</p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/12/23/springcloud/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ribbon</title>
      <link>http://wzlovegit.github.io/2018/12/18/ribbon/</link>
      <guid>http://wzlovegit.github.io/2018/12/18/ribbon/</guid>
      <pubDate>Tue, 18 Dec 2018 11:31:00 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文只对 Ribbon 的概要设计进行描述，从客户端负载均衡器的角度认识 Ribbon，便于自己设计和实现客户端负载均衡器，或者为 Ribbon 做插件满足自身业务需求（最近项目中我们给 Ribbon 做了个小插件完成 A/B 测试能力）。源代码分
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文只对 Ribbon 的概要设计进行描述，从客户端负载均衡器的角度认识 Ribbon，便于自己设计和实现客户端负载均衡器，或者为 Ribbon 做插件满足自身业务需求（最近项目中我们给 Ribbon 做了个小插件完成 A/B 测试能力）。源代码分析可以自行深入或者配合博客书籍自己阅读。</p></blockquote><p>Ribbon 是一款非常优秀的客户端负载均衡工具，在 Spring Cloud 的微服务架构中起了至关重要的作用。近来由于项目的需要，对 Ribbon 的原理进行了深入学习，同时在 Ribbon 的基础上扩展了几个点，所以对 Ribbon 有了更新的认识。</p><h1 id="客户端负载均衡和服务端负载均衡"><a href="#客户端负载均衡和服务端负载均衡" class="headerlink" title="客户端负载均衡和服务端负载均衡"></a>客户端负载均衡和服务端负载均衡</h1><p>之前介绍 REST 的时候介绍过为了降低服务器开发的复杂性，REST 的设计理念当中，HTTP 请求需要客户端负载均衡，Ribbon 就是 HTTP 客户端负载均衡工具；不过想必大家也听说过诸如 Nginx 、 Zuul 这些具有服务器负载均衡能力的网关。那么问题来了：为什么既有客户端负载又要有服务端负载均衡呢？</p><img src="/2018/12/18/ribbon/loadbalancer.png"><p>从功能上来讲，服务端负载均衡通常出现在服务网关中，网关隔离外部客户端和内部服务，这个外部客户端如同用户和服务的中介。比如：小明在 APP 点击下单，此时 APP 会将下单的请求发送到淘宝的网关，再由网关转到对应的服务。网关在隔离 APP 和服务的同时，为服务提供负载均衡的能力。客户端负载均衡通常出现在内部服务的交互中，在微服务架构中尤为常见。比如服务 A 查询服务 B 中某用户是否在黑名单，从而进一步决定自己的业务流向。上图中红色部分为服务端负载均衡，绿色部分为客户端负载均衡。</p><h1 id="Ribbon-的工作方式"><a href="#Ribbon-的工作方式" class="headerlink" title="Ribbon 的工作方式"></a>Ribbon 的工作方式</h1><p>Ribbon 通过在 RestTemplate 上面添加 @LoadBalancer 实现。RestTemplate 是 Spring 为我们封装的 HTTP 请求工具，借助 @LoadBalancer 可以为 RestTemplate 设置请求前拦截器，用以拦截请求，根据策略为该请求选择合适的实例，并将请求转发出去。<br>我们不妨从一个设计者的角度出发去思考如何设计一个客户端负载均衡器。第一步，需要我们获取服务实例状态；第二步需要根据服务实例状态按照某种策略选择一个实例；第三部需要将请求发送到该实例。其实这也是 Ribbon 的总体设计。</p><img src="/2018/12/18/ribbon/ribbonmodule.png"><p>如上图所示，Ribbon 通过 ServerList 提供的方法获取实例状态。 ServerListUpdater 采用周期性拉取服务器实例或者经由注册中心发布服务器实例状态变更信息。ServerListFilter 按照规则过滤出符合规则的服务器实例，提供了更多的个性化能力。IPing 用于测试服务器实例是否正常。这些信息足够我们获取全部实例的状态。在全部实例状态的基础上，IRule 提供了众多的实例选取策略，比如轮询、随机、权重等。在我们选择了一个实例以后，就可以将请求发送到服务实例。</p><h2 id="获取服务实例状态"><a href="#获取服务实例状态" class="headerlink" title="获取服务实例状态"></a>获取服务实例状态</h2><p>Ribbon 可以通过配置读取服务器实例状态，也可以通过 Eureka-Client 等服务发现客户端从服务注册中心获取全量服务器实例状态。通常情况下，Ribbon 提供的这两种方式足以满足我们的业务需求。但是有些情况下我们想让 Ribbon 按照我们指定的策略获取服务器实例信息，怎么处理呢？</p><p>从上面的介绍可知， ServerListFilter 可以从全部实例中按照规则过滤服务器实例，所以此处我们是可以自定义 ServerListFilter 规则，并在配置文件中指定我们的 ServerListFilter 为 Ribbon 过滤服务器的策略，这样在每次 ServerListUpdater 触发执行的时候，都会按照我们指定的 ServerListFilter 选择服务器实例。</p><p>Ribbon 在 ServerListFilter 也提供了众多的方案，比如 Zone亲和、动态获取等。</p><h2 id="选择指定类型的服务实例"><a href="#选择指定类型的服务实例" class="headerlink" title="选择指定类型的服务实例"></a>选择指定类型的服务实例</h2><p>Zuul 网关在实现的时候直接集成了 Ribbon 和 Hystrix（模块化做的太好了），直接在网关上面集成了负载均衡的能力。假设我们需要为每个请求选择指定类型的服务器实例，请求 reqA 选择 A 类型的服务实例，请求 reqB 选择 B 类型的服务实例，怎么处理呢？</p><p>乍一看我们可以通过 ServerListFilter 来完成，但是其实是做不到的。因为 ServerListFilter 的执行时机是 ServerListUpdater 触发的时候，与 HTTP 请求的生命周期是没有任何关系的。即使没有请求 ServerListFilter 依旧会被 ServerListUpdater 触发；请求到来也不会触发 ServerListFilter。因此我们无法通过 ServerListFilter 为每个请求选择服务实例。我们可以通过扩展 ILoadBalancer 来根据请求内容变换 ILoadBalancer 的服务器实例信息。因为请求到来后，必然会执行 IRule 的 chooseServer 方法， chooseServer 方法会从负载均衡状态对象中获取服务器实例状态，在返回这些状态的时候，我们可以通过 req 携带的 A 或者 B 信息筛选服务器实例，并传递给 IRule。 IRule 只会从这些返回实例中根据路由规则获取一个实例。可以看一下 Ribbon 的 chooseServer 实现方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 可以看到我们把 ILoadBalancer 传递进去了，他会提供 getReachableServers getAllServers 等信息给 IRule 让其选择一个实例</span><br><span class="line"> */</span><br><span class="line">public Server choose(ILoadBalancer lb, Object key) &#123;</span><br><span class="line">    if (lb == null) &#123;</span><br><span class="line">        log.warn(&quot;no load balancer&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Server server = null;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (server == null &amp;&amp; count++ &lt; 10) &#123;</span><br><span class="line">        List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">        List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">        int upCount = reachableServers.size();</span><br><span class="line">        int serverCount = allServers.size();</span><br><span class="line"></span><br><span class="line">        if ((upCount == 0) || (serverCount == 0)) &#123;</span><br><span class="line">            log.warn(&quot;No up servers available from load balancer: &quot; + lb);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int nextServerIndex = incrementAndGetModulo(serverCount);</span><br><span class="line">        server = allServers.get(nextServerIndex);</span><br><span class="line"></span><br><span class="line">        if (server == null) &#123;</span><br><span class="line">            /* Transient. */</span><br><span class="line">            Thread.yield();</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">            return (server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Next.</span><br><span class="line">        server = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (count &gt;= 10) &#123;</span><br><span class="line">        log.warn(&quot;No available alive servers after 10 tries from load balancer: &quot;</span><br><span class="line">                + lb);</span><br><span class="line">    &#125;</span><br><span class="line">    return server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h2><p>或许有些朋友好奇为什么指定了我们自己提供扩展，Ribbon 就会使用我们提供的扩展而不是使用期默认的实现。Springboot 的约定大于配置并非废弃配置，只是提供了一种便捷的配置方案。下面举例说明 Ribbon 是如何实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public ServerListFilter ribbonServerListFilter(IClientConfig config) &#123;</span><br><span class="line">if (this.propertiesFactory.isSet(ServerListFilter.class, name)) &#123;</span><br><span class="line">return this.propertiesFactory.get(ServerListFilter.class, config, name);</span><br><span class="line">&#125;</span><br><span class="line">ZonePreferenceServerListFilter filter = new ZonePreferenceServerListFilter();</span><br><span class="line">filter.initWithNiwsConfig(config);</span><br><span class="line">return filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 RibbonClientConfiguration.java 的ServerListFilter 这段代码中可知， Spring 在装配 Ribbon 的 ServerListFilter 的时候，会先从 propertiesFactory 查询是否已经配置，如果是，则返回配置的 filter，否则创建 ZonePreferenceServerListFilter， 初始化之后返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 读取配置文件获取类</span><br><span class="line"> */</span><br><span class="line">public String getClassName(Class clazz, String name) &#123;</span><br><span class="line">if (this.classToProperty.containsKey(clazz)) &#123;</span><br><span class="line">String classNameProperty = this.classToProperty.get(clazz);</span><br><span class="line">String className = environment.getProperty(name + &quot;.&quot; + NAMESPACE + &quot;.&quot; + classNameProperty);</span><br><span class="line">return className;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果类存在则实例化该类，并返回</span><br><span class="line"> * 否则返回 null</span><br><span class="line"> */</span><br><span class="line">public  C get(Class clazz, IClientConfig config, String name) &#123;</span><br><span class="line">String className = getClassName(clazz, name);</span><br><span class="line">if (StringUtils.hasText(className)) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Class toInstantiate = Class.forName(className);</span><br><span class="line">return (C) instantiateWithConfig(toInstantiate, config);</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Unknown class to load &quot;+className+&quot; for class &quot; + clazz + &quot; named &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 getClassName 从配置文件中读到了配置的类，则通过 Class.forName 和 instantiateWithConfig 初始化一个 ServerListFilter 实例，并返回给 Spring 容器，后续状态整个负载均衡器的时候，采用 ServerListFilter 装配。</p><p>所以我们在提供 starter 的时候，也可以采用这种方式实现，提供更加灵活的配置。</p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/12/18/ribbon/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一气呵成了解分布式</title>
      <link>http://wzlovegit.github.io/2018/11/18/acid%20base%20cap/</link>
      <guid>http://wzlovegit.github.io/2018/11/18/acid%20base%20cap/</guid>
      <pubDate>Sun, 18 Nov 2018 02:26:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;分布式的理念已经遍地开花，无论数据库存储、大规模计算、文件系统以及大多数商用软件的后台服务器都无法绕开分布式。相比于单机系统而言，分布式无论从理解上还是管理上复杂性都提高了不止一个量级，为什么大家还要选择用分布式？分布式在解决了某些问题的时候，又给我们带来了哪些新的问题？在
        
      
      </description>
      
      <content:encoded><![CDATA[<p>分布式的理念已经遍地开花，无论数据库存储、大规模计算、文件系统以及大多数商用软件的后台服务器都无法绕开分布式。相比于单机系统而言，分布式无论从理解上还是管理上复杂性都提高了不止一个量级，为什么大家还要选择用分布式？分布式在解决了某些问题的时候，又给我们带来了哪些新的问题？在设计分布式应用的时候，需要遵循哪些基本原则？日常我们又用过哪些分布式系统呢？本文将围绕上述的问题展开说明。</p><h1 id="分布式简介"><a href="#分布式简介" class="headerlink" title="分布式简介"></a>分布式简介</h1><h2 id="认识分布式系统"><a href="#认识分布式系统" class="headerlink" title="认识分布式系统"></a>认识分布式系统</h2><p>分布式系统将一组计算机组合起来，提供统一的服务。从使用者角度来看，分布式系统使用起来和单机系统是一样的。下面我们引用[1]中的例子进行说明。</p><img src="/2018/11/18/acid%20base%20cap/traditional&distribute.png"><p>传统的数据库安装在一个单机 OS 的文件系统上，所有与该数据库的交互（CRUD）都在该数据库完成。而在分布式数据库部署中，用户通常会和多个数据库服务器交互。从上图可以看出，采用分布式数据库部署之后，第一可以将读写数据库操作分离；第二可以进行数据备份；第三可以进行主从切换。</p><h2 id="分布式系统的成因"><a href="#分布式系统的成因" class="headerlink" title="分布式系统的成因"></a>分布式系统的成因</h2><p>相较于单机系统，开发、调试、部署、运维分布式系统的难度更大。甚至可以这样说，一个完整的运维监控平台是分布式系统进入商用阶段必不可少的一部分（ google 发表了 dapper 论文，facebook 开发了 zipkin 工具，spring cloud 也集成 sleuth ）。商用分布式系统意味着规模庞大的运维监控管理平台。既然如此，我们为什么还要做分布式系统？</p><blockquote><p>此处声明一个观点：被逼的。分布式系统除了解决了单机系统面临的难题外，还引入了单机系统不存在的问题。有钱有势，我想没必要做分布式系统。想必大家在办事情的时候都遇到过“我们领导不在，你明天再来。”这种牛逼的回答。人家就是纯单机，领导不在直接不提供服务。</p></blockquote><p>显然分布式系统并非智力游戏，它提供了单机系统所不具备的几个重要的影响用户体验的能力：</p><ol><li><p><strong>水平扩展能力</strong><br>水平扩展指若一个服务节点可以为 m 个用户提供正常服务，那么 n 个服务节点可以为 n * m 个用户提供正常服务。也就是说系统可服务的用户数可随着服务节点个数线性增长。<br>通常我们达不到如此理想的水平扩展能力，因为随着节点个数增多，节点间信息同步、路由用户到某节点等开销都会增大。所以只要在 n = max_user_num / m 的范围内（其中 max_usr_num 为预估用户最大值）满足水平扩展，我们就可以认为该系统具有水平扩展能力。<br>与水平扩展相呼应的的扩展方式叫做垂直扩展，垂直扩展通常指提高单机硬件设备处理能力。垂直扩展对于大业务量的服务器来讲通常是杯水车薪。</p><blockquote><p>想象一个场景，随着用户量的变大和需求的愈加复杂，有一天突然节点 CPU 80%，free -m 为100，投诉纷至沓来。正在老板焦头烂额之际，很多人提出了两个方案：1， 让码农加班优化；2，买主频更高的 CPU ，换更大的内存。第一种方案，等你优化完，项目组都解散了；第二种方案，即使是目前最好的 CPU，它的处理能力也是有限的；可扩展内存的数量也是非常有限的。此时若只需要在云端扩充几个一模一样的节点就可以迅速恢复服务将会是最快速稳妥的方案。</p></blockquote></li><li><p><strong>更高的可用性</strong></p><p>假设一台主机在某一时刻发生不可恢复的故障的可能性为 1/1000。根据概率论的知识可知 n 台主机在某一时刻同时故障的概率为 (1/1000) ^ n。在 n &gt; 1 的情况下，分布式比单机系统提供了更高的可用性的。</p></li><li><p><strong>更小的延迟</strong></p><p>第一由于分散了服务节点压力，服务节点可以更快的响应用户；第二若多地域部署分布式系统，用户可以选择就近接入，提高响应速度。</p></li></ol><h1 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h1><p>事物总是具有两面性，分布式系统在解决单机系统出现的问题的同时也引入了单机系统没有的多节点数据一致性问题。下面我们首先介绍产生该问题的原因（CAP），然后介绍两种解决数据一致性问题的实践。</p><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>CAP （Consistency、Availability、Partition Tolerance)是指在现在基础设施条件下，一个分布式系统无法同时满足一致性、可用性和分区容忍性。</p><img src="/2018/11/18/acid%20base%20cap/cap.png"><ul><li><p><strong>一致性（Consistency）</strong> ： 所有节点访问同一份最新的数据副本</p></li><li><p><strong>可用性（Availability）</strong> ：每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据</p></li><li><p><strong>分区容忍性(Partition Tolerance)</strong> ： 以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</p></li></ul><p>就现在基础设施而言，网络是不可靠的，分区是必然的。如果我们保证了一致性，那么在分布式系统数据未达成一致的时间内，是不能提供访问的，即不具备可用性。如果我们保证了可用性，那么在分布式系统数据未达成一致的时间内，我们提供的数据不是最新数据，即不保证一致性。</p><blockquote><p>AP 和 CP 均有商用分布式系统采用，就数据库而言，Cassandra 是 AP，MySQL 事务则是 CP。</p></blockquote><h2 id="ACID-VS-BASE"><a href="#ACID-VS-BASE" class="headerlink" title="ACID VS BASE"></a>ACID VS BASE</h2><h3 id="事务-ACID"><a href="#事务-ACID" class="headerlink" title="事务 ACID"></a>事务 ACID</h3><ul><li><strong>原子性（Atomicity）</strong> : 数据库事务要么完整的执行完毕，要么就恢复执行之前的状态。不允许出现执行一部分的状态。</li><li><strong>一致性（Consistency)</strong> : 事务将数据库从一个合法状态转移到另一个合法状态。比如银行转账，A转给B 500，那么事务执行成功后必须是 A 减少 500，B增加 500 ，不能出现 A 减少 500 ，B 没变的情况。</li><li><p><strong>隔离性（Isolation）</strong> : 多个客户端生成的多个事务是互相隔离执行。隔离级别分为 4 类：脏读、不可重复读、幻读、串行。</p><blockquote><ol><li>脏读： A B 事务并行执行，A 事务写入的未提交的数据被 B 事务读取到</li><li>不可重复读： A B 事务并行执行，A 事务写入的已提交的数据被 B 事务读取到</li><li>幻读： A B 事务并行执行，A 向表中添加了一条数据，B 通过查询全部记录条数统计到该数据，但却无法检索出来。</li><li>串行： A B 事务并行执行， B 事务必须等 A 事务执行完毕才能执行。</li></ol></blockquote></li><li><strong>持久性（Durability）</strong> : 事务的数据操作必须反映在非易失性存储中（比如硬盘）并在事务成功完成后保持不变。事务失败则不能使数据处于部分提交状态。</li></ul><p>由此可见事务为了保证一致性，但牺牲了可用性。即若不能达成一致性，则拒绝提供服务，直到全部成功或全部失败。</p><h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><ul><li><strong>基本可用（BasicallyAvailable）</strong> ：系统总是可以给用户一个响应</li><li><strong>可变状态（Soft State）</strong> : 系统中存储的值可能在返回给用户之后又发生了变化</li><li><strong>最终一致性（Eventually Consistent）</strong> : 当数据添加到系统后，系统会将数据逐渐复制到其他节点。也正是由于最终一致性要求，会产生可变状态。</li></ul><p>由此可见 BASE 理论采用可变状态 + 最终一致性减弱了一致性约束。它倾向于 AP。</p><p>我们知道，为了保证事务的 ACID 特性，关系型数据库通过 MVCC 做了大量的工作。然而在很多应用场景中，强一致性并没有可用性那么重要。比如，线上抢购系统，在10000个人同时抢购的时候，显示还有 1000 台， 最终可定有 9000 个用户没抢上，再下单时台数已经为 0。然而用户是可以接受这种现象的。但是如果为了强一致性要求，而使得网站拒绝服务，则会让用户反感。</p><h1 id="分布式模型"><a href="#分布式模型" class="headerlink" title="分布式模型"></a>分布式模型</h1><p>虽然都是分布式服务，但是提供服务的方式不尽相同，下面介绍两种常见的分布式模型。</p><h2 id="主备模型"><a href="#主备模型" class="headerlink" title="主备模型"></a>主备模型</h2><p>主备模型多见于持有状态的服务，比如数据库、消息队列、任务调度等。比如在写入比例远小于查询比例的场景中，MySQL 部署方式采用的是一主多备，主库写入，备库读取；Kafka 的 partition 在各 Kafka 的物理机上分布的时候也是一主多备，在主 partition 故障之后，备 partiton 继续提供数据；分布式调度框架通常也采用一主多备的形式，主调度负责下发任务，在主调度故障之后，由备调度继续下发任务。</p><p>对于 Kafka 来讲只是数据上的主备，处理上采用的是多活模型，因此支持水平扩展。对于 MySQL 来讲，处理上就采用的主从模型，即只有主库具有写入权限，备库只支持查询。这个时候的水平扩展给我们带来另外一个话题：客户端协作。</p><h3 id="客户端协作"><a href="#客户端协作" class="headerlink" title="客户端协作"></a>客户端协作</h3><p><strong>服务器分片</strong>，比如 redis-cluster 系统，在客户端向 cluster 中的节点 A 发起请求的时候，若请求的结果在节点 A 上，那么 redis-cluster 会将结果直接返回，如果在 B 节点， redis-cluster 会给客户端回复一个重定向命令，客户端会将请求发往 B 节点，从而完成分布式操作。这是 redis-cluster 是可以支持水平扩展的。<br><strong>客户端分片</strong>，比如 mycat 服务用来支持 MySQL 的水平扩展。在客户端发起请求的时候，由客户端对请求进行路由，分发到不同的 MySQL 服务器。</p><h2 id="多活模型"><a href="#多活模型" class="headerlink" title="多活模型"></a>多活模型</h2><p>多活模型通常用于业务应用开发，业务应用的状态全部存储在缓存、消息队列、数据库等服务中，业务应用本身无状态。业务应用提供无差别服务。<br>我们知道，多活模型通常有两种方法来导流客户端请求：<strong>服务器路由</strong> VS <strong>客户端路由</strong>。<br>在 Spring Cloud 的微服务架构中采用<strong>客户端路由</strong>。服务端注册到 Eureka-Server 并提供 RESTful 接口（无状态接口），客户端（Ribbon 、 Hystrix 、 Feign）通过 Eureka-Server 提供的接口发现服务，并采用既定的路由规则进行路由。Ribbon 提供了多种路由，IRule 接口提供了服务发现的规则（包括轮询、加权、区域亲和等），chooseServer 接口提供了选择服务的规则，在这两种策略的配合下，为客户端选择出指定的服务器。</p><p>对于对外提供的接口（整个系统之外），则需要用到<strong>服务器路由</strong>，通常采用 Zuul、Nginx 等负载均衡工具，针对服务器的使用情况进行负载均衡。</p><h1 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h1><h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>思考中，未消化。<br><a href="https://zhuanlan.zhihu.com/p/25933039" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25933039</a><br><a href="https://zhuanlan.zhihu.com/p/36153160" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36153160</a></p><h2 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h2><p>分区容忍性（CAP 中的 P）是不可避免的，在网络环境下，节点无法全部互联，从而出现各自为政的局面，如下图所示，我们称之为脑裂现象。</p><img src="/2018/11/18/acid%20base%20cap/splitbrain.png"><p>如上例，我们假定上述5个节点为 redis-sentinel 节点，左边三个互联，右边两个互联，左边和右边网络断开连接，此时需要哨兵投票哪个 redis 服务器作为主服务器。左边三个认为 A 是或者的，选择了 A 节点，右边两个认为 B 是存活的，选择 B 节点，那么就会存在数据不一致的严重问题。如何保证一致性或最终一致性呢？</p><h3 id="Quorum-（维基百科）"><a href="#Quorum-（维基百科）" class="headerlink" title="Quorum （维基百科）"></a>Quorum （维基百科）</h3><p>Quorom 机制，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鸽巢原理。</p><p>在有冗余数据的分布式存储系统当中，冗余数据对象会在不同的机器之间存放多份拷贝。但是同一时刻一个数据对象的多份拷贝只能用于读或者用于写。该算法可以保证同一份数据对象的多份拷贝不会被超过两个访问对象读写。</p><p>分布式系统中的每一份数据拷贝对象都被赋予一票。每一个读操作获得的票数必须大于最小读票数（read quorum）（Vr），每个写操作必须获得获得的票数必须大于最小写票数（write quorum）(Vw）才能读或者写。如果系统有V票（意味着一个数据对象有V份冗余拷贝），那么最小读写票数(quorum)应满足如下限制：</p><ol><li>Vr + Vw &gt; V</li><li>Vw &gt; V/2</li></ol><p>第一条规则保证了一个数据不会被同时读写。当一个写操作请求过来的时候，它必须要获得Vw个冗余拷贝的许可。而剩下的数量是V-Vw 不够Vr，因此不能再有读请求过来了。同理，当读请求已经获得了Vr个冗余拷贝的许可时，写请求就无法获得许可了。第二条规则保证了数据的串行化修改。一份数据的冗余拷贝不可能同时被两个写请求修改。</p><p>在区间 (V/2, V] 调整 Vw 的值可以改变写入操作的开销。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote><p>[1] <a href="https://hackernoon.com/a-thorough-introduction-to-distributed-systems-3b91562c9b3c" target="_blank" rel="noopener">https://hackernoon.com/a-thorough-introduction-to-distributed-systems-3b91562c9b3c</a><br>[2] <a href="https://www.dummies.com/programming/big-data/hadoop/acid-versus-base-data-stores/" target="_blank" rel="noopener">https://www.dummies.com/programming/big-data/hadoop/acid-versus-base-data-stores/</a><br>[3] <a href="https://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="noopener">https://queue.acm.org/detail.cfm?id=1394128</a><br>[4] <a href="https://www.johndcook.com/blog/2009/07/06/brewer-cap-theorem-base/" target="_blank" rel="noopener">https://www.johndcook.com/blog/2009/07/06/brewer-cap-theorem-base/</a><br>[5] <a href="https://zh.wikipedia.org/wiki/Quorum_(%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Quorum_(%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)</a></p></blockquote>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/11/18/acid%20base%20cap/#disqus_thread</comments>
    </item>
    
    <item>
      <title>REST Introduction</title>
      <link>http://wzlovegit.github.io/2018/10/21/rest/</link>
      <guid>http://wzlovegit.github.io/2018/10/21/rest/</guid>
      <pubDate>Sun, 21 Oct 2018 09:26:00 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://www.restapitutorial.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.restapitutorial.com/&lt;/a&gt; ，继承协议 C
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>本文翻译自 <a href="https://www.restapitutorial.com/" target="_blank" rel="noopener">https://www.restapitutorial.com/</a> ，继承协议 Creative Commons Attribution-ShareAlike 4.0 International License。转载请注明出处。</p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>与其他计算机技术一样，构建好一个 RESTful 服务也是科学与艺术的结合。互联网方兴未艾，如火如荼，采用业界最佳实践创建 REST API 变得越来越重要。由于 RESTful web 服务不遵循除 HTTP 以外的规定标准，因此根据行业最佳实践构建 RESTful API 以简化并提高客户端使用率变得非常重要。</p><p>目前没有很多可以帮助开发人员的 REST API 实践指南，RestApiTutorial.com 致力于专研 REST API 的最佳实践并且为开发人员提供资源，以便大家可以参考和自我学习。</p><h1 id="REST-简介"><a href="#REST-简介" class="headerlink" title="REST 简介"></a>REST 简介</h1><p>REST 架构包含 6 个约束，参见 <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="noopener">https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a> ：</p><ul><li><p>统一接口</p><p>统一接口用于简化和解耦客户端和服务端，以便于它们独立发展。统一接口设计的 4 个指导原则如下：</p><p><strong>基于资源</strong></p><p>请求中采用 URI 标识唯一资源。资源和返回给客户端的资源呈现是不同的，例如，服务器会将表示数据库记录的用UTF-8编码的 HTML，XML 或 JSON 数据发送给客户端，而不是将数据库返回给客户端。这里的 HTML，XML 或 JSON 等就是资源呈现，数据库真实的记录就是资源。</p><p><strong>通过资源呈现操作资源</strong></p><p>当客户端持有一个资源呈现及其附属的元数据时，它就应该具有足够多的信息在其权限允许的范围内增加、修改、删除服务器的资源。</p><p><strong>自描述消息</strong></p><p>每个消息需要包含如何处理它的足够信息，比如，采用 MIME 类型指定采用那个解析器处理消息，响应也需要明确指定它们的缓存能力。</p><p><strong>超媒体用作应用状态引擎（HATEOAS）</strong></p><p>客户端通过请求体、请求行、请求头传递状态到服务端，服务端通过响应体、响应码、响应头传递状态到客户端。这种方式称为超媒体。</p><p>除了上面的描述，HATEOAS 还意味着在必要的情况下，链接需要包含在返回的响应体重以便 URI 检索相关资源。</p><blockquote><p>统一接口是任何 REST 服务设计的基础</p></blockquote></li><li><p>无状态</p><p>REST 是 REpresentational <strong>State</strong> Transer （资源呈现状态迁移） 的简写，无状态是关键，也就是说处理当前请求所必需的状态就包含在该请求（无论是包含在 URI、查询参数、请求体、请求头）中，无需其它维系状态的手段。URI 唯一标识资源，请求体中包含资源的状态，服务器基于这两个信息处理完请求后通过响应头、响应体和状态码将结果状态返回给客户端。</p><p>有过工作经历的工程师都接触过 <strong>session</strong> 用于在服务器保存跨 HTTP 请求的业务状态，然而，在 REST 结构中，客户端需要维护所有的状态信息以便提供给服务器处理该请求，即便在该业务状态需要跨越多个 HTTP 请求的情况下，依旧需要客户端多次发送状态。无状态的条件下，服务器不用维系会话状态，使得服务器易于横向扩展。另外，无状态的使得服务器在设计负载均衡的时候无需考虑会话关系。</p><p>如何区分状态和资源？状态或应用状态是指服务器为了处理请求需要关注的信息，比如请求中携带的必要数据。资源或者资源状态是指资源呈现所指向的真正内容，比如数据库中的数据。每个客户端可以根据每次请求的需要更改应用状态，然而资源是在所有发起请求的客户端间是共享的常量。</p><p>是否遇到过由于 web 应用需要您按照既定顺序填写内容而您没有照做引起的服务失败？这正是因为它违背了无状态原则。然而某些场景确实无法做到无状态，比如 three-legged OAuth，API调用频率限制等，在这些场景下，您就需要尽可能保证服务一次性完成，避免服务跨越多个请求才能完成。</p></li></ul><ul><li><p>可缓存</p><p>和万维网一样，在 REST 架构中，客户端可以缓存响应，因此响应需要直接或间接的定义它们是否可以被缓存，以防止客户端在后续的请求中重用不恰当的数据。管理良好的缓存或多或少减少了客户端服务器的直接交互，更进一步提升了扩展性和性能。</p></li><li><p>C/S 模式</p><p>统一接口将客户端和服务器分开，这样的话，客户端无需考虑数据存储，交由服务器来完成，因此提升了客户端的可移植性；服务器不用考虑用户状态，因此提升了服务器的可扩展性和简单性。只要接口不发生变更，客户端和服务器可以独立开发和升级。</p></li><li><p>分层系统</p><p>客户端通常无法判断它是直连了终端服务器还是沿途的中间服务器，中间服务器可以通过启用负载均衡和共享缓存提供系统可伸缩性。分层机制也可以更加方面的实施安全保护措施。</p></li><li><p>Code on Demand(optional)</p><p>服务器可以通过传输客户端可以执行的逻辑扩展或定制客户端功能，比如包含客户端脚本（例如JS）和编译组件（例如 Java applets）。</p><p>符合 REST 风格，遵循上述约束可以带来诸如性能、可伸缩性、简单性、可修改性、可见性、可移植性和可靠性等诸多好处。</p><blockquote><p>注：Code on Demand 是唯一一个可选约束。如果违背了其他约束，那么该服务严格意义上并不是一个真正的 RESTful 服务。</p></blockquote></li></ul><h1 id="REST-API-小贴士"><a href="#REST-API-小贴士" class="headerlink" title="REST API 小贴士"></a>REST API 小贴士</h1><p>下面介绍 6 个 REST API 设计的小贴士，不管是不是严格的 RESTful 服务，这些小贴士都会帮助您设计出更好用的服务。</p><ul><li><p>合理运用 HTTP 中的动词<br>API 使用者可以发送 GET、POST、PUT 和 DELETE 这些动词给服务器，这极大地增强了请求的表达能力。主要的 HTTP 动词用法如下：</p><ul><li><strong>GET</strong><br><strong>查</strong>：读取（查询）某个指定资源或某个指定资源的集合。</li><li><strong>PUT</strong><br><strong>改</strong>：修改某个指定资源或某个自定资源的集合。如果预先知道资源标识符，PUT 也可以用于创建特定资源。</li><li><strong>DELETE</strong></li><li><strong>删</strong>：删除指定资源</li><li><strong>POST</strong><br><strong>增</strong>：创建一个新资源。对于不适合上述三类的操作，POST 是一个万金油动词。</li></ul></li><li><p>提供合理的资源名称<br>创建一个优秀的 API 来自于 80% 的艺术和 20% 的科学。采用层级性的 URL 用以合理表示资源是 API 设计的艺术部分。一个合理的资源名称（URL 路径，比如 /customers/12345/orders）有助于更加清晰的表达请求的内容。<br>合理的资源名称可以为服务请求提供上下文，使得 API 更易理解。URI 的层次性为 API 使用者提供友好的易于理解的资源层次结构，利于 API 在应用程序中使用。<br>下面是几个快速设计 URL （资源名称）的规则：</p><ul><li><strong>URL 中采用标识符代替查询字符串</strong>。查询字符串参数适合过滤但不适合用作资源名称。<br>好： /users/12345<br>差： /api?type=user&amp;id=23</li><li><strong>采用 URL 的分层特性来表示资源结构</strong>。</li><li><strong>面向用户设计资源名称，而非面向数据</strong>。</li><li><strong>资源名称采用名词命名，用 HTTP 方法指定动作</strong>。</li><li><strong>在 URL 的分层中，采用复数命名形式</strong>。使用复数可以使得 URL 在跨 HTTP 的方法保持一致。<br>好： /customers/33245/orders/8769/lineitems/1<br>坏： /customer/33245/order/8769/lineitem/1</li><li><strong>避免冗余的表示集合的命名方式</strong>。比如， customer_list 可以采用复数形式替换， customers。</li><li><strong>在 URL 分层中采用小写形式，使用下划线或连字符分隔单词</strong>。有些服务器大小写不敏感，因此最好保持一致性。</li><li><strong>在清楚表明语义的情况下，保持 URL 短小精悍</strong>。</li></ul></li></ul><ul><li><p>采用 HTTP 响应码表明处理状态</p><p>响应状态码是 HTTP 协议的一部分，它们涵盖了绝大部分常见的场景。由于 RESTful 也遵循 HTTP 规范，所以我们设计的 API 也应该返回相关的 HTTP 状态码。比如，在成功创建资源（比如来自 POST 请求）以后，API 应该返回 HTTP 状态码 201。下面是 TOP 10 常用的 HTTP 状态码列表:</p><p><strong>200 OK</strong><br>普通成功状态码，用于表示成功。<br><strong>201 CREATED</strong><br>资源创建成功（通过 POST 或 PUT）。将响应头中的 Location 字段设置为标识新资源的连接，响应体可有可无。<br><strong>204 NO CONTENT</strong><br>成功，但响应正文中没有任何内容，通常用于 DELETE 和 PUT 操作。<br><strong>400 BAD REQUEST</strong><br>处理请求时出现不合法的状态时的一般错误码。比如，数据格式错误、域名解析错误等。<br><strong>401 UNAUTHORIZED</strong><br>未携带或携带了错误的鉴权 token 时的错误码。<br><strong>403 FORBIDDEN</strong><br>用户没有认证权限执行该操作，或者资源不能被访问时的错误码。<br><strong>404 NOT FOUND</strong><br>找不到指定的资源时的错误码。不管是真的不存在或者存在 401 或 403，服务出于安全方面的考虑需要屏蔽。<br><strong>405 METHOD NOT ALLOWED</strong><br>请求的 URL 存在但不支持请求中的 HTTP 方法访问。比如 POST /users/12345，API 若不支持使用 POST 方法，返回 405 是必须设置 Allow 字段，诸如 GET, PUT, DELETE。<br><strong>409 CONFLICT</strong><br>执行请求时出现资源冲突。比如尝试创建相同信息的两个用户，或者不支持级联删除时删除根对象。<br><strong>500 INTERNAL SERVER ERROR</strong><br>不要故意返回 500 错误。服务端出现问题时会抛 500 错误，这种错误客户端无法解决。</p></li><li><p>同时支持 JSON 和 XML（JSON 大行其道，这个有待考量）</p><p>在不是很复杂的情况下，尽可能同时提供对 JSON 和 XML 的支持。理想情况下，让客户端采用 Accpet 字段指定格式，或者将 URL 上的 .xml 换成 .json 即可。<br>虽然我们建议支持 XML，但是除非必须，请尽量保持 XML 和 JSON 一样的简单实用。也就是说，XML 中也不支持架构和命名空间这些细节，只有数据和连接。如果完整支持 XML，其代价往往是高昂的。根据我们的实战经验，过去几年几乎没有使用过 XML 响应了，对于服务和客户端来讲都显得过于重了。<br>如果非要支持类似命名空间这些功能，JSON-Schema也是可以提供的。</p></li><li><p>创建细粒度资源<br>在最开始最好依托于底层应用程序和数据库的API来创建具有 CRUD 功能的资源，然后再利用小的资源构建更大的资源。</p></li><li>考虑连通性<br>通过超链接实现连通性是 REST 的一个重要原则。虽然不具备连通性的时候，服务依然是可用的，但是如果在响应中带有连接，那么 API 变得更具有自我描述性。至少我们可以通过链接通知客户端如何检索数据，还有，利用 HTTP Location 头域返回客户端通过 POST （或 PUT）创建的资源的连接。在支持分页响应时，”first”，”last”，”next”和”prev”非常有用。</li></ul>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/10/21/rest/#disqus_thread</comments>
    </item>
    
    <item>
      <title>同步与互斥</title>
      <link>http://wzlovegit.github.io/2018/10/01/lock/</link>
      <guid>http://wzlovegit.github.io/2018/10/01/lock/</guid>
      <pubDate>Mon, 01 Oct 2018 01:15:00 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;随着计算机科学和实践的发展，多线程、多进程编程早已是后台工程师（无论框架还是服务器或是业务）需要熟知的重要基础知识之一。这个技术帮助工程师最大限度的利用冯诺依曼型计算机的资源，然而该技术在给资本家节约成本（当然也会提升人民生活的便利）的同时，提升了
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>随着计算机科学和实践的发展，多线程、多进程编程早已是后台工程师（无论框架还是服务器或是业务）需要熟知的重要基础知识之一。这个技术帮助工程师最大限度的利用冯诺依曼型计算机的资源，然而该技术在给资本家节约成本（当然也会提升人民生活的便利）的同时，提升了工程师编码的复杂度。</p></blockquote><p><strong>摘要</strong> 本文着重讨论多线程、多进程编程中的同步与互斥。<strong>名词解释</strong>部分对本文涉及到的重要名词进行说明，<strong>问题研讨</strong>部分对同步与互斥这一经典问题进行描述。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li><p><strong>定义</strong></p><p>计算机中的资源指的是操作系统管理的抽象资源。比如：内存、IO、CPU、锁等。</p></li></ul><h2 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h2><ul><li><p><strong>定义</strong></p><p>多道程序（多进程、多线程）系统中，一次只允许一道程序（一个线程、一个进程）使用的资源，称为<strong>临界资源</strong>。</p></li><li><p><strong>调皮一下</strong></p><p>现在假设厕所只有一个坑，小 A 占用的时候，小 B 只能等；小 B 占用的时候，小 A 只能等。厕所的坑是一个解决问题的重要资源，然而却不能被小 A 和小 B 同时使用，那么这个坑就是<strong>临界资源</strong>。</p><blockquote><p><strong>想法</strong>：计算机科学衍生自人类本身的经验科学和数学科学，因此有很多名词和编码理念取材于日常生活。而且计算机科学又非常高效地反馈了人类，取材于日常生活的理念，快速应用到解决日常问题。</p></blockquote></li></ul><h2 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h2><ul><li><strong>定义</strong><br>操作系统（Operation System）是计算机的管家，管理着这台计算机的全部资源。应用程序在运行过程中需要的资源均需向 OS 申请并且及时归还。多道程序申请一个临界资源的情况，称为<strong>竞争</strong>。</li></ul><h2 id="独立进程（或线程）"><a href="#独立进程（或线程）" class="headerlink" title="独立进程（或线程）"></a>独立进程（或线程）</h2><ul><li><strong>定义</strong><br>自身状态与其他进程（或线程）无关并且其他进程不会影响自身状态的进程（或线程），称为<strong>独立进程（或线程）</strong>。</li></ul><h2 id="合作进程（或线程）"><a href="#合作进程（或线程）" class="headerlink" title="合作进程（或线程）"></a>合作进程（或线程）</h2><ul><li><strong>定义</strong><br>进程执行过程中影响其他进程（或线程）状态或被其他进程（或线程）影响自身状态，称为<strong>合作进程（或线程）</strong>。</li></ul><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><ul><li><strong>定义</strong><br>在多道系统中，合作进程（或线程）按照某种事先规定的序列完成任务的过程称为<strong>同步</strong>。</li></ul><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><ul><li><p><strong>定义</strong><br>在多道系统中，合作进程（或线程）对临界资源的排他访问，称为<strong>互斥</strong>。</p></li><li><p><strong>调皮一下</strong><br>小 A 和小 B 属于合作进程。他们需要按照既定的顺序解决问题：小 A 先上或者小 B 先上。小 A 先上的话，小 B 只能等待小 A 出来，小 B 遵守了厕所坑互斥的约定，按照次序解决问题，这就是同步。</p></li></ul><blockquote><p><strong>想法</strong>，同步与互斥是两个非常独立的概念，然而却经常理解混乱。其一，多道程序为了完成同步需要一些互斥手段。其二，自然语言解释抽象概念本身就捉襟见肘。</p></blockquote><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul><li><strong>定义</strong><br>一种由资源管理者提供的资源，用于正确地访问临界资源。</li></ul><h1 id="问题研讨"><a href="#问题研讨" class="headerlink" title="问题研讨"></a>问题研讨</h1><p>由于互斥是同步的一个重要手段，我们从互斥入手去展开这一主题的介绍。锁在为多道程序正确地访问临界资源提供支持的同时，也加大了编写正确多道程序的难度。</p><h2 id="多道程序的活跃性问题"><a href="#多道程序的活跃性问题" class="headerlink" title="多道程序的活跃性问题"></a>多道程序的活跃性问题</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li><p><strong>定义</strong><br>集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。死锁会进一步引起服务挂起，无法正常处理业务。</p></li><li><p><strong>调皮一下</strong><br>教科书爱用哲学家用餐问题引入介绍死锁，然而作为市井打工仔，我没见过科学家，因此这里换个日常生活中常见的死锁。一次下班回家，在一个交通转盘上就发生了严重的交通死锁，看到一辆救护车的悲鸣，心里很是触动。死锁如下：</p><img src="/2018/10/01/lock/Deadlock.jpg"></li><li><p><strong>死锁产生</strong><br>从上面的例子我们可以看到死锁产生需要4个必要条件：</p><ol><li><strong>互斥</strong>：进程对临界资源排他性占用，若进程 P1 持有临界资源，则进程 P2 请求临界资源时需要等待，直到 P1 释放该资源，P2 才能获取。上图中，路口就是临界资源，同时只能由1辆车通过。</li><li><strong>请求和占有</strong>：进程 P1 在请求资源 R1 的同时还独占资源 R2，进程 P2 在请求资源 R2 的同时还独占资源 R1。上图中，每个方向的车队都是在请求自己的通行路口，同时还独占另外一个车队的通行路口。</li><li><strong>不可抢占</strong>：进程 P1 获得的资源 R1 在未自己释放之前不可由进程 P2 抢夺。每个车队都没有执法权可以让另一个车队让出一个路口。</li><li><strong>循环等待</strong>：进程资源环形链路。车队和路口出现了一个环形。</li></ol><p>上述四个条件为死锁产生的必要不充分条件：即死锁 -&gt; 互斥，死锁 -&gt; 请求和保持，死锁 -&gt; 请求和占有，死锁 -&gt; 循环等待，反过来则不成立。</p></li><li><p><strong>问题解决方案</strong></p><p>科学家给出了科学结论和理论上可行的方案：</p><ol><li><strong>死锁预防</strong><br>破坏死锁产生的4个必要条件之一，则就不会发生死锁。<strong>有序资源分配法</strong>是非常典型的一种死锁预防算法，它破坏了<strong>循环等待</strong>条件。<br><strong>有序资源分配算法</strong>即进程在获取多个资源的时候需要事先规定好的顺序获取，比如进程 P1 和 P2 需要资源 R1 R2 完成工作，如果 P1 占有 R1 申请 R2，P2 占有 R2 申请 R1 就会出现死锁。若我们事先规定进程获取资源的顺序为 R1 R2，那么进程 P2 在申请 R2 之前需先申请 R1，若 R1 申请不到则其无法持有 R2。因此不会产生死锁。</li><li><strong>死锁避免</strong><br>系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的<strong>动态策略</strong>。<strong>银行家算法</strong>是典型的死锁避免算法。<br><strong>银行家算法</strong>比较复杂，很难三言两语解释清楚，请见。由于申请资源者并非一次性将自己所需的最大资源数全部从银行家手里获取，因此会有虽然银行家手里有资源，但是并不能向外分配的情况。此时需要检测是否存在进程安全序列。</li><li><strong>死锁检测</strong><br>允许死锁发生，然后检测到进程发生死锁，再去干预。在交通图中，检测到死锁，右下角的警车到达，经过疏导完成了解锁。检测策略实现起来比较有难度。</li></ol><blockquote><p><strong>想法</strong>在日常业务开发中，通过业务拆分，通常多个进程竞争一个临界资源，不会出现多个临界资源，因此直接不满足死锁必要条件的<strong>请求和占有</strong>。如果真遇到多个临界资源的竞争，则需要引入<strong>有序资源分配法</strong>（由于资源有序，导致业务上的串行，影响性能），<strong>银行家算法</strong>（动态分配资源，实现略显复杂，提高并发性）。</p></blockquote><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3></li><li><p><strong>定义</strong></p><p>进程的等待时间给进程的响应时间带来明显影响，称为<strong>进程饥饿</strong>。若一直等待到即使完成该任务也毫无意义的时候，则称为<strong>饥饿死亡</strong>。</p></li><li><p><strong>调度算法</strong><br>进程和线程调度均由 OS 来完成，但业务相关任务调度则由工程师控制，因此调度算法也是工程师需要掌握的技术手段。下面介绍 6 种典型的进程调度算法（当然可以应用到任务调度当中），它们均是抢占式、非抢占式调度算法：</p><ol><li><strong>FCFS (First Come First Serve) 先来先服务</strong><ul><li>任务按照先来先服务原则执行（俗话所说的按照先来后到）</li><li>基于 FIFO 队列，实现简单</li><li>平均等待时长较长（老师常说的，你耽误课堂一分钟，整个教室 60 个人，你就耽误了 60 分钟）</li></ul></li><li><strong>SJN (Short Job Next) 短作业优先</strong><ul><li>任务按照短作业优先原则执行</li><li>平均等待时长最短（可以证明）</li><li>适合预先知道处理时长的批处理系统，不适合预先不知道处理时长的交互式系统</li><li>系统需要实现知道处理时长</li></ul></li><li><strong>Priority Scheduling 优先级调度</strong><ul><li>批处理系统中的常用调度算法</li><li>按照任务优先级处理，同一优先级按照 FCFS 处理</li></ul></li><li><strong>Shortest Remaining Time 最少剩余时间</strong></li><li><strong>Round Robin(RR) Scheduling 轮询调度</strong><ul><li>每个任务获取一个固定的执行时间，时间到则切换下一个任务</li></ul></li><li><strong>Multiple-Level Queue Scheduling 多级队列调度</strong></li></ol></li></ul><p>调度也是一个研究方向，值得庆幸的是科学家已经提供了很多行之有效的经典方案。Quartz 就是一个分布式调度框架，最近也用到了我们的项目中。</p><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><ul><li><p><strong>定义</strong></p><p>活锁指的是任务或者执行者没有被阻塞，只是由于某种原因导致执行者一直重复尝试-失败，尝试-失败。</p></li><li><p><strong>实例</strong><br>活锁会导致虽然线程没有阻塞，但却什么都完成不了。比如执行任务的过程中，若遇到失败任务则重试，那么就有可能一直重试下去。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>锁是实现互斥的一种手段；互斥是程序执行过程中对临界资源访问的一种保证正确性的手段；同步需要 A 等待 B 完成才能继续执行，A 得知 B 已经完成的手段的一种方式就是访问一个临界资源。</p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/10/01/lock/#disqus_thread</comments>
    </item>
    
    <item>
      <title>curator</title>
      <link>http://wzlovegit.github.io/2018/09/28/curator%20lock/</link>
      <guid>http://wzlovegit.github.io/2018/09/28/curator%20lock/</guid>
      <pubDate>Fri, 28 Sep 2018 01:15:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Curator&quot;&gt;&lt;a href=&quot;#Curator&quot; class=&quot;headerlink&quot; title=&quot;Curator&quot;&gt;&lt;/a&gt;Curator&lt;/h1&gt;&lt;p&gt;Apache Curator 是 Apache Zookeeper 的一个客户端库。它封装了底层 A
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Curator"><a href="#Curator" class="headerlink" title="Curator"></a>Curator</h1><p>Apache Curator 是 Apache Zookeeper 的一个客户端库。它封装了底层 Apache Zookeeper 客户端 API，为用户提供了更加简便可靠的高级 API 和一些常用工具。 除此之外，它还提供了常见场景的实现（比如选主、分布式锁等）以及一些扩展（比如服务发现）。</p><p>curator-recipes 为我们提供了几种常用场景的解决方案和实现，本文着重介绍这些工具的用法以及实现原理。</p><h1 id="Elections-选主"><a href="#Elections-选主" class="headerlink" title="Elections (选主)"></a>Elections (选主)</h1><p>日常生活中，一个稍微繁杂一些的工作，通常需要多人协作，多人协作时通常存在一个 leader 负责根据每个人的状况分发任务；那么就需要大家推举出一个让人信服的 leader，不能搞小团体，这样才能高效完成任务。在分布式系统中，通常也需要推举出一个 leader 完成整个系统的协同。</p><blockquote><p>选主（leader election）是指分布式系统中各个节点推举出一个节点作为整个系统的组织者，进而协同各个节点的状态，协调分布式任务。</p></blockquote><h2 id="应用场景举例"><a href="#应用场景举例" class="headerlink" title="应用场景举例"></a>应用场景举例</h2><ol><li>监控</li></ol><p>因为 leader 节点需要协同整个系统，所以及时获取系统中各个 non-leader 节点的状态是很重要的。因此 leader 节点会监控整个系统节点的状态。<br>比如在一个分布式计算系统中，调度模块将任务下发给 leader 节点，leader 节点在分发任务的时候，首先要确保 non-leader 计算节点的状态正常，才会下发计算任务；否则，就会引起数据丢失，计算失败。</p><ol><li>调度</li></ol>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/09/28/curator%20lock/#disqus_thread</comments>
    </item>
    
    <item>
      <title>记几次有意思的问题诊断</title>
      <link>http://wzlovegit.github.io/2018/08/05/question%20ananlysis/</link>
      <guid>http://wzlovegit.github.io/2018/08/05/question%20ananlysis/</guid>
      <pubDate>Sun, 05 Aug 2018 06:38:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CLOSE-WAIT&quot;&gt;&lt;a href=&quot;#CLOSE-WAIT&quot; class=&quot;headerlink&quot; title=&quot;CLOSE_WAIT&quot;&gt;&lt;/a&gt;CLOSE_WAIT&lt;/h1&gt;&lt;p&gt;服务端出现 CLOSE_WAIT 状态，必然是某些原因导致服务端 socke
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h1><p>服务端出现 CLOSE_WAIT 状态，必然是某些原因导致服务端 socket 未关闭， FIN 包未发送到客户端，所以一直处于 CLOSE_WAIT 状态。打印 jstack 发现有大量的相同堆栈，均由同步 RPC 调用未能及时返回引起。</p><h1 id="Jedis连接到slave服务器"><a href="#Jedis连接到slave服务器" class="headerlink" title="Jedis连接到slave服务器"></a>Jedis连接到slave服务器</h1><p>服务端采用哨兵+主备方案部署，客户端采用 Jedis 连接。测试反应数据无法写入 redis，一直打印 READONLY异常。登录 redis，info 查看连接节点角色为 slave。因此怀疑主备切换之后 Jedis 客户端未能感知到。通过 Jedis 源代码得知 redis 主备切换后哨兵会将主备切换的信息 pub 到 +switch-master 这个主题， Jedis 客户端订阅该主题，在获取到主备切换信息之后关闭当前所有 Jedis 连接，跟新的主节点建立连接。由于测试服务端环境只有一个哨兵，并且 redis 的 pub/sub 模式是发布后需要直接消费，否则就会丢失，造就了 Jedis 客户端未能发现主备切换，引起客户端连接在了从节点。</p><h1 id="kafka无业务状态下流量和CPU较高"><a href="#kafka无业务状态下流量和CPU较高" class="headerlink" title="kafka无业务状态下流量和CPU较高"></a>kafka无业务状态下流量和CPU较高</h1><p>现网和测试反应 kafka 在基本没有业务的情况下，网络带宽竟然占用到了 5Mbits/s。问题反馈上来颇感棘手，原因是 kafka 采用 erlang 开发，而我只对 c/c++/Java 有所了解。既然无法直接阅读 kafka 代码，那就从外围分析。首先抓包，查看到的内容都是一些 topic 的名称，然而从我们的常识判断 kafka 这么成熟的商用消息队列不至于出现自身同步都引起巨大流量的问题。采用工具查看流量都从 kafka 不同节点同步消息互相流动。offset 的同步是采用的自动提交方式，每次提交都会触发 offset 同步。排查后发现 offset 的自动提交时间为 100ms，因此引起多个客户端每秒触发 10 次 offset 同步。将 offset 修改为 5000 ms 之后流量和 CPU 都降下来了。</p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/08/05/question%20ananlysis/#disqus_thread</comments>
    </item>
    
    <item>
      <title>简单聊聊Spring State Machine</title>
      <link>http://wzlovegit.github.io/2018/07/25/Spring%20State%20Machine/</link>
      <guid>http://wzlovegit.github.io/2018/07/25/Spring%20State%20Machine/</guid>
      <pubDate>Wed, 25 Jul 2018 13:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;状态机&quot;&gt;&lt;a href=&quot;#状态机&quot; class=&quot;headerlink&quot; title=&quot;状态机&quot;&gt;&lt;/a&gt;状态机&lt;/h1&gt;&lt;p&gt;FSM (Finite State Machine) 有限状态机。学术上 FSM 分为两种类型： Mealy 状态机和 Moore 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h1><p>FSM (Finite State Machine) 有限状态机。学术上 FSM 分为两种类型： Mealy 状态机和 Moore 状态机。</p><ul><li>Mealy 状态机</li></ul><p>output = f ( present_state, input )<br>next_state = f ( present_state, input)</p><ul><li>Moore 状态机</li></ul><p>output = f ( present_state )<br>next_state = f ( present_state, input )</p><p>参见：</p><p><a href="https://www.tutorialspoint.com/automata_theory/moore_and_mealy_machines.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/automata_theory/moore_and_mealy_machines.htm</a></p><h1 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h1><p>Spring State Machine 是事件驱动的，事件可以是定时器事件或者普通事件。上图中，比如状态机目前处于 S1 状态，收到 E1 事件后就切换到 S2 状态；状态机目前处于 S2 状态， 收到 E2 事件后切换到 S3 状态。那么 Spring 状态机是怎么使用计算资源的呢？</p><img src="/2018/07/25/Spring%20State%20Machine/springsm.jpg" title="This is an example image"><p>每个状态机都有一个接收事件的事件队列，每次每个事件触发都会将 Runnable 任务提交到线程池的任务队列。线程从线程池中提取 Runnable 任务，然后执行事件队列中的全部事件。在任务执行的过程中，会首先加锁，不让多个线程同时处理一个事件队列以免引起线程安全问题。</p><h1 id="分布式协作状态机"><a href="#分布式协作状态机" class="headerlink" title="分布式协作状态机"></a>分布式协作状态机</h1><p>Distribute state machine 是借助 Zookeeper 实现的。每次状态发生变化，Spring State Machine 会将状态持久化到 Zookeeper 中，并以 log 的形式记录到 Zookeeper。 由于另一个 State Machine Watch 了 Zookeeper 上 log 的变化，因此它会在 log 发生变化的时候重放 log，以完成两个 State Machine 的同步。这里需要注意，如果状态机中定义的 Action 中存在变量自加的情况，那么重放 log 会导致 Action 中的操作执行多遍，因此我们在设计的时候通常不能在 Action 中执行操作。</p><h1 id="状态机实例化"><a href="#状态机实例化" class="headerlink" title="状态机实例化"></a>状态机实例化</h1><p>初次使用 Spring State Machine，从其 Demo 中只能看到每次启动 Spring 服务只能配置一个 Spring State Machine 实例。这种情况通常不符合我们的业务流程，因为我们会有多个相同的业务同时执行。当然，这不能困住我们啦，把 Spring State Machine 的源代码下下来，就能看到 Builder 模式的创建状态机的方法。</p><h1 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h1><p>经验教训是这将近一月的需求分析、概要设计、详细设计、代码开发到自测阶段不断思考的一些内容。由于并非理论知识，不具备普适性，不具备科学性，所以放在了行文的最后，不妨碍阅读 Spring State Machine 本身的内容。</p><h2 id="如何进行设计？"><a href="#如何进行设计？" class="headerlink" title="如何进行设计？"></a>如何进行设计？</h2><p>设计阶段我们分别进行了业务细节设计、研究 Spring State Machine 的设计、 定时器框架 Quarz 的设计。设计阶段没有达到预期的原因，我认为有以下几个点需要自己以后注意：</p><ol><li>设计仓促</li></ol><p>需求分析和可行性分析是最不能节省时间的。这里的仓促需要我花更多的时间和更多的精力买单。时间紧张是一个比较客观的原因。</p><ol><li>缺少沟通</li></ol><p>骨子里认为开会是个浪费时间的动作，但设计阶段的会议必不可少，一天一次或者一天两次都不为过。沟通的过程是需要和大家不断澄清方案合理性的过程，而且不间断的沟通可以激起负责人的主人翁精神，调动起大家的积极性是愉快工作必不可少的环节。</p><ol><li>缺少信任</li></ol><p>事必躬亲是非常错误的，是一种事倍功半的做法。首先一个人精力有限，其次一个人必有局限。充分信任同事，不断沟通结果才是提高生产力的法则。比如，如果不信任 Spring 的代码质量，那么项目从 0 开始，将是非常巨大的成本。信任同事，一起查看设计和开发结果，对不合理的地方不断完善，既可以减轻事必躬亲带来的压力和巨大工作量，又可以让大家都有主人翁精神。</p><h2 id="如何分工合作？"><a href="#如何分工合作？" class="headerlink" title="如何分工合作？"></a>如何分工合作？</h2><p>需求一下来，我立马拉上组内相关同事进行了一个针对性的拆解分工。因为每个人技术背景不同，所以起初我的想法是每两个同事关注一个重要的点，每个同事关注两个重要的点，即下图的形式：</p><img src="/2018/07/25/Spring%20State%20Machine/project_teamwork.jpg" title="This is an example image"><p>此时大家可以分工调研各自重点关注和辅助关注的模块了。分工上基本是合理的。就是缺少了沟通。沟通是分工合作非常需要关注的一个点。下次牵头做设计，必然要每天沟通，记录进度和结果。</p><h2 id="如何保证质量？"><a href="#如何保证质量？" class="headerlink" title="如何保证质量？"></a>如何保证质量？</h2><p>把信任给了同事，那么质量如何保证。这就又体现了沟通的重要性。不是大家能力问题，而是不同技术背景，开发习惯等会引起一些低级问题。开会 review 是提升大家编码水平的一个重要渠道。</p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/07/25/Spring%20State%20Machine/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JWT简介</title>
      <link>http://wzlovegit.github.io/2018/06/23/JWT/</link>
      <guid>http://wzlovegit.github.io/2018/06/23/JWT/</guid>
      <pubDate>Sat, 23 Jun 2018 02:34:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1-JSON-Web-Tokens&quot;&gt;&lt;a href=&quot;#1-JSON-Web-Tokens&quot; class=&quot;headerlink&quot; title=&quot;1 JSON Web Tokens&quot;&gt;&lt;/a&gt;1 JSON Web Tokens&lt;/h1&gt;&lt;p&gt;JSON Web T
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="1-JSON-Web-Tokens"><a href="#1-JSON-Web-Tokens" class="headerlink" title="1 JSON Web Tokens"></a>1 JSON Web Tokens</h1><p>JSON Web Tokens(JWT)是一个紧凑的自包含的用于多方安全传输信息的开放标准。由于JWT具有数字签名（可用对称密钥和非对称密钥进行签名），因此JWT传输的信息可以被认证和信任。</p><blockquote><p>数字签名： 用户Alice采用非对称密钥加密算法生成一对公钥和私钥；Alice将公钥公诸于世，私钥只有自己知道。此时Alice就可以采用自己的私钥将一段信息进行加密。其他人只有用Alice的公钥才能解密这一段信息。因此其他人就可以判定该信息由Alice发布，即具有Alice的数字签名。</p></blockquote><p>虽然JWT可以在加密信道传输，但是我们依然要关注JWT的签名。签名可以用于验证信息没有被篡改，并且可以判断发送者的身份。</p><h1 id="2-JWT应用场景"><a href="#2-JWT应用场景" class="headerlink" title="2 JWT应用场景"></a>2 JWT应用场景</h1><ul><li><p>认证</p><p>JWT最常用的场景就是认证。一旦用户正确登录，则其后续的请求都必须携带JWT。根据JWT判断是否允许用户访问受保护的路由、服务和资源。<br>由于JWT的轻量级和在不同领域的易传输性使其广泛应用于SSO（Signle Sign On）单点登录。</p></li></ul><blockquote><p>SSO：单点登录，用户完成认证后，在访问整个系统的其他服务时，只需携带令牌，无需重新登录。</p></blockquote><ul><li><p>信息交换</p><p>JWT可用于多方信息安全传输。因为JWT是被签名的，因此可以判断发送者身份，并且可判断消息是否被篡改。</p></li></ul><h1 id="3-JWT-结构"><a href="#3-JWT-结构" class="headerlink" title="3 JWT 结构"></a>3 JWT 结构</h1><p>紧凑型JWT包含三个部分，并且用点分隔，类似于xxx.yyy.zzz。</p><ul><li><p>Header</p><p>头部通常包括两部分：类型和哈希算法<br>{<br>  “alg” : “HS256”<br>  “typ” : “JWT”<br>}<br>将这个JSON经过Base64Url编码后生成JWT的header</p></li><li><p>Payload</p><p>负载包含三个部分：注册声明、公共声明和私有声明<br>注册声明包含一些推荐但不强制使用的预定义字段，提供注册该Token的相关信息。比如：iss（签发者），exp（过期时间），sub（使用者）等。<br>公共声明<br>私有声明是多方协商好携带信息的字段。<br>{<br>“sub” : “123”<br>“name” : “John”<br>“admin” : true<br>}</p><p>将这个JSON经过Base64Url编码后生成JWT的payload</p></li><li><p>Signature</p><p>签名是用加密算法生成编码后header和payload的摘要。比如：<br>HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)<br>签名用于鉴定信息是否被篡改，并且可以判断发送者身份。</p></li></ul><h1 id="4-JWT如何工作"><a href="#4-JWT如何工作" class="headerlink" title="4 JWT如何工作"></a>4 JWT如何工作</h1><p>认证时，当用户登录系统，会为其返回一个JWT。JWT也是证书，因此需要保护好它的安全性。通常在用完JWT后即释放。</p><p>当用户访问受保护的路由活资源时，用户代理同时需要将JWT发送过去。通常JWT令牌放在Authorization头的Bearer主题下。</p><blockquote><p>Authorization: Bearer \<token></token></p></blockquote><p>JWT在某些情况下是无状态认证机制。服务器认证JWT通过之后就会让其访问受保护的资源。如果JWT包含一些必要的数据，那么可以减少对数据库的查询操作。</p><p>如果token在Authorization头中发送，那么跨域资源共享（CORS）就不存在问题，因为他们不是cookie。</p><p>下图是JWT官网的图：<br><img src="/2018/06/23/JWT/client-credentials-grant.png" title="client-credentials-grant.png"></p><ol><li>应用或客户端发送认证请求到认证服务器。</li><li>认证通过，认证服务器给应用返回一个访问令牌</li><li>应用程序使用访问令牌访问服务端受保护的资源</li></ol><p>注意：JWT中的所有信息都可以被所有人获取，因此JWT不应该存储密钥信息。</p><h1 id="5-为什么选择JWT"><a href="#5-为什么选择JWT" class="headerlink" title="5 为什么选择JWT"></a>5 为什么选择JWT</h1><ul><li>JSON比XML冗余小，更紧凑，适合在HTML和HTTP环境</li><li>JWT相比于SWT，可以使用非对称加密算法。相比于SAML更加简单清晰</li><li>JSON格式平台兼容性更好</li></ul>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/06/23/JWT/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Mosquitto源码分析</title>
      <link>http://wzlovegit.github.io/2018/05/21/mosquittio%20source%20code/</link>
      <guid>http://wzlovegit.github.io/2018/05/21/mosquittio%20source%20code/</guid>
      <pubDate>Mon, 21 May 2018 08:30:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;[Mosquitto简介]这篇文章介绍了Mosquitto的基本功能。本文在此基础上，对Mosquitto的内核实现进行简单总结。文章只对M
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>[Mosquitto简介]这篇文章介绍了Mosquitto的基本功能。本文在此基础上，对Mosquitto的内核实现进行简单总结。文章只对Mosquitto概要设计进行分析，不深入代码细节。</p><h1 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h1><p>Mosquitto对socket连接的管理和redis等其他开源c软件大同小异，均采用反应堆模式（可参考<a href="http://www.cnblogs.com/xujian2014/p/5711828.html）。事件驱动是反应堆的核心。" target="_blank" rel="noopener">http://www.cnblogs.com/xujian2014/p/5711828.html）。事件驱动是反应堆的核心。</a></p><h2 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h2><p>事件指I/O、定时器等事件。一个新的客户端连接服务器，就会触发监听socket的可读事件；客户端向服务器发送消息，就会触发客户端与服务器之间这个socket的可读事件；服务器想向客户端发送消息，那么服务器会去触发客户端与服务器之间这个socket的可写事件。</p><p>由上图，事件驱动模型有3大部件：1，事件收集器；2，事件发送器；3，事件处理器。在C语言编写的服务器里面，事件收集器的工作通常由select、poll或epoll这类多路复用IO承担。事件发送器通常在与多路复用IO同一个应用线程当中实现，即将收集的事件分发到不同的事件队列。事件处理器通常是与多路复用IO不同的一些线程，这些线程从事件队列中获取事件，并根据事件类型执行响应的事件处理函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mosquitto_main_loop</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">while (run)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">fdcount = epoll_wait(db-&gt;epollfd, events, MAX_EVENTS, 100);</span><br><span class="line">...</span><br><span class="line">ev.data.fd = net__socket_accept(db, listensock[j])</span><br><span class="line">...</span><br><span class="line">loop_handle_reads_writes(db, events[i].data.fd, events[i].events);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码片为简化版的1.5.0的Mosquitto的主循环实现。代码中清晰的分辨出事件收集器epoll，事件发送器loop_handle_reads_writes。事件处理器则在其他线程执行不同事件的处理函数。</p><p>为什么称为事件驱动呢？驱动是指事物本身是静止状态，在驱动的驱使下发生变动。由上述代码片，若没有事件发生，那么只有while循环这一个线程在空转，事件处理器处于全体静止状态。事件发生，则会处罚事件处理器执行事件的处理函数。因此说，整个的server是事件驱动的。</p><h2 id="客户端对象"><a href="#客户端对象" class="headerlink" title="客户端对象"></a>客户端对象</h2><p>c 语言虽然不是面向对象的语言，但开源项目中通常看到对象的影子。面向对象思想包含 3 个重要特性：封装、继承、多态。<br>封装性在 c 语言中采用 struct 结构体模拟。之所以叫模拟是因为 c 语言中 struct 不具备成员变量可见性控制；私有成员函数采用在 .c 文件中的 static 方法实现，对外接口则声明到头文件中。继承和多态在 c 语言中需要采用 void * 指针、回调函数、自定义虚函数表来模拟。虽然是模拟，但是 c 语言并不是面向对象语言。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">struct mosquitto &#123;</span><br><span class="line">mosq_sock_t sock;</span><br><span class="line">#ifndef WITH_BROKER</span><br><span class="line">mosq_sock_t sockpairR, sockpairW;</span><br><span class="line">#endif</span><br><span class="line">#if defined(__GLIBC__) &amp;&amp; defined(WITH_ADNS)</span><br><span class="line">struct gaicb *adns; /* For getaddrinfo_a */</span><br><span class="line">#endif</span><br><span class="line">... 客户端接收包所需的数据结构</span><br><span class="line">#ifdef WITH_TLS</span><br><span class="line">...</span><br><span class="line">#endif</span><br><span class="line">bool want_write;</span><br><span class="line">bool want_connect;</span><br><span class="line">#if defined(WITH_THREADING) &amp;&amp; !defined(WITH_BROKER)</span><br><span class="line">...</span><br><span class="line">#endif</span><br><span class="line">bool clean_session;</span><br><span class="line">#ifdef WITH_BROKER</span><br><span class="line">... 服务端端用于存储 msg 的结构</span><br><span class="line">#  ifdef WITH_WEBSOCKETS</span><br><span class="line">...</span><br><span class="line">#  endif</span><br><span class="line">bool ws_want_write;</span><br><span class="line">#else</span><br><span class="line">#  ifdef WITH_SOCKS</span><br><span class="line">... SOCKS协议控制</span><br><span class="line">#  endif</span><br><span class="line">... 登录登出、收发包等的回调</span><br><span class="line">#  ifdef WITH_SRV</span><br><span class="line">ares_channel achan;</span><br><span class="line">#  endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef WITH_BROKER</span><br><span class="line">... handle</span><br><span class="line">#endif</span><br><span class="line">#ifdef WITH_EPOLL</span><br><span class="line">uint32_t events;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>struct mosquitto 结构中包含了 #ifdef WITH_BROKER，因为在 Mosquitto 的设计中，在实现 server 的同时也实现了 client 的 lib 库。<br>包括 redis 在内，开源软件中很多 server 中都会对客户端进行抽象。这些客户端对象很方便管理各个客户端的状态、数据等。</p><h1 id="服务器数据结构"><a href="#服务器数据结构" class="headerlink" title="服务器数据结构"></a>服务器数据结构</h1><p>Mosquitto 的实现，AWS IoT 对 MQTT 的支持，阿里 IoT 对 MQTT 的支持，均关注一个非常重要的指标：消息转发。与消息中间件（比如 Kafka ）不同，Mosquitto 更加关注消息转发效率而非消息吞吐量。</p><h2 id="订阅树"><a href="#订阅树" class="headerlink" title="订阅树"></a>订阅树</h2><p>Mosquitto 的订阅树采用的是孩子兄弟表示法。与平时见到的实现不同，为了快速找到某个 topic 上的订阅者，它采用了 hash 表来加速查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">struct mosquitto__subleaf &#123;</span><br><span class="line">struct mosquitto__subleaf *prev;</span><br><span class="line">struct mosquitto__subleaf *next;</span><br><span class="line">struct mosquitto *context;</span><br><span class="line">int qos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct mosquitto__subhier &#123;</span><br><span class="line">UT_hash_handle hh;</span><br><span class="line">struct mosquitto__subhier *parent;</span><br><span class="line">struct mosquitto__subhier *children;</span><br><span class="line">struct mosquitto__subleaf *subs;</span><br><span class="line">struct mosquitto_msg_store *retained;</span><br><span class="line">mosquitto__topic_element_uhpa topic;</span><br><span class="line">uint16_t topic_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct UT_hash_bucket &#123;</span><br><span class="line">   struct UT_hash_handle *hh_head;</span><br><span class="line">   unsigned count;</span><br><span class="line">   unsigned expand_mult;</span><br><span class="line"></span><br><span class="line">&#125; UT_hash_bucket;</span><br><span class="line"></span><br><span class="line">typedef struct UT_hash_table &#123;</span><br><span class="line">   UT_hash_bucket *buckets;</span><br><span class="line">   unsigned num_buckets, log2_num_buckets;</span><br><span class="line">   unsigned num_items;</span><br><span class="line">   struct UT_hash_handle *tail; /* tail hh in app order, for fast append    */</span><br><span class="line">   ptrdiff_t hho; /* hash handle offset (byte pos of hash handle in element */</span><br><span class="line">   unsigned ideal_chain_maxlen;</span><br><span class="line">   unsigned nonideal_items;</span><br><span class="line">   unsigned ineff_expands, noexpand;</span><br><span class="line"></span><br><span class="line">   uint32_t signature; /* used only to find hash tables in external analysis */</span><br><span class="line">#ifdef HASH_BLOOM</span><br><span class="line">   uint32_t bloom_sig; /* used only to test bloom exists in external analysis */</span><br><span class="line">   uint8_t *bloom_bv;</span><br><span class="line">   char bloom_nbits;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; UT_hash_table;</span><br><span class="line"></span><br><span class="line">typedef struct UT_hash_handle &#123;</span><br><span class="line">   struct UT_hash_table *tbl;</span><br><span class="line">   void *prev;                       /* prev element in app order      */</span><br><span class="line">   void *next;                       /* next element in app order      */</span><br><span class="line">   struct UT_hash_handle *hh_prev;   /* previous hh in bucket order    */</span><br><span class="line">   struct UT_hash_handle *hh_next;   /* next hh in bucket order        */</span><br><span class="line">   void *key;                        /* ptr to enclosing struct&apos;s key  */</span><br><span class="line">   unsigned keylen;                  /* enclosing struct&apos;s key len     */</span><br><span class="line">   unsigned hashv;                   /* result of hash-fcn(key)        */</span><br><span class="line">&#125; UT_hash_handle;</span><br></pre></td></tr></table></figure><p>订阅树中订阅节点采用双向链表实现。孩子兄弟表示法隐藏在handle数据结构中。从下图可以清晰得看出订阅树的数据结构。MQTT 主题采用目录结构形式，天然是树形结构，因此订阅主题采用订阅树的结构非常合适。Hash 表可以提升树形结构的查询效率。目前用不上，不做详细分析。</p><img src="/2018/05/21/mosquittio%20source%20code/mosquitto_subhier.jpg"><img src="/2018/05/21/mosquittio%20source%20code/UT_hash_handle.jpg"><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文描述了 C 语言开发的事件驱动模型以及 mosquitto 的订阅树结构。若需要更加深入的使用 mosquitto 则可以沿此思路继续深入。</p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/05/21/mosquittio%20source%20code/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Mosquitto简介</title>
      <link>http://wzlovegit.github.io/2018/05/15/mosquttio%20cook/</link>
      <guid>http://wzlovegit.github.io/2018/05/15/mosquttio%20cook/</guid>
      <pubDate>Tue, 15 May 2018 01:15:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;p&gt;Mosquitto是实现了MQTT协议3.1和3.1.1版本的一个消息服务器的开源实现。Mosquitto是轻量级的，它的应
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>Mosquitto是实现了MQTT协议3.1和3.1.1版本的一个消息服务器的开源实现。Mosquitto是轻量级的，它的应用平台囊括从低电量的单片机到所有服务器。</p><p>MQTT协议基于<strong>publish/subscribe(发布/订阅)</strong>模型提供了轻量级的携带消息的方法。这就为传感器、移动设备（比如手机）、嵌入式设备接入互联网提供了可能。</p><p>Mosquitto提供了实现MQTT客户端的C库，并且提供了<strong>mosquitto_pub</strong> 和 <strong>mosquitto_sub</strong>的命令行实现。</p><h1 id="2-MQTT"><a href="#2-MQTT" class="headerlink" title="2 MQTT"></a>2 MQTT</h1><h2 id="2-1-描述"><a href="#2-1-描述" class="headerlink" title="2.1 描述"></a>2.1 描述</h2><p>MQTT是一个轻量级的发布/订阅协议。在低电量传感器中非常有用，但它也可以用于很多其他场景。</p><h2 id="2-2-发布-订阅"><a href="#2-2-发布-订阅" class="headerlink" title="2.2 发布/订阅"></a>2.2 发布/订阅</h2><p>MQTT协议基于”pub/sub”即发布/订阅模型。客户端连接到服务器（broker）并且订阅它们感兴趣的主题（topics），除此之外，客户端也会连接到服务器并且发布消息到主题。不同的客户端可以订阅相同的主题。MQTT服务器就像一个接口一样供大量不同设备接入。</p><h2 id="2-3-主题-订阅"><a href="#2-3-主题-订阅" class="headerlink" title="2.3 主题/订阅"></a>2.3 主题/订阅</h2><p>MQTT的主题结构是一种类似于文件系统的层级格式，每一层采用”/“分隔。与此同时，MQTT提供了”+”和”#”通配符，这就为客户端订阅相似的主题提供了便利。</p><ul><li>： 单一层级的通配符<br># ： 多层级通配符  </li></ul><p>比如：设备将温度发送到主题<strong>sensors/COMPUTER_NAME/temperature/HARDDRIVE_NAME</strong>中,如果我们想要订阅所有设备的温度变化，则可以订阅<strong>sensors/+/temperature/+</strong>这个主题。</p><p>又比如订阅<strong>a/b/c/d</strong>这个主题，那么以下几种方式都可以订阅到：</p><p>a/b/c/d<br>+/b/c/d<br>a/+/c/d<br>a/+/+/d<br>+/+/+/+</p><p>a/b/c/d<br>#<br>a/#<br>a/b/#<br>a/b/c/#<br>+/b/c/#</p><p>不要提供长度为0的层级主题。</p><h2 id="2-4-服务质量QoS"><a href="#2-4-服务质量QoS" class="headerlink" title="2.4 服务质量QoS"></a>2.4 服务质量QoS</h2><p>MQTT提供了3个等级的QoS，每个等级对于可达性的要求不同。消息可以采用任意QoS等级发布，也可以采用任意QoS等级订阅，但最终发布端到订阅端的QoS的值为min(QoSSend，QoSReceive)。</p><p>QoS0：只发一次，不发确认。<br>QoS1：最少一次，需要确认。<br>QoS2：精确一次，四次握手。</p><h1 id="3-保持消息"><a href="#3-保持消息" class="headerlink" title="3 保持消息"></a>3 保持消息</h1><p>消息可以配置为保持消息，这意味着服务器在将消息发送到所有订阅的客户端之后，仍然会保存该消息。如果新的订阅到来，服务端会将保持消息发送到该客户端。在某些场景下，消息的更新频率很低，这个时候，如果新的客户端订阅消息时如果未保持消息，则新的客户端会等待比较长的时间；而如果进行了消息保持，则会立即获取到消息。</p><h1 id="4-清除会话-持久连接"><a href="#4-清除会话-持久连接" class="headerlink" title="4 清除会话/持久连接"></a>4 清除会话/持久连接</h1><p>客户端的clean session字段若为false，则认为是持久连接。在持久连接中，当客户端断链，那么它将要订阅的所有主题以及所有它订阅的QoS1和QoS2级别的消息将会存储到服务端，直到它重连。如果clean session字段为false，则在客户端断链之后，会清除所有会话相关内容。</p><h1 id="5-遗嘱"><a href="#5-遗嘱" class="headerlink" title="5 遗嘱"></a>5 遗嘱</h1><p>客户单连接到服务端后，可以给向服务端提供自己的遗嘱。这个遗嘱是在客户端意外断链的时候，服务端需要发布的消息。这个消息的主题，QoS和保持状态跟之前介绍的是一致的。</p><h1 id="6-桥接"><a href="#6-桥接" class="headerlink" title="6 桥接"></a>6 桥接</h1><p>关于Mosquitto桥接的配置在配置文档里面已经描述清楚，这里对其原理进行介绍：</p><img src="/2018/05/15/mosquttio%20cook/mosquitto桥接.jpg"><p>桥接在一台Mosquitto服务器配置。桥接服务器与其他服务器建立连接，并各自为该连接命名。</p><p>在某个客户端向任何一台Mosquitto服务器publish消息的时候，由于客户端连接订阅了该主题，那么服务器就会往该连接publish 消息。当其他broker收到publish消息，会将消息发布到对应的topic当中。</p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/05/15/mosquttio%20cook/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Jedis简介</title>
      <link>http://wzlovegit.github.io/2018/05/11/Jedis%20design/</link>
      <guid>http://wzlovegit.github.io/2018/05/11/Jedis%20design/</guid>
      <pubDate>Fri, 11 May 2018 10:34:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;1 简介&lt;/h1&gt;&lt;p&gt;Jedis是redis的Java客户端。它基于BIO实现。Jedis包含以下几个核心类与服务端交互：Jedis，JedisC
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>Jedis是redis的Java客户端。它基于BIO实现。Jedis包含以下几个核心类与服务端交互：Jedis，JedisCluster，ShardedJedis，JedisPool，JedisSentinelPool，ShardedJedisPool。通过本文加深对对象池化和连接管理的理解。</p><h1 id="2-Jedis简介"><a href="#2-Jedis简介" class="headerlink" title="2 Jedis简介"></a>2 Jedis简介</h1><img src="/2018/05/11/Jedis%20design/jedis.jpg" title="jedis"><h2 id="2-1-Jedis介绍"><a href="#2-1-Jedis介绍" class="headerlink" title="2.1 Jedis介绍"></a>2.1 Jedis介绍</h2><p>Jedis是对redis命令的封装，包括数据操作命令，哨兵相关命令，集群相关命令。Jedis对象封装了与redis服务器的Connection，因此它只能执行与redis服务器相关的命令；对于需要在redis-sentinel执行的命令需要采用JedisSentinel对象，JedisSentinel对象封装了客户端与redis-sentinel之间的连接；需要执行redis-cluster相关的命令则只能采用JedisCluster对象。</p><h2 id="2-2-Client介绍"><a href="#2-2-Client介绍" class="headerlink" title="2.2 Client介绍"></a>2.2 Client介绍</h2><p>Client用于封装与redis服务器的Connection。Client利用Connection执行sendCommand命令给服务端发送命令以外，还会进行鉴权，连接指定数据库等操作。</p><h2 id="2-3-Connection介绍"><a href="#2-3-Connection介绍" class="headerlink" title="2.3 Connection介绍"></a>2.3 Connection介绍</h2><p>Jedis的方法在有返回值的情况下大致分两步执行：1，将redis命令通过按照redis协议发往redis服务器；2，接收来自服务器的返回值并解析。第一步是写的过程，即将redis命令按照redis协议写入与redis服务器连接的Socket当中；第二步是读的过程，即将redis命令的执行结果从刚刚的Socket中读出来解析。</p><p>Socket的建立通过Connection封装管理。Socket为TCP的BIO实现，采用NODELAY，KEEPALIVE，超时时间默认2min的形式配置。情况下，2min足够redis将结果返回，但也不排除会抛出I/O异常。I/O异常会封装为JedisConnectionException向外抛。</p><h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h2><p>Jedis用于给使用者提供跟服务器基本一样的命令接口。Client用于鉴权、连接数据库，并且执行Jedis调用自己的指令。Connection用于管理与服务器之间的连接。Protocol用于完成命令的封装。分工非常清晰。</p><h1 id="3-JedisSentinel"><a href="#3-JedisSentinel" class="headerlink" title="3 JedisSentinel"></a>3 JedisSentinel</h1><img src="/2018/05/11/Jedis%20design/JedisSentinel.PNG" title="JedisSentinel"><p>并不存在JedisSentinel类。在执行redis-sentinel的命令时，其实也是采用的Jedis对象，不过Jedis对象中使用的连接是连接到redis-sentinel的。Jedis jedisSentinel = new Jedis(sentinel)；sentinel为redis-sentinel的ip和port。</p><h1 id="4-JedisCluster"><a href="#4-JedisCluster" class="headerlink" title="4 JedisCluster"></a>4 JedisCluster</h1><p>JedisCluster和Jedis不同，JedisCluster对象用于执行一些集群相关的命令。</p><h1 id="5-ShardedJedis"><a href="#5-ShardedJedis" class="headerlink" title="5 ShardedJedis"></a>5 ShardedJedis</h1><img src="/2018/05/11/Jedis%20design/ShardJedis.jpg" title="ShardJedis"><h2 id="5-1-ShardedJedis"><a href="#5-1-ShardedJedis" class="headerlink" title="5.1 ShardedJedis"></a>5.1 ShardedJedis</h2><p>ShardedJedis是基于客户端分片的redis客户端实现。ShardedJedis在执行命令的时候，首先获取key对应的分片使用的Jedis对象，然后通过该Jedis对象执行相应的命令。使用者不感知Jedis和分片的存在。如上图的get流程所示：ShardedJedis调用get方法，get方法里面会先获取key对应的Jedis，然后采用Jedis执行命令，然后将结果返回；整个过程使用者不感知分片和Jedis的存在。</p><img src="/2018/05/11/Jedis%20design/ShardedJedis1.jpg" title="ShardJedis"><h2 id="5-2-Sharded"><a href="#5-2-Sharded" class="headerlink" title="5.2 Sharded"></a>5.2 Sharded</h2><p>Sharded用于管理key与Jedis之间的关系。</p><ol><li>Sharded缓存key的hash值区间和ShardInfo的映射关系</li><li>Sharded缓存ShardInfo与Jedis的映射关系</li></ol><p>所以Sharded执行命令的过程如下：</p><ol><li>计算key的hash值应该落到那个区间</li><li>查看该区间对应的ShardInfo</li><li>查找ShardInfo对应的Jedis</li><li>利用Jedis对象发送命令给对应的redis服务器并获取结果</li><li>返回结果。</li></ol><h2 id="5-3-ShardedInfo"><a href="#5-3-ShardedInfo" class="headerlink" title="5.3 ShardedInfo"></a>5.3 ShardedInfo</h2><p>ShardedInfo有两个作用：</p><ol><li>存储多个redis服务器的信息</li><li>提供createResource方法创建对象</li></ol><h1 id="6-JedisPool"><a href="#6-JedisPool" class="headerlink" title="6 JedisPool"></a>6 JedisPool</h1><img src="/2018/05/11/Jedis%20design/JedisPool.jpg" title="JedisPool"><h2 id="6-1-JedisPool介绍"><a href="#6-1-JedisPool介绍" class="headerlink" title="6.1 JedisPool介绍"></a>6.1 JedisPool介绍</h2><p>JedisPool是Jedis对象池。Jedis对象中的连接为TCP长连接，TCP连接的创建需要三次握手，销毁需要四次挥手。如果每次执行一个redis命令都进行连接的创建和销毁，对于客户端和服务端来讲均有不小的毫无意义的开销。因而引入了Pool。</p><p>JedisPool提供getResource()方法，返回一个Jedis对象，用于执行redis命令。提供returnResource(returnBrokenResource)方法，将Jedis对象归回到Pool。</p><h2 id="6-2-GenericObjectPool"><a href="#6-2-GenericObjectPool" class="headerlink" title="6.2 GenericObjectPool"></a>6.2 GenericObjectPool</h2><p>GenericObjectPool是Pool的一种。它提供Pool中对象的借用（borrowObject）和归还（returnObject）的方法，管理Pool中对象的生命周期。它提供了一些配置参数用于管理对象池中对象的个数，对象的生命周期。</p><ul><li>maxIdle：Pool中最大空闲对象数</li><li>minIdle：Pool中最小空闲对象数</li><li>maxTotal：Pool中对象个数最大值</li><li>testOnBorrow：对象借出前合法性检查，不合法则销毁</li><li>testOnReturn：对象归还pool之前合法性检查，不合法则销毁</li></ul><h2 id="6-3-JedisFactory"><a href="#6-3-JedisFactory" class="headerlink" title="6.3 JedisFactory"></a>6.3 JedisFactory</h2><p>JedisFactory继承自PooledObjectFactory，用于提供对象生命周期管理的方法，供pool使用。PooledObjectFactory提供了对象的创建（makeObject）、激活（activateObject)、去激活（passivateObject)、销毁（destoryObject)、合法性检查（validateObject)方法。JedisFactory这些方法，makeObject创建Jedis对象；activateObject选择指定的数据库；destoryObject销毁Jedis对象；validateObject给服务器发送PING消息探测连接是否可用。</p><h1 id="7-JedisSentinelPool"><a href="#7-JedisSentinelPool" class="headerlink" title="7 JedisSentinelPool"></a>7 JedisSentinelPool</h1><p>JedisSentinelPool并不是客户端与哨兵之间的连接池，而是客户端通过redis-sentinel获取到redis-master的ip和port，然后建立与master之间的Jedis池。</p><p>JedisSentinelPool主要负责两个事情：1，监听redis-sentinel发布的切主事件，销毁与旧master之间的连接，建立与新master之间的连接；2，维护池中Jedis对象。</p><img src="/2018/05/11/Jedis%20design/JedisSentinelPool1.jpg" title="JedisSentinel"><h2 id="7-1-MasterListener"><a href="#7-1-MasterListener" class="headerlink" title="7.1 MasterListener"></a>7.1 MasterListener</h2><p>MasterListener是在JedisSentinelPool初始化的时候创建的，它订阅redis-sentinel的+switch-master主题，在发生主从切换的时候，哨兵将事件发布到该topic，然后MasterListener订阅到该信息，根据该信息，关闭与旧的主redis的连接，创建与新redis的连接。</p><h2 id="7-2-PooledObjectFactory"><a href="#7-2-PooledObjectFactory" class="headerlink" title="7.2 PooledObjectFactory"></a>7.2 PooledObjectFactory</h2><p>JedisSentinelPool默认的PooledObjectFactory是JedisFactory。该JedisFactory是管理与master连接的Jedis的对象生命周期的，因此JedisSentinelPool并没有创建大量的与redis-sentinel的连接，而是创建与master的连接。</p><h2 id="7-3-小结"><a href="#7-3-小结" class="headerlink" title="7.3 小结"></a>7.3 小结</h2><p>为什么JedisSentinelPool不直接依赖JedisPool实现呢？如果实现默认功能的话，确实可以直接饮用JedisPool的实现方法。但是有时候我们需要扩充JedisSentinelPool，比如扩充为ShardJedisSentinelPool，那么就可以考虑重新设计PooledObjectFactory并传递给JedisSentinelPool。</p><h1 id="8-ShardedJedisPool"><a href="#8-ShardedJedisPool" class="headerlink" title="8 ShardedJedisPool"></a>8 ShardedJedisPool</h1><p>ShardedJedisPool是ShardedJedis的对象池。它需要提供自己的PooledObjectFactory即ShardedJedisFactory。这里不再赘述。</p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/05/11/Jedis%20design/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java多线程服务启动和停止</title>
      <link>http://wzlovegit.github.io/2018/05/03/Java%20thread/</link>
      <guid>http://wzlovegit.github.io/2018/05/03/Java%20thread/</guid>
      <pubDate>Thu, 03 May 2018 12:33:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文从多线程服务的启动，运行，停止着手，深入了解Java多线程编程框架以及不同场景的解决方案。&lt;/p&gt;
&lt;h1 id=&quot;1-Java多线程服
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文从多线程服务的启动，运行，停止着手，深入了解Java多线程编程框架以及不同场景的解决方案。</p><h1 id="1-Java多线程服务启动和停止"><a href="#1-Java多线程服务启动和停止" class="headerlink" title="1 Java多线程服务启动和停止"></a>1 Java多线程服务启动和停止</h1><p>Java如何编写多线程代码？绝大部分人会想起Java的Excutor框架。如何管理多线程服务的生命周期？大家又会推荐ExcutorService。如何用好它们？哪些场景需要拓展它们？</p><h1 id="2-基础介绍"><a href="#2-基础介绍" class="headerlink" title="2 基础介绍"></a>2 基础介绍</h1><p>见Java多线程模型和Executor框架。</p><h1 id="3-服务启动"><a href="#3-服务启动" class="headerlink" title="3 服务启动"></a>3 服务启动</h1><p>线程启动，只需要start一下就可以启动线程，此处写服务启动，主要是为了介绍任务抽象。由2我们已经清楚了线程池的工作机制，那么通常我们会怎么抽象任务呢？</p><h2 id="3-1-Runnable任务"><a href="#3-1-Runnable任务" class="headerlink" title="3.1 Runnable任务"></a>3.1 Runnable任务</h2><p>Runnable任务用于无返回值不抛异常的任务。实践当中，我们会在run当中捕获各种异常，以免线程退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void hiWork(int i) &#123;</span><br><span class="line">    System.out.println(&quot;hi : &quot; + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HiWorkRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private int i;</span><br><span class="line"></span><br><span class="line">    HiWorkRunnable(int i) &#123;</span><br><span class="line">        this.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        hiWork(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-Callable任务"><a href="#3-2-Callable任务" class="headerlink" title="3.2 Callable任务"></a>3.2 Callable任务</h2><p>Callable任务带有返回值，并且可以抛出异常。它是Runnable任务一个非常好的补充。通常情况下，Callable任务的返回值并不期待立即返回，我们可以用一个Future对象来保存Callable的返回值。当Callable执行完毕，会将结果回填到对应的Future对象中。通过Future的get方法可以获取值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private String callHiWork(int i) &#123;</span><br><span class="line">    return &quot;call hi : &quot; + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HiWorkCallable implements Callable &#123;</span><br><span class="line">    private int i;</span><br><span class="line"></span><br><span class="line">    HiWorkCallable(int i) &#123;</span><br><span class="line">        this.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return callHiWork(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-服务停止"><a href="#4-服务停止" class="headerlink" title="4 服务停止"></a>4 服务停止</h1><p>服务停止，我们首先想到的是调用ExecutorService的shutdown和shutdownNow方法。</p><p>shutdown：平滑关闭ExecutorService，即等待Executor队列中的任务全部执行完毕，关闭线程池。<br>shutdownNow：立即关闭ExecutorService，即直接关闭线程池，Executor队列中的任务丢弃。</p><p>但有些场景下，我们已经执行了shutdown设置shutdownNow，可是任务就是关闭不掉。这是为什么呢？shutdown和shutdownNow本质上都是调用线程池中线程的interrupt方法，用于中断线程；不同点在于，shutdown等待任务执行完获取锁，即只调用空闲线程的interrupt方法，用于终止线程；而shutdownNow直接调用interrupt，不管是否处于空闲状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">shutdown退出线程</span><br><span class="line"></span><br><span class="line">    private void interruptIdleWorkers(boolean onlyOne) &#123;</span><br><span class="line">        final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            for (Worker w : workers) &#123;</span><br><span class="line">            //遍历worker，获取线程池中的线程</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                //如果线程处于非中断状态，则尝试获取锁，锁在线程执行完任务后可以获取成功</span><br><span class="line">                if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                    //执行线程中断方法</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                    &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        w.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (onlyOne)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shutdownNow强制退出线程</span><br><span class="line">    /**</span><br><span class="line">     * Interrupts all threads, even if active. Ignores SecurityExceptions</span><br><span class="line">     * (in which case some threads may remain uninterrupted).</span><br><span class="line">     */</span><br><span class="line">    private void interruptWorkers() &#123;</span><br><span class="line">        final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 遍历所有worker线程，对于运行中的线程执行中断函数</span><br><span class="line">            for (Worker w : workers)</span><br><span class="line">                w.interruptIfStarted();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为什么触发了线程本身的interrupt方法，还是无法中断线程呢？interrupt方法只是标记线程状态为中断状态，并不会立即杀死线程。线程运行过程中如果有响应中断的函数，则会终止，如果没有，则无法终止。</p><p>这里就需要我们注意：</p><ol><li>同步socket I/O</li><li>等待锁<br>这两种阻塞无法响应中断。如果我们采用Future对象来管理任务的生命周期，则可以通过复写ThreadPoolExecutor的NewTaskFor方法来制定自己的RunnableFuture对象。</li></ol><h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h1><p>响应中断的位置有很多，通常情况下，我们希望在循环入口处响应，这样我们可以完整执行完一个任务。<br>对于大部分任务，通过在循环入口处检查线程中断状态或者循环入口处设置boolean型变量均可以完成线程的正常退出。<br>对于部分复杂任务，则需要考虑到shutdown和shutdownNow的局限性。通过复写ThreadPoolExecutor的NewTaskFor方法，更加针对性的控制任务生命周期。</p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/05/03/Java%20thread/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java内存分配和回收</title>
      <link>http://wzlovegit.github.io/2018/03/31/Jvm%20memory/</link>
      <guid>http://wzlovegit.github.io/2018/03/31/Jvm%20memory/</guid>
      <pubDate>Sat, 31 Mar 2018 15:40:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;1 简介&lt;/h1&gt;&lt;p&gt;我不会JVM开发，但是加深对JVM的理解可以帮助我们编写更好的服务。目前我只了解了一下JVM的内存相关的内容，比如怎么分配内
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>我不会JVM开发，但是加深对JVM的理解可以帮助我们编写更好的服务。目前我只了解了一下JVM的内存相关的内容，比如怎么分配内存空间可以减少gc次数，如何调整JVM参数提升程序性能，如何定位OOM的问题。</p><h1 id="2-JVM-内存布局"><a href="#2-JVM-内存布局" class="headerlink" title="2 JVM 内存布局"></a>2 JVM 内存布局</h1><ol><li>线程独享内存</li></ol><ul><li>PC：程序计数器，线程切换时需要保存当前执行状态，PC用于记录线程将要执行的下一条指令。</li><li>虚拟机栈：JVM在执行函数的过程中，需要存储局部变量、参数、返回值等，用到虚拟机栈</li><li>本地方法栈：JVM调用本地方法执行，需要存储局部变量、参数、返回值等，用到本地方法栈</li></ul><ol><li>线程共享内存</li></ol><ul><li>heap：堆内存通常是JVM最大的内存，用于存储对象实体</li><li>方法区：用于存放代码指令、常量等</li></ul><img src="/2018/03/31/Jvm%20memory/jvm内存布局.png" title="jvm内存布局"><h1 id="3-GC-Root"><a href="#3-GC-Root" class="headerlink" title="3 GC Root"></a>3 GC Root</h1><ul><li>虚拟机栈中的引用指向的对象</li><li>本地方法栈中的引用指向的对象</li><li>类中静态变量指向的对象</li><li>类中静态方法使用的对象</li><li>类中常量引用（final修饰）指向的常量</li></ul><p>从图jvm内存布局可以看出，GC Root其实就是heap内存之外的内存中的一些引用指向的对象。堆中引用指向的对象属于间接的，不属于GC Root。</p><h1 id="4-JVM-内存回收算法"><a href="#4-JVM-内存回收算法" class="headerlink" title="4 JVM 内存回收算法"></a>4 JVM 内存回收算法</h1><h2 id="4-1-标记清除-Mark-Sweep"><a href="#4-1-标记清除-Mark-Sweep" class="headerlink" title="4.1 标记清除 Mark-Sweep"></a>4.1 标记清除 Mark-Sweep</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>先标记哪些内存需要回收</li><li>清除标记要删除的内存</li></ol><p>首先将用过的内存空间标记为已用，在gc的时候，首先根据GC Root标记需要被回收的对象，然后将这些被回收的对象所占用的空间标记为可用。此时jvm在分配堆内存的时候，就可以在这些标记为可用的内存当中开辟空间。</p><img src="/2018/03/31/Jvm%20memory/mark-sweep.png" title="mark-sweep"><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ol><li>内存碎片。由于对象占用的内存就地回收，所以内存碎片会越来越严重，最终导致内存无法分配给对象使<br>用。由mark-sweep图可以看出3个方格大的对象分配内存失败，虽然内存当中有足够的空间可以使用。</li></ol><p>为了解决内存碎片，在内存使用到一定程度后，就需要进行内存整理，将对象搬到一起存储。CMS垃圾回收器就是采用的这种机制，触发内存整理的参数为CMSInitiatingOccupancyFraction、UseCMSCompactAtFullCollection、CMSFullGCsBeforeCompaction。</p><h2 id="4-2-复制"><a href="#4-2-复制" class="headerlink" title="4.2 复制"></a>4.2 复制</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><ol><li>划分出一部分区域用于给新生成的对象分配空间</li><li>划分出的一部分区域被用完之后，复制到另外一份空闲区域</li></ol><img src="/2018/03/31/Jvm%20memory/copy.png" title="copy"><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ol><li>内存中有一部分无法使用，我们可以看出内存最多可以使用S + E的空间。</li><li>对象移动</li><li>无内存碎片</li></ol><p>由于服务当中大部分的对象是朝生夕死的，所以复制算法作为新生代的回收算法，由于对象存活概率低，S空间可以变小，对象移动也会变少，所以复制算法很适合作为新生代垃圾回收算法。</p><h2 id="4-3-标记整理-Mark-Compact"><a href="#4-3-标记整理-Mark-Compact" class="headerlink" title="4.3 标记整理 Mark-Compact"></a>4.3 标记整理 Mark-Compact</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><ol><li>标记哪些内存需要回收</li><li>将不被回收的内存整理到一起</li></ol><img src="/2018/03/31/Jvm%20memory/mark-compact.png" title="mark-compact"><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ol><li>减少内存碎片</li><li>对象移动少</li><li>不需要浪费内存空间</li></ol><h1 id="5-JVM-垃圾回收器"><a href="#5-JVM-垃圾回收器" class="headerlink" title="5 JVM 垃圾回收器"></a>5 JVM 垃圾回收器</h1><img src="/2018/03/31/Jvm%20memory/垃圾回收器.png"><h2 id="5-1-Serial-新生代内存回收机制，复制算法"><a href="#5-1-Serial-新生代内存回收机制，复制算法" class="headerlink" title="5.1 Serial: 新生代内存回收机制，复制算法"></a>5.1 Serial: 新生代内存回收机制，复制算法</h2><img src="/2018/03/31/Jvm%20memory/serial.png" title="serial"><p>STOP THE WORLD听着很厉害，但是真正出现的时候，通常面临着痛苦。比如，在大量任务执行的过程中，本来一秒处理100个，突然就变成了几个，用图形化界面展示出来就是一个暴跌的曲线。这通常象征着需要加班了。所以串行gc在多CPU的情况下，不推荐。</p><h2 id="5-2-ParNew：Serial算法的并行版本"><a href="#5-2-ParNew：Serial算法的并行版本" class="headerlink" title="5.2 ParNew：Serial算法的并行版本"></a>5.2 ParNew：Serial算法的并行版本</h2><img src="/2018/03/31/Jvm%20memory/ParNew.png"><p>ParNew是Serial的并行实现。它同样存在STOP THE WORLD的限制。但并行版本在多核情况下通常会有更优秀的回收效率。比较难受的一点是ParNew如果设置为新生代垃圾回收器，那么老年代只能用Serial-Old回收器。Serial-Old是标记整理算法的串行版本的实现，也无法利用多核优势。</p><h2 id="5-3-Serial-old：-老年代内存回收机制"><a href="#5-3-Serial-old：-老年代内存回收机制" class="headerlink" title="5.3 Serial-old： 老年代内存回收机制"></a>5.3 Serial-old： 老年代内存回收机制</h2><p>老年代垃圾回收器，标记整理算法，有STOP THE WORLD的限制，并且无法利用多核性能。但可以与ParNew、Serial和Parallel Scanvege搭配使用。也是CMS无法整理内存的时候采用的后继方案。</p><h2 id="5-4-ParOld：-Serial-Old的并行版本"><a href="#5-4-ParOld：-Serial-Old的并行版本" class="headerlink" title="5.4 ParOld： Serial-Old的并行版本"></a>5.4 ParOld： Serial-Old的并行版本</h2><h2 id="5-5-Par-Scanverge-吞吐优先考虑的垃圾回收器"><a href="#5-5-Par-Scanverge-吞吐优先考虑的垃圾回收器" class="headerlink" title="5.5 Par Scanverge 吞吐优先考虑的垃圾回收器"></a>5.5 Par Scanverge 吞吐优先考虑的垃圾回收器</h2><h2 id="5-6-CMS"><a href="#5-6-CMS" class="headerlink" title="5.6 CMS"></a>5.6 CMS</h2><img src="/2018/03/31/Jvm%20memory/CMS.png"><p>Java 1.6之前的常用的老年代垃圾回收器。虽然初始标记和重新标记都会STW，但是它们执行都比较快，可以将对用户线程的影响降到最低。</p><p>缺点：</p><ol><li>CPU敏感，占用（CPU + 3）/4的CPU资源进行GC</li><li>无法处理浮动垃圾，即一边标记一边由用户线程产生的垃圾，会导致CMS失败，此时会处罚Serial-old再一次进行GC</li><li>标记清除算法的局限性。需要配置内存整理阈值触发内存整理。</li></ol><h2 id="5-7-G1GC"><a href="#5-7-G1GC" class="headerlink" title="5.7 G1GC"></a>5.7 G1GC</h2><p>新一代垃圾回收器。将内存划分为很多的Region，回收的时候进行小范围回收。1.7之后通常在Server端采用G1GC。虽然书上介绍说G1GC在吞吐上对比与CMS并没有优势，但是随着其发展，应该会不断提升。</p><h1 id="JVM-内存管理常用参数实战配置"><a href="#JVM-内存管理常用参数实战配置" class="headerlink" title="JVM 内存管理常用参数实战配置"></a>JVM 内存管理常用参数实战配置</h1><p>Xms : 最小申请内存。 1G<br>Xmx : 最大申请内存。 4G。虽然64bits虚拟机可以配置更大的运行内存，但通常服务不应该去依靠自己内存存储大量的内容，这在异常情况下可能导致任务丢失。而且在OOM进行dump的时候，过大的内存会导致dump文件很大，对于获取信息不利。<br>UseG1GC : G1GC通常是我们队垃圾回收器的选择，因为新，期待G1团队可以将其优化的更好。<br>server : 服务端开启server模式<br>打印gc日志<br>+HeapDumpOnOutOfMemoryError : 内存溢出打印heapdump文件<br>HeapDumpPath=/path/heap/dump :  heapdump文件路径<br>+PrintGCDeatils : 打印垃圾回收的细节信息<br>Xloggc:<filename> : 将垃圾回收信息输出到指定文件<br>+PrintGCDateStamps : 需要打印日历形式的时间戳选项</filename></p><h1 id="JAVA-内存问题定位手段"><a href="#JAVA-内存问题定位手段" class="headerlink" title="JAVA 内存问题定位手段"></a>JAVA 内存问题定位手段</h1><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>命令：jmap -dump:format=b,file=heap.bin</p><p>file：保存路径及文件名<br>pid：进程编号（windows通过任务管理器查看，linux通过ps aux查看）</p><p>dump文件可以通过MemoryAnalyzer(MAT)分析查看,可以查看dump时对象数量，内存占用，线程情况等。</p><p>通常情况下我们不会用jhat分析jmap信息，第一jhat消耗服务器资源；第二jhat的分析能力还不上javaVisualvm。</p><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>jstat是查看java进程内存和gc的神器，通常配置参数jstat -gcutil {pid}</p><h1 id="JAVA-CPU问题定位手段"><a href="#JAVA-CPU问题定位手段" class="headerlink" title="JAVA CPU问题定位手段"></a>JAVA CPU问题定位手段</h1><p>jps<br>ps -mp pid -o THREAD,tid,time<br>jstack</p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/03/31/Jvm%20memory/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java多线程模型和Executor框架</title>
      <link>http://wzlovegit.github.io/2018/03/24/Java%20executor/</link>
      <guid>http://wzlovegit.github.io/2018/03/24/Java%20executor/</guid>
      <pubDate>Sat, 24 Mar 2018 15:40:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;1 简介&lt;/h1&gt;&lt;p&gt;本文主要介绍Java多线程模型以及Java成熟的线程池框架Executor框架。线程模型分为单线程、无限多线程、线程池模型。
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>本文主要介绍Java多线程模型以及Java成熟的线程池框架Executor框架。线程模型分为单线程、无限多线程、线程池模型。Executor直接创建线程池的方法通常不推荐使用，除非你明确知道它的含义；在实际应用过程中我们还是会通过ThreadPoolExecutor定制自己想要的线程池，以便控制内存和CPU利用率，提升系统稳定性。</p><h1 id="2-线程模型"><a href="#2-线程模型" class="headerlink" title="2 线程模型"></a>2 线程模型</h1><h2 id="2-1-线程和进程"><a href="#2-1-线程和进程" class="headerlink" title="2.1 线程和进程"></a>2.1 线程和进程</h2><p>线程是OS任务调度的基本单位，进程是OS资源分配的基本单位。什么意思？</p><ul><li>OS在分配内存地址空间的时候，是以进程分配的。即一个进程享有虚拟地址空间的访问权限；该进程不可以访问其他进程地址空间中的资源。然而该进程中的线程可以共享该进程的地址空间。</li><li>OS在调度任务执行的时候，是以线程调度的。即如果当前CPU有空闲，需要让它run任务，那么就会选择一个线程来执行任务。</li></ul><h2 id="2-2-任务和线程模型"><a href="#2-2-任务和线程模型" class="headerlink" title="2.2 任务和线程模型"></a>2.2 任务和线程模型</h2><p>Java当中将任务的生成和任务的执行分别做了抽象。</p><p><strong>任务</strong>：定义招待客人的hiWork任务，对每个传递进来的整型值say hi：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void hiWork(int i) &#123;</span><br><span class="line">System.out.println(&quot;hi : &quot; + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-单线程"><a href="#2-2-1-单线程" class="headerlink" title="2.2.1 单线程"></a>2.2.1 单线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread t = new Thread() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">int i = 0;</span><br><span class="line">while (i &lt; 100) &#123;</span><br><span class="line">hiWork(i);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个线程循环执行所有任务。<br>优点：</p><ul><li>不用考虑临界资源、锁带来的线程活跃性问题：因为只有一个线程执行，不会出现临界资源争用，不会出现死锁，也不会饿死任务。</li></ul><p>缺点：</p><ul><li>系统资源利用率低。多个CPU只能使用1个。</li><li>吞吐和响应都很差。后面的任务必须等待前面的任务执行完。<h3 id="2-2-2-一个任务一个线程"><a href="#2-2-2-一个任务一个线程" class="headerlink" title="2.2.2 一个任务一个线程"></a>2.2.2 一个任务一个线程</h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">while (i &lt; 100) &#123;</span><br><span class="line">Thread t = new Thread() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">hiWork(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个任务分配一个线程。<br>优点：</p><ul><li>响应速度快。任务会直接被拿走执行，不用等待其他任务。</li><li>资源利用率高。多个任务同时执行，CPU使用率高。</li></ul><p>缺点：</p><ul><li>需要考虑多线程活跃性。死锁，饥饿等。</li><li>线程创建销毁频繁带来的资源消耗大。</li><li>线程过多可能导致系统崩溃。线程本身也在OS当中占用资源。过多的线程，会导致OS资源用光，挂掉。</li><li>线程过多可能导致频繁切换。CPU个数有限，过多的线程会引起CPU不断切换线程执行，浪费资源。<h3 id="2-2-3-线程池"><a href="#2-2-3-线程池" class="headerlink" title="2.2.3 线程池"></a>2.2.3 线程池</h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = ...;</span><br><span class="line">int i = 0;</span><br><span class="line">while (i &lt; 100) &#123;</span><br><span class="line">excutor.excute(new Runnable() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">hiWork(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个线程分别执行不同的任务。<br>优点：</p><ul><li>吞吐和响应好</li><li>不会频繁创建销毁线程</li><li>不会由于任务过多导致线程太多系统崩溃</li><li>不会导致频繁线程切换<br>这么一看就像完美了一样。其实从实际使用来看，这种方案确实很6。</li></ul><p>缺点：</p><ul><li>多线程活跃性。死锁、饥饿等。</li></ul><h2 id="2-2-4-结论"><a href="#2-2-4-结论" class="headerlink" title="2.2.4 结论"></a>2.2.4 结论</h2><p>对比以上三种的优缺点，找到任务类型，选择合适的线程模型。比如，强烈要求顺序性的任务，我们会选择类似于第一种的方案，保证顺序性；比如互相独立的任务，我们会选择类似第三种的方案，保证高吞吐，低延时。</p><h1 id="3-Executor-线程框架"><a href="#3-Executor-线程框架" class="headerlink" title="3 Executor 线程框架"></a>3 Executor 线程框架</h1><img src="/2018/03/24/Java%20executor/Executors.png" title="Executors框架"><p>Java的线程框架Executor将任务和执行任务的线程分离开来。线程池当中的线程就像工人一样，不断从传送带上提取任务，处理完之后，再从传送带上获取下一个任务，循环往复。线程池细节很多，本小节对线程池创建、任务执行、任务提交方式进行简单介绍。若我们不去定制ThreadPoolExecutor，那么本节介绍的就是Executor的原理。如果定制了线程池，那么它便会有不同的表现。</p><h2 id="3-1-线程池构造函数"><a href="#3-1-线程池构造函数" class="headerlink" title="3.1 线程池构造函数"></a>3.1 线程池构造函数</h2><p>看一下线程池的构造函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial</span><br><span class="line"> * parameters.</span><br><span class="line"> *</span><br><span class="line"> * @param corePoolSize 线程池中即使某些线程处于idle状态，也要有corePoolSize个线程</span><br><span class="line"> *        除非设置&#123;@code allowCoreThreadTimeOut&#125;</span><br><span class="line"> * @param maximumPoolSize 线程池中最多允许存在maxmumPoolSize个线程</span><br><span class="line"> * @param keepAliveTime 当线程池中的线程个数超过了corePoolSize，那么线程如果在keepAliveTime时间内</span><br><span class="line"> *        还是一直处于空闲状态，则终止该线程</span><br><span class="line"> * @param unit &#123;@code keepAliveTime&#125; 参数的时间单位</span><br><span class="line"> * @param workQueue 任务执行之前会先提交到workQueue队列。该队列只接收execute方法提交的Runnable任务</span><br><span class="line"> * @param threadFactory 线程创建工厂</span><br><span class="line"> * @param handler 当提交任务由于线程绑定或队列已满被阻塞时，采用handler句柄处理</span><br><span class="line"> * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;</span><br><span class="line"> *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt;</span><br><span class="line"> *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt;</span><br><span class="line"> *         &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span><br><span class="line"> *         &#123;@code maximumPoolSize &lt; corePoolSize&#125;</span><br><span class="line"> * @throws NullPointerException if &#123;@code workQueue&#125;</span><br><span class="line"> *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null</span><br><span class="line"> */</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.acc = System.getSecurityManager() == null ?</span><br><span class="line">            null :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知，线程池需要我们提供几个策略：</p><ol><li>任务队列</li><li>任务队列满之后的处理方式</li><li>线程池线程个数区间</li><li>线程池中线程在idle状态下能活多长时间</li><li>线程池中线程的创建方式</li></ol><h2 id="3-2-任务队列"><a href="#3-2-任务队列" class="headerlink" title="3.2 任务队列"></a>3.2 任务队列</h2><p>BlockedQueue提供offer put take poll等方法完成对任务的提交和获取。任务队列可以根据自己的想法，配置有界队列，无界队列。实践表明：</p><ol><li>配置有界队列，保证内存可控，否则可能由于处理不急导致OOM。</li><li>可以选择FIFO队列或者优先级队列。</li><li>队列的线程安全性已经在Executor框架当中实现，所以没必要自己从头实现一个阻塞队列，只需要扩充。</li></ol><h3 id="3-2-1-如何向线程池提交任务"><a href="#3-2-1-如何向线程池提交任务" class="headerlink" title="3.2.1 如何向线程池提交任务"></a>3.2.1 如何向线程池提交任务</h3><p>execute执行的时候，默认采用的BlockedQueue的offer方法。队列不满的情况下，任务将被提交到队列当中；如果队列已满，则会执行RejectExecutionHandler指定的方法，不会产生阻塞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    /*</span><br><span class="line">     * Proceed in 3 steps:</span><br><span class="line">     *</span><br><span class="line">     * 1. 如果线程池中的线程数小于corePoolSize，则把当前任务command作为第一个任务给新创建的线程</span><br><span class="line">     *    创建失败，则在之前的线程当中执行</span><br><span class="line">     *</span><br><span class="line">     * 2. If a task can be successfully queued, then we still need</span><br><span class="line">     * to double-check whether we should have added a thread</span><br><span class="line">     * (because existing ones died since last checking) or that</span><br><span class="line">     * the pool shut down since entry into this method. So we</span><br><span class="line">     * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">     * stopped, or start a new thread if there are none.</span><br><span class="line">     *</span><br><span class="line">     * 3. 如果我们添加任务队列失败，则创建新的线程去执行该任务，如果创建失败，则执行reject</span><br><span class="line">     */</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        else if (workerCountOf(recheck) == 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command); // 执行reject函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>submit &amp;&amp; execute</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @throws RejectedExecutionException &#123;@inheritDoc&#125;</span><br><span class="line"> * @throws NullPointerException       &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;</span><br><span class="line">    if (task == null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>submit提交任务之后，会先生成一个RunnableFuture对象来管理提交任务的生命周期，然后调用execute去提交任务。</p><h2 id="3-3-任务队列满之后的处理方式"><a href="#3-3-任务队列满之后的处理方式" class="headerlink" title="3.3 任务队列满之后的处理方式"></a>3.3 任务队列满之后的处理方式</h2><p>Executor框架调用executor提交任务，executor调用BlockedQueue的offer方法提交任务。如果队列不满，则提交成功；如果队列满，则offer返回false，转而执行RejectExecutionHandler提供的方法。那么RejectExecutionHandler方法如何处理呢？</p><h3 id="3-3-1-任务不能丢失的情况"><a href="#3-3-1-任务不能丢失的情况" class="headerlink" title="3.3.1 任务不能丢失的情况"></a>3.3.1 任务不能丢失的情况</h3><ol><li><p>阻塞任务提交<br>缺点：1）任务延时；2）任务全部阻塞到任务队列，可能引发内存溢出；3）提交任务的线程可能需要做其他重要工作却被阻塞；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static class MyKeepPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               e.getQueue().put(r);</span><br><span class="line">               break;</span><br><span class="line">           &#125; catch (InterruptException e) &#123;</span><br><span class="line">               ;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在任务提交线程执行任务<br>优点：1）不丢任务；2）任务在任务提交线程执行，可以不阻塞任务提交线程；3）任务的形成速度得到一定程度降低；<br>缺点：1）任务延时；2）时序问题，最后提交不进去的任务，反而比队列中的任务先获得处理权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Creates a &#123;@code CallerRunsPolicy&#125;.</span><br><span class="line">     */</span><br><span class="line">    public CallerRunsPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Executes task r in the caller&apos;s thread, unless the executor</span><br><span class="line">     * has been shut down, in which case the task is discarded.</span><br><span class="line">     *</span><br><span class="line">     * @param r the runnable task requested to be executed</span><br><span class="line">     * @param e the executor attempting to execute this task</span><br><span class="line">     */</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        if (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-3-2-任务可以丢失的情况"><a href="#3-3-2-任务可以丢失的情况" class="headerlink" title="3.3.2 任务可以丢失的情况"></a>3.3.2 任务可以丢失的情况</h3><ol><li><p>抛出异常，将处理权转交给任务提交线程<br>优点：1）控制权转移到任务提交线程；2）不会稀里糊涂丢任务；3）不会阻塞后续任务<br>缺点：1）抛出了异常通常情况下也没有更好的办法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">            throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br><span class="line">                                                 &quot; rejected from &quot; +</span><br><span class="line">                                                 e.toString());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>选择默默丢弃：通常不会这样做，稀里糊涂丢任务，在实际情况下通常是不能容忍的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A handler for rejected tasks that silently discards the</span><br><span class="line"> * rejected task.</span><br><span class="line"> */</span><br><span class="line">public static class DiscardPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Creates a &#123;@code DiscardPolicy&#125;.</span><br><span class="line">     */</span><br><span class="line">    public DiscardPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Does nothing, which has the effect of discarding task r.</span><br><span class="line">     *</span><br><span class="line">     * @param r the runnable task requested to be executed</span><br><span class="line">     * @param e the executor attempting to execute this task</span><br><span class="line">     */</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>选择丢弃最前面的任务：这个策略通常也不会和优先级队列连用，会导致优先级最高的任务被丢弃</p><h2 id="3-4-线程池中线程个数区间"><a href="#3-4-线程池中线程个数区间" class="headerlink" title="3.4 线程池中线程个数区间"></a>3.4 线程池中线程个数区间</h2><p>最小线程数：从任务队列中取出任务之后，会创建线程执行任务，执行完任务之后，如果线程总数小于等于最小线程数，则线程不会退出。<br>最大线程数：当线程都忙以后，从任务获取队列会创建新的线程，直到达到最大线程数。</p></li></ol><h2 id="3-5-线程池中线程在idle状态下能活多长时间"><a href="#3-5-线程池中线程在idle状态下能活多长时间" class="headerlink" title="3.5 线程池中线程在idle状态下能活多长时间"></a>3.5 线程池中线程在idle状态下能活多长时间</h2><p>达到最大线程数之后，如果线程处于空闲状态，超过参数设置的时长，则超出的线程会不断退出。</p><h2 id="3-6-线程池中线程的创建方式"><a href="#3-6-线程池中线程的创建方式" class="headerlink" title="3.6 线程池中线程的创建方式"></a>3.6 线程池中线程的创建方式</h2><h3 id="3-6-1-线程创建和任务执行"><a href="#3-6-1-线程创建和任务执行" class="headerlink" title="3.6.1 线程创建和任务执行"></a>3.6.1 线程创建和任务执行</h3><p>线程池中的线程被封装为Worker。Worker中thread的创建方式跟我们通常采取的方法一样，new Thread之后复写run方法。run方法中采用poll或者take的方式从BlockedQueue当中获取任务，并执行。时序图和代码如下：</p><img src="/2018/03/24/Java%20executor/线程池时序.png" title="线程池执行任务时序"><p>黑色是正常流程，红色为异常流程，绿色为线程池。获取任务的时候，采用的poll或者take的方法。在任务队列不空的情况下，会返回一个任务；在任务队列为空的情况下，会阻塞。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 从ThreadFactory创建thread，如果有初始任务，就会先执行初始任务</span><br><span class="line">  * @param firstTask the first task (null if none)</span><br><span class="line">  */</span><br><span class="line"> Worker(Runnable firstTask) &#123;</span><br><span class="line">     setState(-1); // inhibit interrupts until runWorker</span><br><span class="line">     this.firstTask = firstTask; //第一个任务</span><br><span class="line">     this.thread = getThreadFactory().newThread(this); // 创建线程，见下面一片代码</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Thread newThread(Runnable r) &#123;</span><br><span class="line">    Thread t = new Thread(group, r,</span><br><span class="line">                          namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                          0); // 创建线程对象</span><br><span class="line">    if (t.isDaemon())</span><br><span class="line">        t.setDaemon(false); // 非守护线程</span><br><span class="line">    if (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">        t.setPriority(Thread.NORM_PRIORITY); // 设置优先级</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final class Worker</span><br><span class="line">    extends AbstractQueuedSynchronizer</span><br><span class="line">    implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    /** Delegates main run loop to outer runWorker  */</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        runWorker(this);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果有任务task或者从队列当中获取到了任务，则执行该任务</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            w.lock(); // 任务执行时，需要保证任务不被其他线程池中断，只能由自己中断</span><br><span class="line">            // 任务执行之前检查线程是否处于需要被中断的状态，如果是，则设置线程中断标志位</span><br><span class="line">            // 如果不是，则清除掉线程中断位，使得其他线程不能中断该线程</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 回调任务执行之前的一些操作，通常情况下，不会干啥，但给我们提供了扩展execute的方法</span><br><span class="line">                beforeExecute(wt, task); </span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run(); // 任务执行</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown); // 回调任务执行之后的操作</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task = null;</span><br><span class="line">                w.completedTasks++; // 完成的任务数 +1</span><br><span class="line">                w.unlock(); // 释放锁</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 任务执行过程中出现不能处理的错误和异常，会导致while退出，执行线程退出操作</span><br><span class="line">        processWorkerExit(w, completedAbruptly); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    boolean timedOut = false; // Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // Check if queue empty only if necessary.</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        // Are workers subject to culling?</span><br><span class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"> // 线程池中线程超过最大值，或者获取任务超时；并且任务队列为空，那么减少线程池中线程个数</span><br><span class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : // 获取任务超时返回</span><br><span class="line">                workQueue.take(); // 或者阻塞直到获取任务</span><br><span class="line">            if (r != null)</span><br><span class="line">                return r;</span><br><span class="line">            timedOut = true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h2><ol><li>Executor框架已经实现了成熟的任务队列和线程池</li><li>Executor建议采用ThreadPoolExecutor去初始化， 不建议使用默认方式</li><li>线程执行过程中，在入口处捕获大异常，而不是让线程直接跑飞，查询不到异常日志。</li><li>对于不重要的任务，可以选择抛异常的形式交给任务提交线程处理；对于重要的任务，可以选择阻塞的方式，或者将任务转移的方式处理。具体策略依据业务而定。</li></ol><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>通过本篇介绍，相信可以了解到多线程的优缺点以及EXECUTOR框架的注意事项。这样我们就可以根据优缺点为我们的业务选择合适的线程池配置。通过对Executor框架源码的部分了解，也避免我们犯一些低级错误，导致OOM和稀里糊涂丢任务或者线程阻塞。</p><p><strong>完</strong></p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/03/24/Java%20executor/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://wzlovegit.github.io/2018/03/11/hello-world/</link>
      <guid>http://wzlovegit.github.io/2018/03/11/hello-world/</guid>
      <pubDate>Sun, 11 Mar 2018 09:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>]]></content:encoded>
      
      <comments>http://wzlovegit.github.io/2018/03/11/hello-world/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
